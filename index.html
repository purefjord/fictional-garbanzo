<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Turn‑Based Hex Prototype – Milestone 10.5 (Auto Player Spawn)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
      html,body{margin:0;padding:0;overflow:hidden;background:#111; /* Darker bg for FoW */ font-family:system-ui,sans-serif; color: #eee;}
      #endTurnBtn{position:absolute;top:12px;right:12px;padding:8px 14px;font-size:16px;border:none;border-radius:8px;background:#ffbd59;color:#222;cursor:pointer}
      #endTurnBtn:disabled{background:#555;color:#999;cursor:not-allowed}
      #uiContainer { display: flex; justify-content: space-between; position: absolute; top: 50px; bottom: 50px; left: 10px; right: 10px; pointer-events: none; }
      #orderPanel { width: 180px; height: fit-content; max-height: calc(100vh - 110px); background: #2a2e37cc; border-radius: 6px; padding: 8px; overflow-y: auto; pointer-events: all; display: flex; flex-direction: column; gap: 4px; }
      #logPanelContainer { position: absolute; bottom: 10px; left: 10px; width: calc(100% - 220px); max-width: 600px; height: 100px; pointer-events: all; }
      #logPanel { background: #1c1f26cc; border-radius: 6px; padding: 8px; font-family: monospace; font-size: 12px; color: #ccc; height: 100%; overflow-y: scroll; white-space: pre-wrap; }
      .orderItem { background: #3a3f4c; border-radius: 4px; padding: 4px 8px; display: flex; align-items: center; justify-content: space-between; cursor: default; }
      .orderItem:hover { background: #4a4f5c; }
      .orderLabel { display: flex; align-items: center; gap: 6px; font-size: 13px; }
      .orderIcon { width: 16px; height: 16px; border-radius: 3px; display: inline-block; flex-shrink: 0; }
      .orderText { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .orderControls button { background: #5a5f6c; border: none; color: #ddd; border-radius: 3px; cursor: pointer; font-size: 10px; padding: 1px 4px; margin-left: 2px; }
      .orderControls button:hover { background: #ff5555; }
      .orderControls button.reorderBtn { background: #6a6f7c; }
      .orderControls button.reorderBtn:hover { background: #7a7f8c; }
      .tooltip { position: absolute; background: #111; color: #eee; padding: 5px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap; pointer-events: none; z-index: 1000; border: 1px solid #555; }
      .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 1999; display: none; }
      .modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #2a2e37; border-radius: 8px; padding: 20px; z-index: 2000; min-width: 300px; max-width: 450px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); display: none; border: 1px solid #555; }
      .modal h3 { margin-top: 0; color: #ffbd59; }
      .modal p { margin-bottom: 15px; font-size: 14px; line-height: 1.5; }
      .modal-buttons { display: flex; justify-content: flex-end; gap: 10px; }
      .modal-buttons button { padding: 8px 15px; font-size: 14px; border: none; border-radius: 5px; cursor: pointer; }
      .modal-buttons button.primary { background: #4d73ff; color: white; }
      .modal-buttons button.secondary { background: #5a5f6c; color: #ddd; }
      .modal-buttons button:hover { opacity: 0.9; }
      #combatUiContainer { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); z-index: 1500; background: #1c1f26cc; padding: 10px; border-radius: 8px; display: none; flex-direction: column; align-items: center; gap: 8px; }
      #combatRoundBanner { font-size: 16px; color: #ffbd59; padding: 5px 10px; background: #2a2e37; border-radius: 4px; }
      #combatActionButtons { display: block; }
      #combatActionButtons button { padding: 8px 15px; font-size: 14px; border: none; border-radius: 5px; cursor: pointer; background: #4d73ff; color: white; margin: 0 5px; }
      #combatActionButtons button:hover { opacity: 0.9; }
      #combatActionButtons button:disabled { background: #555; color: #999; cursor: not-allowed; }
    </style>
  </head>
  <body>
    <div id="uiContainer">
        <div id="orderPanel"></div>
    </div>
    <div id="logPanelContainer">
      <pre id="logPanel"></pre>
    </div>
    <button id="endTurnBtn" disabled>End Turn</button>
    <div id="eventModalBackdrop" class="modal-backdrop"></div>
    <div id="eventModal" class="modal">
        <h3 id="eventModalTitle">Event Title</h3>
        <p id="eventModalBody">Event description text goes here. Make a choice!</p>
        <div id="eventModalButtons" class="modal-buttons"></div>
    </div>
    <div id="combatUiContainer">
        <div id="combatRoundBanner">Round 1 / 5</div>
        <div id="combatActionButtons">
            <button id="combatAttackBtn">Attack</button>
            <button id="combatMoveBtn">Move</button>
            <button id="combatRetreatBtn">Retreat</button>
        </div>
    </div>

    <script>
      /* ==========================================================
         TURN‑BASED HEX PROTOTYPE (p5.js) – Milestone 10.5 (Auto Player Spawn)
      ========================================================== */

      /* ===== CONSTANTS ===== */
      const CONSTS = {
        SQRT3: Math.sqrt(3), HEX_WIDTH_FACTOR: 1.5, // For flat-topped, this is 3/2 for q-spacing
        HEX_SIZE: 32, HEX_SIZE_SQUARED: 32 * 32, GRID_W: 18, GRID_H: 14, SHIP_RADIUS_FACTOR: 0.6,
        MENU_WIDTH: 130, MENU_ITEM_HEIGHT: 26, LOS_RADIUS: 2,
        FOG_ALPHA_PERCENT: 0.75, UNEXPLORED_COLOUR: "#111116",
        LOG_MAX_LINES: 35, HAZARD_ICON_SIZE: 12,
        MOVE_POINTS_PER_TURN: 5, DEFAULT_MOVE_COST: 1, SCOUT_MP_COST: 1,
        BUILD_WOOD_COST: 10, BUILD_CREW_COST: 5, BUILD_MP_COST: 1,
        COLONY_UPKEEP_WHEAT_PER_CREW: 1, AI_INITIAL_CREW: 10,
        PLAYER_INITIAL_CREW: 15, // Added for player ship
        PLAYER_INITIAL_WHEAT: 5, PLAYER_INITIAL_WOOD: 10, PLAYER_INITIAL_GOLD: 5, // Added for player ship
        AI_TARGET_COLONY_RANGE: 4, SHIP_MAX_CARGO: 20,
        FORAGE_MP_COST: 1, TRADE_MP_COST: 1, MARKET_SPAWN_CHANCE: 0.1,
        STORM_DEFAULT_TTL: 3,
        COMBAT_GRID_DIM: 6, COMBAT_CELL_PIXEL_SIZE: 50, COMBAT_MAX_ROUNDS: 5,
        COMBAT_DEFAULT_UNIT_HP: 3, COMBAT_DEFAULT_COLONY_HP: 3,
        COMBAT_ATTACK_HIT_ROLL_THRESHOLD: 4, COMBAT_AI_RETREAT_HP_THRESHOLD: 1,
        COMBAT_AI_RETREAT_CHANCE: 0.5, COMBAT_AI_TURN_DELAY_MS: 750,
        COMBAT_UI_AI_THINKING_DELAY_MS: 500,
        COMBAT_ATTACKER_START_X_OFFSET: 1,
        COMBAT_DEFENDER_START_X_OFFSET_FROM_EDGE: 2,
        COMBAT_UNIT_START_Y_OFFSET_FROM_CENTER: -1,
        FACTION_PLAYER: 'PLAYER', FACTION_AI: 'AI',
        COMBAT_CONTEXT_SHIP_VS_SHIP: 'SHIP_VS_SHIP',
        COMBAT_CONTEXT_SHIP_VS_COLONY: 'SHIP_VS_COLONY',
        COMBAT_OUTCOME_PLAYER_VICTORY: 'VICTORY',
        COMBAT_OUTCOME_PLAYER_DEFEAT: 'DEFEAT',
        COMBAT_OUTCOME_DRAW_MAX_ROUNDS: 'DRAW_MAX_ROUNDS',
        LOG_PREFIX_AI: "AI › ", LOG_PREFIX_SYSTEM: "SYS: ",
        LOG_PREFIX_EVENT_TEMPLATE: (turn) => `T${turn} › EVT: `,
        LOG_PREFIX_PLAYER_TURN_TEMPLATE: (turn) => `T${turn}: `,
        COMBAT_LOG_PREFIX: '[⚔] ', EVENT_LOG_COLOUR: '#4dd0e1',
        COMBAT_LOG_COLOUR: '#ff7043',
        HIGHLIGHT_COLOUR: "#4d73ff66", RANGE_COLOUR: "#4dc0ff44",
        PLANNED_PATH_COLOUR: "#ffd166", PLAYER_COLOUR: "#ffbd59",
        AI_COLOUR: "#9b5de5", COLONY_COLOUR: "#ffffff",
        PLAYER_FLAG_COLOUR: "#e65050", AI_FLAG_COLOUR: "#f4a261",
        MARKET_COLOUR: "#ffd700",
        HAZARD_COLOURS: { Storm: "#607d8b", Reef: "#f44336", Pirates: "#ff9800" },
        RESOURCE_WHEAT: 'Wheat', RESOURCE_WOOD: 'Wood', RESOURCE_GOLD: 'Gold',
      };

      const TerrainType = { OCEAN: 0, COAST: 1, PLAINS: 2, FOREST: 3, HILLS: 4, MOUNTAINS: 5 };
      const TERRAIN_COLOURS = {
        [TerrainType.OCEAN]:     { fill: "#27577a", stroke: "#18344a" },
        [TerrainType.COAST]:     { fill: "#3b7ead", stroke: "#265571" },
        [TerrainType.PLAINS]:    { fill: "#5b9148", stroke: "#3c6030" },
        [TerrainType.FOREST]:    { fill: "#2e6130", stroke: "#1c3b1d" },
        [TerrainType.HILLS]:     { fill: "#8a793a", stroke: "#544a23" },
        [TerrainType.MOUNTAINS]: { fill: "#6b6f7b", stroke: "#454952" },
      };
      const MOVE_COST = {
        [TerrainType.OCEAN]: 1, [TerrainType.COAST]: 1, [TerrainType.PLAINS]: 1,
        [TerrainType.FOREST]: 2, [TerrainType.HILLS]: 2, [TerrainType.MOUNTAINS]: 999
      };
      const priceTable = {
          buy:  { [CONSTS.RESOURCE_WHEAT]: 2, [CONSTS.RESOURCE_WOOD]: 3, [CONSTS.RESOURCE_GOLD]: null },
          sell: { [CONSTS.RESOURCE_WHEAT]: 1, [CONSTS.RESOURCE_WOOD]: 2, [CONSTS.RESOURCE_GOLD]: null }
      };
      const debugMode = false;

      /* ===== STATE ===== */
      let hexes = []; hoverIdx = null; selectedIdx = null; menuOpen = false; menuX = 0; menuY = 0; isEventModalOpen = false;
      let gameState = {
          turnCount: 1, playerOrderQueue: [], aiOrderQueues: new Map(), turnLog: [],
          nextOrderId: 0, nextShipId: 1, nextHazardId: 1, playerShip: null, aiShips: [],
          resources: { [CONSTS.RESOURCE_WHEAT]: 10, [CONSTS.RESOURCE_WOOD]: 20, [CONSTS.RESOURCE_GOLD]: 0 },
          eventDeck: [], discardPile: [], activeHazards: [], combat: null,
          isTurnProcessingPausedForCombat: false, postCombatTurnResumeCallback: null,
          gridOffsetX: 0, gridOffsetY: 0, playerColonyIndices: [], coastHexIndices: [],
      };
      let reachableSet = new Set(); visibleReachableSet = new Set(); currentPathPreview = null;
      let lastPreviewStartIdx = null;
      let lastPreviewHoverIdx = null;
      let lastPreviewPlayerMoves = -1;
      let lastTooltipContent = '';
      let lastTooltipX = -1, lastTooltipY = -1;
      const actions = ["Sail", "Scout", "Build Outpost", "Forage", "Trade", "Attack"];
      let orderPanel, logPanel, tooltipElement, eventModal, eventModalBackdrop, eventModalTitle, eventModalBody, eventModalButtons;
      let combatUiContainer, combatRoundBanner, combatActionButtonsDiv, combatAttackBtn, combatMoveBtn, combatRetreatBtn;

      /* ===== HELPERS ===== */
      const AXIAL_DIRECTIONS = [ {q: 1, r: 0}, {q: 1, r: -1}, {q: 0, r: -1}, {q: -1, r: 0}, {q: -1, r: 1}, {q: 0, r: 1} ];
      function axialToPixel(q, r) { return { x: CONSTS.HEX_SIZE * CONSTS.HEX_WIDTH_FACTOR * q, y: CONSTS.HEX_SIZE * CONSTS.SQRT3 * (r + q / 2) }; }
      function axialToIndex(q, r) { if (q < 0 || q >= CONSTS.GRID_W || r < 0 || r >= CONSTS.GRID_H) return null; return q * CONSTS.GRID_H + r; }
      function indexToAxial(idx) { if (idx === null || idx < 0 || idx >= hexes.length) return null; const q = Math.floor(idx / CONSTS.GRID_H); const r = idx % CONSTS.GRID_H; if (q < 0 || q >= CONSTS.GRID_W || r < 0 || r >= CONSTS.GRID_H) return null; return { q, r }; }
      function axialDistance(a, b) { if(!a || !b) return Infinity; const ac = axialToCube(a); const bc = axialToCube(b); return (Math.abs(ac.x - bc.x) + Math.abs(ac.y - bc.y) + Math.abs(ac.z - bc.z)) / 2; }
      function axialToCube(hex) { return { x: hex.q, z: hex.r, y: -hex.q - hex.r }; }
      function axialNeighbors(q, r) { const neighbors = []; for (const dir of AXIAL_DIRECTIONS) { const nq = q + dir.q; const nr = r + dir.r; if (nq >= 0 && nq < CONSTS.GRID_W && nr >= 0 && nr < CONSTS.GRID_H) { neighbors.push({ q: nq, r: nr }); } } return neighbors; }
      function getTerrainName(terrainType) { return Object.keys(TerrainType).find(key => TerrainType[key] === terrainType) || "UNKNOWN"; }
      function generateColonyName(faction = CONSTS.FACTION_PLAYER) { const prefixes = ["New", "Fort", "Port", "Star", "Cape", "Mount", "South", "North"]; const suffixes = ["Hope", "Freedom", "Prospect", "Horizon", "Haven", "Landing", "Point", "Bay"]; return `${random(prefixes)} ${random(suffixes)}`; }
      function shuffleByWeight(pool) { let weightedPool = []; pool.forEach(item => { for (let i = 0; i < (item.weight || 1); i++) weightedPool.push(item); }); for (let i = weightedPool.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [weightedPool[i], weightedPool[j]] = [weightedPool[j], weightedPool[i]]; } return weightedPool; }
      function aStar(startIdx, goalIdx, moveCostLookup) { const startCoords = indexToAxial(startIdx); const goalCoords = indexToAxial(goalIdx); if (!startCoords || !goalCoords || startIdx === null || goalIdx === null) return null; function heuristic(aIdx, bIdx) { const aCoords = indexToAxial(aIdx); const bCoords = indexToAxial(bIdx); if (!aCoords || !bCoords) return Infinity; return axialDistance(aCoords, bCoords); } const openSet = new Map(); openSet.set(startIdx, heuristic(startIdx, goalIdx)); const cameFrom = new Map(); const gScore = new Map(); hexes.forEach((_, idx) => gScore.set(idx, Infinity)); gScore.set(startIdx, 0); while (openSet.size > 0) { let currentIdx = -1; let lowestFScore = Infinity; for (const [idx, score] of openSet.entries()) { if (score < lowestFScore) { lowestFScore = score; currentIdx = idx; } } if (currentIdx === goalIdx) { const path = []; let tempIdx = goalIdx; while (tempIdx !== startIdx) { path.push(tempIdx); tempIdx = cameFrom.get(tempIdx); if (!tempIdx && tempIdx !== 0) { console.error("A* Path reconstruction failed!"); return null; } } path.reverse(); return { path: path, cost: gScore.get(goalIdx) }; } openSet.delete(currentIdx); const currentCoords = indexToAxial(currentIdx); if (!currentCoords) continue; const neighborsCoords = axialNeighbors(currentCoords.q, currentCoords.r); for (const nCoords of neighborsCoords) { const neighborIdx = axialToIndex(nCoords.q, nCoords.r); if (neighborIdx === null || !hexes[neighborIdx]) continue; const terrain = hexes[neighborIdx].terrain; const costToNeighbor = moveCostLookup[terrain] ?? CONSTS.DEFAULT_MOVE_COST; if (costToNeighbor >= 999) continue; const tentativeGScore = (gScore.get(currentIdx) ?? Infinity) + costToNeighbor; if (tentativeGScore < (gScore.get(neighborIdx) ?? Infinity)) { cameFrom.set(neighborIdx, currentIdx); gScore.set(neighborIdx, tentativeGScore); const fScore = tentativeGScore + heuristic(neighborIdx, goalIdx); openSet.set(neighborIdx, fScore); } } } return null; }
      function computeReachable(startQ, startR, mpLeft) { const startIdx = axialToIndex(startQ, startR); if (startIdx === null || mpLeft <= 0) return new Set(); const frontier = [{ idx: startIdx, cost: 0 }]; const visited = new Map(); visited.set(startIdx, 0); const reachable = new Set(); let head = 0; while(head < frontier.length) { const current = frontier[head++]; const currentCoords = indexToAxial(current.idx); if (!currentCoords) continue; const neighbors = axialNeighbors(currentCoords.q, currentCoords.r); for (const neighborCoords of neighbors) { const neighborIdx = axialToIndex(neighborCoords.q, neighborCoords.r); if (neighborIdx === null || !hexes[neighborIdx]) continue; const moveCost = MOVE_COST[hexes[neighborIdx].terrain] ?? CONSTS.DEFAULT_MOVE_COST; if (moveCost >= 999) continue; const newCost = current.cost + moveCost; if (newCost <= mpLeft) { if (!visited.has(neighborIdx) || newCost < visited.get(neighborIdx)) { visited.set(neighborIdx, newCost); frontier.push({ idx: neighborIdx, cost: newCost }); reachable.add(neighborIdx); } } } } return reachable; }
      function* spiral(q0, r0, radius) { for (let dq = -radius; dq <= radius; dq++) { for (let dr = Math.max(-radius, -dq - radius); dr <= Math.min(radius, -dq + radius); dr++) { const q = q0 + dq; const r = r0 + dr; const idx = axialToIndex(q, r); if (idx !== null && hexes[idx]) { yield idx; } } } }
      function updateVisibility() {
        hexes.forEach(h => { if (h) h.isVisible = false; });

        if (gameState.playerShip) {
          const shipQ = gameState.playerShip.q;
          const shipR = gameState.playerShip.r;
          for (const idx of spiral(shipQ, shipR, CONSTS.LOS_RADIUS)) {
            if (hexes[idx]) {
              hexes[idx].isVisible = true;
              hexes[idx].isExplored = true;
            }
          }
        }

        if (gameState.playerColonyIndices) {
          gameState.playerColonyIndices.forEach(colonyIdx => {
            const colonyHex = hexes[colonyIdx];
            if (colonyHex && colonyHex.colony) { // Ensure colony still exists
              for (const idx of spiral(colonyHex.q, colonyHex.r, 1)) { // Assuming colony LOS is 1
                if (hexes[idx]) {
                  hexes[idx].isVisible = true;
                  hexes[idx].isExplored = true;
                }
              }
            }
          });
        }

        visibleReachableSet.clear();
        if (gameState.playerShip) { // Only compute if player ship exists
            reachableSet.forEach(idx => {
                if (hexes[idx]?.isVisible) {
                    visibleReachableSet.add(idx);
                }
            });
        }
      }
      function drawHex(cx, cy) { beginShape(); for (let i = 0; i < 6; i++) { const a = PI / 3 * i; vertex(cx + CONSTS.HEX_SIZE * cos(a), cy + CONSTS.HEX_SIZE * sin(a)); } endShape(CLOSE); }
      function pointInHex(px, py, h) {
        if (!h) return false;
        const dx = px - h.x;
        const dy = py - h.y;
        return (dx * dx + dy * dy) <= CONSTS.HEX_SIZE_SQUARED;
      }

      function pixelToAxial(pixelX, pixelY, gridOffsetX, gridOffsetY) {
        const worldX = pixelX - gridOffsetX;
        const worldY = pixelY - gridOffsetY;

        const q_frac = (2 / 3 * worldX) / CONSTS.HEX_SIZE;
        const r_frac = (-1 / 3 * worldX + CONSTS.SQRT3 / 3 * worldY) / CONSTS.HEX_SIZE;

        // Convert fractional axial to fractional cube
        const x_frac = q_frac;
        const z_frac = r_frac;
        const y_frac = -x_frac - z_frac;

        // Round cube coordinates
        let rx = Math.round(x_frac);
        let ry = Math.round(y_frac);
        let rz = Math.round(z_frac);

        // Correct rounding errors
        const x_diff = Math.abs(rx - x_frac);
        const y_diff = Math.abs(ry - y_frac);
        const z_diff = Math.abs(rz - z_frac);

        if (x_diff > y_diff && x_diff > z_diff) {
          rx = -ry - rz;
        } else if (y_diff > z_diff) {
          ry = -rx - rz;
        } else {
          rz = -rx - ry;
        }
        return { q: rx, r: rz }; // Return rounded axial (cube.x is q, cube.z is r)
      }

      function getHexUnderMouse() {
        if (gameState.combat) return null;

        const candidateAxial = pixelToAxial(mouseX, mouseY, gameState.gridOffsetX, gameState.gridOffsetY);

        const candidates = [{q: candidateAxial.q, r: candidateAxial.r}];
        for (const dir of AXIAL_DIRECTIONS) {
            candidates.push({ q: candidateAxial.q + dir.q, r: candidateAxial.r + dir.r });
        }

        for (const coords of candidates) {
            const idx = axialToIndex(coords.q, coords.r);
            if (idx !== null && hexes[idx] && hexes[idx].isVisible) {
                if (pointInHex(mouseX, mouseY, hexes[idx])) {
                    return idx;
                }
            }
        }
        return null;
      }
      function clampMenuToScreen() { if (menuX + CONSTS.MENU_WIDTH > width) menuX = width - CONSTS.MENU_WIDTH; if (menuY + actions.length * CONSTS.MENU_ITEM_HEIGHT > height) menuY = height - actions.length * CONSTS.MENU_ITEM_HEIGHT; if (menuX < 0) menuX = 0; if (menuY < 0) menuY = 0; }

      const EVENT_POOL = [ { id: 'storm', name: 'Sudden Storm', type: 'Instant', weight: 3, desc: "Dark clouds gather rapidly, spawning a treacherous storm nearby.", effectFn: (ship) => { const hazard = spawnStormNear(ship); if (hazard) { gameState.activeHazards.push(hazard); addToLog(`[EVENT] ${ship.faction} Ship ${ship.id}: A storm brews at (${hexes[hazard.idx].q}, ${hexes[hazard.idx].r})!`, "Event"); } else { addToLog(`[EVENT] ${ship.faction} Ship ${ship.id}: Storm clouds gathered but found no open sea nearby.`, "Event"); } } }, { id: 'merchant', name: 'Travelling Merchant', type: 'Choice', weight: 2, desc: "A merchant vessel hails you, offering 3 Wheat for 6 Gold.", options: ['Buy (6G)', 'Ignore'], effectFn: (ship, choice) => { if (choice === 'Buy (6G)') { const cost = 6; const amount = 3; const currentCargo = ship.cargo[CONSTS.RESOURCE_WHEAT]; const spaceAvailable = CONSTS.SHIP_MAX_CARGO - currentCargo; if (ship.cargo[CONSTS.RESOURCE_GOLD] >= cost && spaceAvailable > 0) { const canTake = Math.min(amount, spaceAvailable); ship.cargo[CONSTS.RESOURCE_GOLD] -= cost; ship.cargo[CONSTS.RESOURCE_WHEAT] += canTake; addToLog(`[EVENT] ${ship.faction} Ship ${ship.id}: Bought ${canTake} ${CONSTS.RESOURCE_WHEAT} for ${cost}G. (Space: ${spaceAvailable})`, "Event"); } else if (ship.cargo[CONSTS.RESOURCE_GOLD] < cost) { addToLog(`[EVENT] ${ship.faction} Ship ${ship.id}: Cannot afford the merchant's offer (Need 6G).`, "Event"); } else { addToLog(`[EVENT] ${ship.faction} Ship ${ship.id}: No space for the merchant's wheat.`, "Event"); } } else { addToLog(`[EVENT] ${ship.faction} Ship ${ship.id}: Passed on the merchant's deal.`, "Event"); } } }, { id: 'favorable_winds', name: 'Favorable Winds', type: 'Instant', weight: 4, desc: "Strong tailwinds promise swift travel next turn.", effectFn: (ship) => { if (!ship.status) ship.status = {}; ship.status.windBoost = (ship.status.windBoost || 0) + 1; addToLog(`[EVENT] ${ship.faction} Ship ${ship.id}: Caught favorable winds! (+1 MP next turn).`, "Event"); } }, { id: 'lost_scouts', name: 'Lost Scouts', type: 'Instant', weight: 2, desc: "A scouting party failed to return, but salvaged some timber.", effectFn: (ship) => { const crewLoss = Math.min(2, ship.crew); const woodGain = 1; const spaceAvailable = CONSTS.SHIP_MAX_CARGO - ship.cargo[CONSTS.RESOURCE_WOOD]; const actualWoodGain = Math.min(woodGain, spaceAvailable); ship.crew -= crewLoss; ship.cargo[CONSTS.RESOURCE_WOOD] += actualWoodGain; addToLog(`[EVENT] ${ship.faction} Ship ${ship.id}: Lost ${crewLoss} crew, gained ${actualWoodGain} ${CONSTS.RESOURCE_WOOD}.`, "Event"); if (ship.crew <= 0) { addToLog(`   Ship ${ship.id} has no crew left!`, "System"); } } }, { id: 'plague_rats', name: 'Plague Rats', type: 'Instant', weight: 1, desc: "Rats infest the ship! Sickness spreads among the crew.", effectFn: (ship) => { if (!ship.status) ship.status = {}; ship.status.crewSick = 3; addToLog(`[EVENT] ${ship.faction} Ship ${ship.id}: Crew struck by sickness! (-1 MP while sick).`, "Event"); } }, ];

      /* ===== SETUP ===== */
      function setup() {
        createCanvas(windowWidth, windowHeight); angleMode(RADIANS); textAlign(LEFT, CENTER); textSize(14); strokeWeight(1);
        orderPanel = select('#orderPanel').elt; logPanel = select('#logPanel').elt; tooltipElement = createDiv(''); tooltipElement.addClass('tooltip'); tooltipElement.hide();
        eventModal = select('#eventModal').elt; eventModalBackdrop = select('#eventModalBackdrop').elt; eventModalTitle = select('#eventModalTitle').elt; eventModalBody = select('#eventModalBody').elt; eventModalButtons = select('#eventModalButtons').elt;
        combatUiContainer = select('#combatUiContainer'); combatRoundBanner = select('#combatRoundBanner'); combatActionButtonsDiv = select('#combatActionButtons');
        combatAttackBtn = select('#combatAttackBtn').mousePressed(() => handleCombatPlayerAction('ATTACK')); combatMoveBtn = select('#combatMoveBtn').mousePressed(() => handleCombatPlayerAction('MOVE')); combatRetreatBtn = select('#combatRetreatBtn').mousePressed(() => handleCombatPlayerAction('RETREAT'));
        gameState.gridOffsetX = width / 2 - (CONSTS.GRID_W / 2 * CONSTS.HEX_SIZE * CONSTS.HEX_WIDTH_FACTOR);
        gameState.gridOffsetY = height / 2 - (CONSTS.GRID_H / 2 * CONSTS.HEX_SIZE * CONSTS.SQRT3);
        for (let q = 0; q < CONSTS.GRID_W; q++) { for (let r = 0; r < CONSTS.GRID_H; r++) { const pos = axialToPixel(q, r); hexes.push({ q, r, x: pos.x + gameState.gridOffsetX, y: pos.y + gameState.gridOffsetY, terrain: TerrainType.PLAINS, isExplored: false, isVisible: false, colony: null, market: null, forageable: false }); } }
        
        generateTerrain();
        spawnAIShip(); // Spawn AI ship first
        autoSpawnPlayerShip(); // Then automatically spawn player ship

        addToLog("Welcome! Your journey begins.", "System");
        gameState.discardPile = []; gameState.eventDeck = shuffleByWeight(EVENT_POOL); addToLog(`Event deck initialized with ${gameState.eventDeck.length} cards.`, "System");
        select('#endTurnBtn').mousePressed(endTurn); document.oncontextmenu = () => false; updateOrderPanel();
      }

      /**
       * Finds a suitable, unoccupied land hex index for the player to spawn on.
       * Prefers non-mountain, non-ocean hexes.
       * @returns {number|null} The index of a valid spawn hex, or null if none found.
       */
      function findValidPlayerSpawnLocation() {
        const potentialSpawns = [];
        for (let i = 0; i < hexes.length; i++) {
            const h = hexes[i];
            if (h &&
                h.terrain !== TerrainType.OCEAN &&
                h.terrain !== TerrainType.MOUNTAINS
            ) {
                // Check if AI ship is already at this location
                const isOccupiedByAI = gameState.aiShips.some(s => s.q === h.q && s.r === h.r);
                if (!isOccupiedByAI) {
                    potentialSpawns.push(i);
                }
            }
        }

        if (potentialSpawns.length > 0) {
            return random(potentialSpawns); // Pick a random valid one
        }

        // Fallback: if no "ideal" (non-AI occupied land) spot, try any land spot.
        // This scenario is less likely if AI spawns on ocean as intended.
        for (let i = 0; i < hexes.length; i++) {
            const h = hexes[i];
            if (h && h.terrain !== TerrainType.OCEAN && h.terrain !== TerrainType.MOUNTAINS) {
                return i;
            }
        }
        return null; // Should ideally not happen on a typical map
      }

      /**
       * Automatically spawns the player ship at a valid location.
       * Updates game state, visibility, and reachable set.
       */
      function autoSpawnPlayerShip() {
        if (gameState.playerShip) return; // Player ship already exists

        const spawnIdx = findValidPlayerSpawnLocation();

        if (spawnIdx === null) {
            addToLog("CRITICAL ERROR: Could not find a valid spawn location for the player ship!", "System");
            return;
        }

        const spawnHex = hexes[spawnIdx];
        const shipId = gameState.nextShipId++;
        gameState.playerShip = {
            id: shipId,
            faction: CONSTS.FACTION_PLAYER,
            q: spawnHex.q,
            r: spawnHex.r,
            movesLeft: CONSTS.MOVE_POINTS_PER_TURN,
            crew: CONSTS.PLAYER_INITIAL_CREW,
            cargo: {
                [CONSTS.RESOURCE_WHEAT]: CONSTS.PLAYER_INITIAL_WHEAT,
                [CONSTS.RESOURCE_WOOD]: CONSTS.PLAYER_INITIAL_WOOD,
                [CONSTS.RESOURCE_GOLD]: CONSTS.PLAYER_INITIAL_GOLD
            },
            status: {}
        };

        addToLog(`Your ship [${shipId}] embarked at (${gameState.playerShip.q}, ${gameState.playerShip.r}) on ${getTerrainName(spawnHex.terrain)}.`);
        updateVisibility(); // Initial visibility based on spawn
        reachableSet = computeReachable(gameState.playerShip.q, gameState.playerShip.r, gameState.playerShip.movesLeft);
        updateVisibility(); // Update visibleReachableSet based on new reachable area
        menuOpen = false;
        // Enable End Turn button if player has a ship and no orders are required to start
        select('#endTurnBtn').elt.disabled = gameState.combat || gameState.playerOrderQueue.length === 0 || isEventModalOpen;
      }


      function spawnAIShip() { let spawnQ = -1, spawnR = -1, spawnIdx = null; let attempts = 0; while (attempts < CONSTS.GRID_W * 2 && spawnIdx === null) { const q = Math.floor(random(CONSTS.GRID_W)); const r = 0; const idx = axialToIndex(q, r); if (idx !== null && hexes[idx] && hexes[idx].terrain === TerrainType.OCEAN) { let occupied = (gameState.playerShip && gameState.playerShip.q === q && gameState.playerShip.r === r) || gameState.aiShips.some(s => s.q === q && s.r === r); if (!occupied) { spawnQ = q; spawnR = r; spawnIdx = idx; break; } } attempts++; } if(spawnIdx === null) { attempts = 0; while (attempts < hexes.length && spawnIdx === null) { const idx = Math.floor(random(hexes.length)); const h = hexes[idx]; if (h && h.terrain === TerrainType.OCEAN) { let occupied = (gameState.playerShip && gameState.playerShip.q === h.q && gameState.playerShip.r === h.r) || gameState.aiShips.some(s => s.q === h.q && s.r === h.r); if (!occupied) { spawnQ = h.q; spawnR = h.r; spawnIdx = idx; break; } } attempts++; } } if(spawnIdx === null) { console.error("Failed to find valid spawn location for AI ship!"); addToLog("Error: Could not spawn AI ship.", "System"); return; } const shipId = gameState.nextShipId++; const newAIShip = { id: shipId, faction: CONSTS.FACTION_AI, q: spawnQ, r: spawnR, movesLeft: CONSTS.MOVE_POINTS_PER_TURN, crew: CONSTS.AI_INITIAL_CREW, cargo: { [CONSTS.RESOURCE_WHEAT]: 5, [CONSTS.RESOURCE_WOOD]: 5, [CONSTS.RESOURCE_GOLD]: 10 }, status: {} }; gameState.aiShips.push(newAIShip); gameState.aiOrderQueues.set(shipId, []); addToLog(`AI Rival ship [${shipId}] launched from (${spawnQ}, ${spawnR})`, CONSTS.FACTION_AI); }
      function generateTerrain() { hexes.forEach(h => { if (h.q === 0 || h.q === CONSTS.GRID_W - 1 || h.r === 0 || h.r === CONSTS.GRID_H - 1) { h.terrain = TerrainType.OCEAN; }}); let centerQ = Math.floor(CONSTS.GRID_W / 2); let centerR = Math.floor(CONSTS.GRID_H / 2); for (let i = 0; i < 5; i++) { let q = Math.floor(random(centerQ-3, centerQ+3)); let r = Math.floor(random(centerR-3, centerR+3)); let rad = Math.floor(random(1,3)); for (const idx of spiral(q, r, rad)) { if(hexes[idx] && hexes[idx].terrain !== TerrainType.OCEAN) { hexes[idx].terrain = (random() < 0.6) ? TerrainType.OCEAN : TerrainType.COAST; }}} const coastCandidates = []; hexes.forEach((h, idx) => { if (!h || h.terrain === TerrainType.OCEAN) return; const neighbors = axialNeighbors(h.q, h.r); for (const nCoords of neighbors) { const nIdx = axialToIndex(nCoords.q, nCoords.r); if (nIdx !== null && hexes[nIdx]?.terrain === TerrainType.OCEAN) { coastCandidates.push(idx); break; } } }); coastCandidates.forEach(idx => { if (hexes[idx]) hexes[idx].terrain = TerrainType.COAST; }); hexes.forEach(h => { if (!h) return; if (h.terrain !== TerrainType.OCEAN && h.terrain !== TerrainType.COAST) { const rnd = random(); if (rnd < 0.45) h.terrain = TerrainType.PLAINS; else if (rnd < 0.70) h.terrain = TerrainType.FOREST; else if (rnd < 0.90) h.terrain = TerrainType.HILLS; else h.terrain = TerrainType.MOUNTAINS; } if (h.terrain === TerrainType.COAST || h.terrain === TerrainType.FOREST || h.terrain === TerrainType.HILLS) { h.forageable = true; } if (h.terrain === TerrainType.COAST) { if (random() < CONSTS.MARKET_SPAWN_CHANCE) { h.market = { buy: { ...priceTable.buy }, sell: { ...priceTable.sell } }; } } }); for (let i = 0; i < 2; i++) { hexes.forEach(h => { if(!h || h.terrain < TerrainType.HILLS) return; let plainsNeighbors = 0; const neighbors = axialNeighbors(h.q, h.r); for (const nCoords of neighbors) { const nIdx = axialToIndex(nCoords.q, nCoords.r); if (nIdx !== null && hexes[nIdx] && hexes[nIdx].terrain <= TerrainType.PLAINS) { plainsNeighbors++; } } if(plainsNeighbors >= 4 && h.terrain === TerrainType.MOUNTAINS) h.terrain = TerrainType.HILLS; else if (plainsNeighbors >= 5 && h.terrain === TerrainType.HILLS) h.terrain = TerrainType.PLAINS; }); } let marketCount = hexes.reduce((count, h) => count + (h && h.market ? 1 : 0), 0); console.log(`Terrain generated. Created ${marketCount} markets.`);
        gameState.coastHexIndices = []; // Clear it in case generateTerrain could be called multiple times
        hexes.forEach((h, idx) => {
            if (h && h.terrain === TerrainType.COAST) {
                gameState.coastHexIndices.push(idx);
            }
        });
        console.log(`Cached ${gameState.coastHexIndices.length} coast hex indices.`);
      }

      /* ===== DRAW LOOP ===== */
      function draw() {
        if (gameState.combat) {
          drawCombat();
        } else {
          background(CONSTS.UNEXPLORED_COLOUR);
          drawHexGrid();
          drawHazards();
          drawShips();

          if (hoverIdx !== null && reachableSet.has(hoverIdx) && gameState.playerShip && !isEventModalOpen) {
            const startIdx = axialToIndex(gameState.playerShip.q, gameState.playerShip.r);

            // Check if recalculation is needed for the A* path preview
            if (startIdx !== lastPreviewStartIdx || hoverIdx !== lastPreviewHoverIdx || gameState.playerShip.movesLeft !== lastPreviewPlayerMoves) {
                currentPathPreview = aStar(startIdx, hoverIdx, MOVE_COST);
                lastPreviewStartIdx = startIdx;
                lastPreviewHoverIdx = hoverIdx;
                lastPreviewPlayerMoves = gameState.playerShip.movesLeft;
            }

            if (currentPathPreview) {
                drawPlannedPathPreview(currentPathPreview.path);
            }
          } else {
            currentPathPreview = null;
            // Reset caching variables when not showing a preview so it recalculates when next needed
            lastPreviewStartIdx = null;
            lastPreviewHoverIdx = null;
            lastPreviewPlayerMoves = -1;
          }
          drawUI();
          if (menuOpen && !isEventModalOpen) drawMenu();
        }
        select('#endTurnBtn').elt.disabled = gameState.combat || !gameState.playerShip || gameState.playerOrderQueue.length === 0 || isEventModalOpen;
        if (!isEventModalOpen && !gameState.combat) updateTooltip();
        else tooltipElement.hide();
      }

      /* ===== RENDERING (Strategy Map) ===== */
      function drawHexGrid() {
        if (!isEventModalOpen) hoverIdx = getHexUnderMouse();
        else hoverIdx = null;

        hexes.forEach((h, idx) => {
          if (!h) return;

          // Viewport Culling
          const buffer = CONSTS.HEX_SIZE * 2; // A bit more buffer
          if (h.x < -buffer || h.x > windowWidth + buffer || h.y < -buffer || h.y > windowHeight + buffer) {
            return; // Skip drawing if hex is off-screen
          }

          if (!h.isExplored) {
            fill(CONSTS.UNEXPLORED_COLOUR);
            noStroke();
            drawHex(h.x, h.y);
            return;
          }

          // Hex is Explored
          const terrainStyle = TERRAIN_COLOURS[h.terrain];
          if (!terrainStyle) { fill("#ff00ff"); stroke("#000"); } // Error color
          else { fill(terrainStyle.fill); stroke(terrainStyle.stroke); }
          strokeWeight(1);
          drawHex(h.x, h.y); // Draw base terrain

          // Draw colony and market icons on top of terrain
          if (h.colony) {
            push();
            translate(h.x, h.y);
            fill(CONSTS.COLONY_COLOUR);
            noStroke();
            rect(-6, -6, 12, 12); // Base of the colony icon
            const flagPoleColor = h.colony.faction === CONSTS.FACTION_AI ? CONSTS.AI_COLOUR : CONSTS.PLAYER_COLOUR;
            const flagColor = h.colony.faction === CONSTS.FACTION_AI ? CONSTS.AI_FLAG_COLOUR : CONSTS.PLAYER_FLAG_COLOUR;
            stroke(flagPoleColor);
            strokeWeight(1.5);
            line(0, -6, 0, -14); // Flagpole
            fill(flagColor);
            noStroke();
            triangle(0, -14, 8, -11, 0, -8); // Flag
            pop();
          }
          if (h.market) {
            push();
            fill(CONSTS.MARKET_COLOUR);
            noStroke();
            ellipse(h.x + CONSTS.HEX_SIZE * 0.3, h.y + CONSTS.HEX_SIZE * 0.4, 10, 10);
            pop();
          }

          if (!h.isVisible) {
            fill(0, 0, 0, CONSTS.FOG_ALPHA_PERCENT * 255);
            noStroke();
            drawHex(h.x, h.y); // Draw fog overlay
          } else {
            // Hex is Visible
            if (!isEventModalOpen) {
              if (visibleReachableSet.has(idx)) {
                fill(CONSTS.RANGE_COLOUR);
                noStroke();
                drawHex(h.x, h.y); // Draw range highlight
              }
              if (idx === hoverIdx) {
                fill(CONSTS.HIGHLIGHT_COLOUR);
                noStroke();
                drawHex(h.x, h.y); // Draw hover highlight (on top of range)
              }
            }
          }
        });
      }

      function drawHazards() { gameState.activeHazards.forEach(hazard => { const h = hexes[hazard.idx]; if (h && h.isVisible) { push(); translate(h.x, h.y); const hazardColor = CONSTS.HAZARD_COLOURS[hazard.kind] || '#ffffff'; fill(hazardColor); noStroke(); const size = CONSTS.HAZARD_ICON_SIZE; if (hazard.kind === 'Storm') { ellipse(0, 0, size * 1.2, size * 0.8); ellipse(-size * 0.3, -size * 0.2, size * 0.8, size * 0.6); ellipse(size * 0.3, size * 0.2, size * 0.8, size * 0.6); } else if (hazard.kind === 'Reef') { stroke(hazardColor); strokeWeight(2); line(-size / 2, -size / 2, size / 2, size / 2); line(-size / 2, size / 2, size / 2, -size / 2); } else if (hazard.kind === 'Pirates') { fill(hazardColor); ellipse(0, -size*0.2, size*0.8, size*0.8); rect(-size*0.4, size*0.2, size*0.8, size*0.3); fill('#111'); ellipse(-size*0.2, -size*0.2, size*0.2, size*0.2); ellipse(size*0.2, -size*0.2, size*0.2, size*0.2); } pop(); } }); }
      function drawShips() { if (gameState.playerShip) { const shipIdx = axialToIndex(gameState.playerShip.q, gameState.playerShip.r); if (shipIdx !== null && hexes[shipIdx]?.isVisible) { drawOneShip(hexes[shipIdx], gameState.playerShip); } } gameState.aiShips.forEach(aiShip => { const shipIdx = axialToIndex(aiShip.q, aiShip.r); if (shipIdx !== null && hexes[shipIdx]?.isVisible) { drawOneShip(hexes[shipIdx], aiShip); } }); }
      function drawOneShip(shipHex, shipData) { if (!shipHex || !shipData) return; const shipColor = shipData.faction === CONSTS.FACTION_AI ? CONSTS.AI_COLOUR : CONSTS.PLAYER_COLOUR; const shipRadius = CONSTS.HEX_SIZE * CONSTS.SHIP_RADIUS_FACTOR; push(); translate(shipHex.x, shipHex.y); fill(shipColor); stroke("#222"); strokeWeight(1.5); triangle(0, -shipRadius*0.8, shipRadius*0.6, shipRadius*0.4, -shipRadius*0.6, shipRadius*0.4); if (shipData.status && shipData.status.crewSick > 0) { fill(CONSTS.HAZARD_COLOURS.Reef); noStroke(); ellipse(shipRadius * 0.5, -shipRadius * 0.6, 6, 6); } pop(); }
      function drawPlannedPathPreview(pathIndices) { if (!pathIndices || pathIndices.length === 0 || !gameState.playerShip || !hexes[axialToIndex(gameState.playerShip.q, gameState.playerShip.r)]?.isVisible) return; const startIdx = axialToIndex(gameState.playerShip.q, gameState.playerShip.r); const start = hexes[startIdx]; const destIdx = pathIndices[pathIndices.length - 1]; if (!hexes[destIdx] || !hexes[destIdx].isVisible) return; const dest = hexes[destIdx]; push(); stroke(CONSTS.PLANNED_PATH_COLOUR); strokeWeight(2.5); noFill(); let lastX = start.x; let lastY = start.y; for (const idx of pathIndices) { if(!hexes[idx] || !hexes[idx].isVisible) break; const h = hexes[idx]; line(lastX, lastY, h.x, h.y); lastX = h.x; lastY = h.y; } if (lastX !== start.x || lastY !== start.y) { const finalTargetHex = hexes[pathIndices[pathIndices.length - 1]]; if(finalTargetHex && finalTargetHex.isVisible){ fill(CONSTS.PLANNED_PATH_COLOUR); noStroke(); translate(finalTargetHex.x, finalTargetHex.y); let angle = atan2(finalTargetHex.y - (pathIndices.length > 1 ? hexes[pathIndices[pathIndices.length-2]].y : start.y), finalTargetHex.x - (pathIndices.length > 1 ? hexes[pathIndices[pathIndices.length-2]].x : start.x)); rotate(angle); const arrowSize = 8; triangle(0, 0, -arrowSize, -arrowSize / 2, -arrowSize, arrowSize / 2); pop(); fill(CONSTS.PLANNED_PATH_COLOUR); noStroke(); textSize(12); textAlign(CENTER, BOTTOM); text(`Cost: ${currentPathPreview.cost}`, dest.x, dest.y - CONSTS.HEX_SIZE * 0.8); } else { pop(); } } else { pop(); } }
      function drawUI() { fill("#ffffff"); noStroke(); textSize(16); textAlign(LEFT, CENTER); const turnText = `Turn: ${gameState.turnCount}`; const mpText = gameState.playerShip ? `MP: ${gameState.playerShip.movesLeft}/${CONSTS.MOVE_POINTS_PER_TURN}` : 'MP: -/-'; const shipCargoText = gameState.playerShip ? `Ship: W:${gameState.playerShip.cargo[CONSTS.RESOURCE_WHEAT]} Wd:${gameState.playerShip.cargo[CONSTS.RESOURCE_WOOD]} G:${gameState.playerShip.cargo[CONSTS.RESOURCE_GOLD]}` : 'Ship: ---'; const crewText = gameState.playerShip ? `Crew: ${gameState.playerShip.crew}` : 'Crew: -'; let statusText = ""; if (gameState.playerShip && gameState.playerShip.status) { if (gameState.playerShip.status.crewSick > 0) statusText += " [Sick]"; if (gameState.playerShip.status.windBoost > 0) statusText += " [Wind]"; if (gameState.playerShip.status.stormPenaltyNextTurn) statusText += " [Storm]"; } let topText = `${turnText} | ${mpText} | ${crewText}${statusText}\n${shipCargoText}`; if (textWidth(`${turnText} | ${mpText} | ${crewText}${statusText}`) < width - 300) { topText = `${turnText} | ${mpText} | ${crewText}${statusText} | ${shipCargoText}`; } text(topText, 16, 28); textAlign(RIGHT, CENTER); const resourceText = `Global: W:${gameState.resources[CONSTS.RESOURCE_WHEAT]} Wd:${gameState.resources[CONSTS.RESOURCE_WOOD]} G:${gameState.resources[CONSTS.RESOURCE_GOLD]}`; text(resourceText, width - 150, 28); textAlign(LEFT, CENTER); }
      function drawMenu() { if (isEventModalOpen) return; push(); translate(menuX, menuY); fill("#262932"); stroke("#888"); strokeWeight(1); rect(0, 0, CONSTS.MENU_WIDTH, actions.length * CONSTS.MENU_ITEM_HEIGHT, 4); noStroke(); fill("#eeeeee"); textSize(14); actions.forEach((act, i) => { const itemY = i * CONSTS.MENU_ITEM_HEIGHT; const isHovered = mouseX > menuX && mouseX < menuX + CONSTS.MENU_WIDTH && mouseY > menuY + itemY && mouseY < menuY + itemY + CONSTS.MENU_ITEM_HEIGHT; const isDisabled = isActionDisabled(act, hexes[selectedIdx]); if (isHovered && !isDisabled) { fill("#4d73ff"); rect(2, itemY + 2, CONSTS.MENU_WIDTH - 4, CONSTS.MENU_ITEM_HEIGHT - 4, 3); fill("#ffffff"); } else if (isDisabled) { fill("#777777"); } else { fill("#eeeeee"); } text(act, 10, itemY + CONSTS.MENU_ITEM_HEIGHT / 2); }); pop(); }

      /* ===== UI & ORDER HANDLING (Strategy Map) ===== */
      function updateOrderPanel() {
        const fragment = document.createDocumentFragment();

        if (gameState.playerOrderQueue.length === 0) {
            const emptyMsg = document.createElement('span');
            emptyMsg.style.fontSize = '12px';
            emptyMsg.style.color = '#888';
            emptyMsg.textContent = 'No orders queued.';
            fragment.appendChild(emptyMsg);
        } else {
            gameState.playerOrderQueue.forEach((order, index) => {
                const item = document.createElement('div');
                item.classList.add('orderItem');
                item.dataset.orderId = order.id;
                item.dataset.index = index;
                const targetHex = hexes[order.targetIdx];
                const coordsLabel = targetHex ? `(${targetHex.q}-${targetHex.r})` : '(?)';
                const terrainLabel = targetHex ? getTerrainName(targetHex.terrain) : '';
                const fullLabel = `${order.type} ${coordsLabel} ${terrainLabel}`;
                let iconColor = "#888";
                switch (order.type) {
                    case 'Sail': iconColor = "#4dc0ff"; break;
                    case 'Scout': iconColor = CONSTS.PLAYER_COLOUR; break;
                    case 'Build Outpost': iconColor = "#5b9148"; break;
                    case 'Forage': iconColor = "#206a23"; break;
                    case 'Trade': iconColor = CONSTS.MARKET_COLOUR; break;
                    case 'Attack': iconColor = CONSTS.HAZARD_COLOURS.Pirates; break;
                }
                item.innerHTML = `<span class="orderLabel" title="${fullLabel}"><span class="orderIcon" style="background-color: ${iconColor};"></span><span class="orderText">${order.type} ${coordsLabel}</span></span><span class="orderControls">${index > 0 ? '<button class="reorderBtn upBtn" title="Move Up">▲</button>' : '<button disabled style="opacity:0;">▲</button>'}${index < gameState.playerOrderQueue.length - 1 ? '<button class="reorderBtn downBtn" title="Move Down">▼</button>' : '<button disabled style="opacity:0;">▼</button>'}<button class="deleteBtn" title="Cancel Order">❌</button></span>`;
                item.querySelector('.deleteBtn').addEventListener('click', (e) => { e.stopPropagation(); removePlayerOrder(order.id); });
                const upBtn = item.querySelector('.upBtn:not([disabled])');
                if (upBtn) { upBtn.addEventListener('click', (e) => { e.stopPropagation(); reorderPlayerOrder(index, index - 1); }); }
                const downBtn = item.querySelector('.downBtn:not([disabled])');
                if (downBtn) { downBtn.addEventListener('click', (e) => { e.stopPropagation(); reorderPlayerOrder(index, index + 1); }); }
                fragment.appendChild(item);
            });
        }
        orderPanel.innerHTML = ''; // Clear just before appending the fragment
        orderPanel.appendChild(fragment); // Append fragment once
      }
      function getHexTooltipContent(h) { let tipContent = `(${h.q}, ${h.r}) ${getTerrainName(h.terrain)}`; tipContent += `\nMove Cost: ${MOVE_COST[h.terrain] ?? CONSTS.DEFAULT_MOVE_COST}`; if (h.forageable) tipContent += `\n[Forageable]`; if (h.market) tipContent += `\n[Market]`; const currentHexIndex = axialToIndex(h.q, h.r); const hazardOnHex = gameState.activeHazards.find(haz => haz.idx === currentHexIndex); if (hazardOnHex) { tipContent += `\n[Hazard: ${hazardOnHex.kind}] (TTL: ${hazardOnHex.ttl})`; } let shipOnHex = null; if (gameState.playerShip && gameState.playerShip.q === h.q && gameState.playerShip.r === h.r) { shipOnHex = gameState.playerShip; } if (!shipOnHex) { shipOnHex = gameState.aiShips.find(s => s.q === h.q && s.r === h.r && h.isVisible); } if (shipOnHex) { tipContent += `\n${shipOnHex.faction === CONSTS.FACTION_AI ? 'AI Rival' : 'Player Ship'} (Crew: ${shipOnHex.crew})`; tipContent += `\n Cargo: W:${shipOnHex.cargo[CONSTS.RESOURCE_WHEAT]} Wd:${shipOnHex.cargo[CONSTS.RESOURCE_WOOD]} G:${shipOnHex.cargo[CONSTS.RESOURCE_GOLD]}`; } if (h.colony) { const factionName = h.colony.faction === CONSTS.FACTION_AI ? CONSTS.FACTION_AI : CONSTS.FACTION_PLAYER; tipContent += `\n${factionName} Outpost: ${h.colony.name}`; if (h.colony.faction === CONSTS.FACTION_PLAYER){ tipContent += `\n Stock: W:${h.colony.stock[CONSTS.RESOURCE_WHEAT]} Wd:${h.colony.stock[CONSTS.RESOURCE_WOOD]}`; } tipContent += ` Crew: ${h.colony.crew}`; } if (currentPathPreview && hoverIdx === currentHexIndex) { tipContent += `\nPath Cost: ${currentPathPreview.cost}`; } return tipContent; }
      function getOrderTooltipContent(order) { const h = hexes[order.targetIdx]; let tipContent = `${order.type}`; if (h) { tipContent += ` at (${h.q}, ${h.r}) ${getTerrainName(h.terrain)}`; if (order.type === 'Sail' && order.cost !== undefined) { tipContent += ` [Est. Cost: ${order.cost}]`; } if (order.type === 'Forage') { const resourceType = (h.terrain === TerrainType.FOREST) ? CONSTS.RESOURCE_WOOD : CONSTS.RESOURCE_WHEAT; tipContent += ` [Resource: ${resourceType}]`; } if (order.type === 'Trade' && order.action) { tipContent += ` [AI: ${order.action} ${order.resource}]`; } } else { tipContent += ' at Invalid Target'; } return tipContent; }
      function updateTooltip() {
        if (isEventModalOpen || gameState.combat) {
            tooltipElement.hide();
            lastTooltipContent = ''; // Reset when hidden
            lastTooltipX = -1;
            lastTooltipY = -1;
            return;
        }
        let showTip = false;
        let newTooltipTarget = null;
        const orderItems = orderPanel.querySelectorAll('.orderItem');
        orderItems.forEach(item => {
            const rect = item.getBoundingClientRect();
            if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) {
                const orderId = parseInt(item.dataset.orderId);
                const order = gameState.playerOrderQueue.find(o => o.id === orderId);
                if (order) {
                    newTooltipTarget = { type: 'order', data: order };
                    showTip = true;
                }
            }
        });
        if (!showTip && hoverIdx !== null && hexes[hoverIdx]?.isVisible) {
            const orderRect = orderPanel.getBoundingClientRect();
            const logRect = logPanelContainer.getBoundingClientRect();
            if (!(mouseX >= orderRect.left && mouseX <= orderRect.right && mouseY >= orderRect.top && mouseY <= orderRect.bottom) &&
                !(mouseX >= logRect.left && mouseX <= logRect.right && mouseY >= logRect.top && mouseY <= logRect.bottom)) {
                newTooltipTarget = { type: 'hex', data: hexes[hoverIdx] };
                showTip = true;
            }
        }

        if (showTip && newTooltipTarget) {
            let tipContent = '';
            if (newTooltipTarget.type === 'hex') { tipContent = getHexTooltipContent(newTooltipTarget.data); }
            else if (newTooltipTarget.type === 'order') { tipContent = getOrderTooltipContent(newTooltipTarget.data); }

            if (tipContent !== lastTooltipContent) {
                tooltipElement.html(tipContent.replace(/\n/g, '<br>'));
                lastTooltipContent = tipContent;
            }
            tooltipElement.show();
        } else {
            if (tooltipElement.style('display') !== 'none') { // Only hide if currently shown
                 tooltipElement.hide();
            }
            lastTooltipContent = ''; // Reset when hidden
        }

        if (tooltipElement.style('display') !== 'none') {
            const tipRect = tooltipElement.elt.getBoundingClientRect();
            let newX = mouseX + 15;
            let newY = mouseY + 15;
            if (newX + tipRect.width > windowWidth - 10) { newX = mouseX - tipRect.width - 10; }
            if (newY + tipRect.height > windowHeight - 10) { newY = mouseY - tipRect.height - 10; }
            if (newX < 10) newX = 10;
            if (newY < 10) newY = 10;

            if (newX !== lastTooltipX || newY !== lastTooltipY) {
                tooltipElement.position(newX, newY);
                lastTooltipX = newX;
                lastTooltipY = newY;
            }
        } else {
             lastTooltipX = -1; // Reset when hidden
             lastTooltipY = -1;
        }
      }
      function addPlayerOrder(type, targetIdx) { if (isEventModalOpen || gameState.combat) return; if (!gameState.playerShip) { addToLog("Cannot add order: No player ship.", "System"); return; } if (targetIdx === null || !hexes[targetIdx]) { addToLog(`Cannot add order: Invalid target index ${targetIdx}.`, "System"); return; } const targetHex = hexes[targetIdx]; const shipIdx = axialToIndex(gameState.playerShip.q, gameState.playerShip.r); if (['Forage', 'Trade', 'Build Outpost', 'Scout'].includes(type) && shipIdx !== targetIdx) { addToLog(`Cannot add order: Ship must be at target (${targetHex.q}, ${targetHex.r}) for ${type}.`, "System"); menuOpen = false; selectedIdx = null; return; } if (isActionDisabled(type, targetHex)) { addToLog(`Cannot add order: ${type} requirements not met at (${targetHex.q}, ${targetHex.r}).`, "System"); menuOpen = false; selectedIdx = null; return; } const newOrder = { id: gameState.nextOrderId++, type: type, targetIdx: targetIdx, cost: (type === 'Sail' || type === 'Attack') ? aStar(shipIdx, targetIdx, MOVE_COST)?.cost : undefined }; gameState.playerOrderQueue.push(newOrder); addToLog(`Order added: ${type} target (${targetHex.q}, ${targetHex.r})`); updateOrderPanel(); select('#endTurnBtn').elt.disabled = false; menuOpen = false; selectedIdx = null; }
      function removePlayerOrder(orderId) { const orderIndex = gameState.playerOrderQueue.findIndex(order => order.id === orderId); if (orderIndex > -1) { const removedOrder = gameState.playerOrderQueue.splice(orderIndex, 1)[0]; addToLog(`Order ${orderId} (${removedOrder.type}) removed.`); updateOrderPanel(); select('#endTurnBtn').elt.disabled = gameState.combat || !gameState.playerShip || gameState.playerOrderQueue.length === 0 || isEventModalOpen; } else { addToLog(`Could not remove order ${orderId}: Not found.`, "System"); } }
      function reorderPlayerOrder(fromIndex, toIndex) { if (fromIndex < 0 || fromIndex >= gameState.playerOrderQueue.length || toIndex < 0 || toIndex >= gameState.playerOrderQueue.length) { console.error(`Invalid reorder indices: from ${fromIndex} to ${toIndex}`); return; } const [item] = gameState.playerOrderQueue.splice(fromIndex, 1); gameState.playerOrderQueue.splice(toIndex, 0, item); addToLog(`Order ${item.id} (${item.type}) moved.`); updateOrderPanel(); }
      function addToLog(message, type = CONSTS.FACTION_PLAYER) {
        let prefix = "";
        let styleClass = "";
        if (type === CONSTS.FACTION_AI) { prefix = CONSTS.LOG_PREFIX_AI; }
        else if (type === 'System') { prefix = CONSTS.LOG_PREFIX_SYSTEM; }
        else if (type === 'Event') { prefix = CONSTS.LOG_PREFIX_EVENT_TEMPLATE(gameState.turnCount); styleClass = `style="color:${CONSTS.EVENT_LOG_COLOUR};"`; }
        else if (type === 'Combat') { prefix = CONSTS.COMBAT_LOG_PREFIX; styleClass = `style="color:${CONSTS.COMBAT_LOG_COLOUR};"`; }
        else { prefix = CONSTS.LOG_PREFIX_PLAYER_TURN_TEMPLATE(gameState.turnCount); }

        const newLogElement = document.createElement('span');
        if (styleClass.startsWith('style="') && styleClass.endsWith('"')) {
            newLogElement.setAttribute('style', styleClass.substring('style="'.length, styleClass.length -1));
        }
        newLogElement.textContent = prefix + message;

        logPanel.appendChild(newLogElement);
        logPanel.appendChild(document.createTextNode('\n'));

        while (logPanel.childNodes.length > CONSTS.LOG_MAX_LINES * 2 && CONSTS.LOG_MAX_LINES > 0) {
            logPanel.removeChild(logPanel.firstChild); // Remove span
            logPanel.removeChild(logPanel.firstChild); // Remove newline text node
        }

        // Sync gameState.turnLog array for compatibility if needed elsewhere
        gameState.turnLog.push(`<span ${styleClass}>${prefix + message}</span>`);
        if (gameState.turnLog.length > CONSTS.LOG_MAX_LINES) {
          gameState.turnLog.shift();
        }

        if (!gameState.combat) logPanel.scrollTop = logPanel.scrollHeight;
      }

      /* ===== EVENT HANDLERS (Strategy Map) ===== */
      function isActionDisabled(actionName, targetHex) {
        if (!targetHex || !gameState.playerShip) return true;
        const playerShip = gameState.playerShip;
        const playerShipOnSelected = targetHex.q === playerShip.q && targetHex.r === playerShip.r;
        const isAIControlledTarget = (targetHex.colony && targetHex.colony.faction === CONSTS.FACTION_AI) || gameState.aiShips.some(s => s.q === targetHex.q && s.r === targetHex.r);
        const targetIdx = axialToIndex(targetHex.q, targetHex.r);

        switch (actionName) {
            case "Sail": return !reachableSet.has(targetIdx);
            case "Attack":
                if (playerShipOnSelected) return true;
                // Can only attack AI colonies or AI ships via menu/click
                const enemyColonyPresent = targetHex.colony && targetHex.colony.faction === CONSTS.FACTION_AI;
                const enemyShipPresent = gameState.aiShips.some(s => s.q === targetHex.q && s.r === targetHex.r);
                if (!enemyColonyPresent && !enemyShipPresent) return true;
                return !reachableSet.has(targetIdx);
            case "Build Outpost":
                if (isAIControlledTarget) return true;
                if (!playerShipOnSelected) return true;
                if (targetHex.colony) return true;
                if ([TerrainType.MOUNTAINS, TerrainType.OCEAN].includes(targetHex.terrain)) return true;
                if (gameState.resources[CONSTS.RESOURCE_WOOD] < CONSTS.BUILD_WOOD_COST) return true;
                if (playerShip.crew < CONSTS.BUILD_CREW_COST) return true;
                if (playerShip.movesLeft < CONSTS.BUILD_MP_COST) return true;
                return false;
            case "Forage":
                if (isAIControlledTarget) return true; if (!playerShipOnSelected) return true;
                if (!targetHex.forageable) return true; if (playerShip.movesLeft < CONSTS.FORAGE_MP_COST) return true;
                return false;
            case "Trade":
                if (isAIControlledTarget) return true; if (!playerShipOnSelected) return true;
                if (!targetHex.market) return true; if (playerShip.movesLeft < CONSTS.TRADE_MP_COST) return true;
                return false;
            case "Scout":
                if (isAIControlledTarget) return true; if (!playerShipOnSelected) return true;
                if (playerShip.movesLeft < CONSTS.SCOUT_MP_COST) return true;
                return false;
            default: return true;
        }
      }
      function mousePressed() {
        if (gameState.combat) { handleCombatMousePressed(); return; }
        if (isEventModalOpen) return;

        // Menu Click Handling
        if (menuOpen) {
            const mx = mouseX - menuX;
            const my = mouseY - menuY;
            if (mx >= 0 && mx <= CONSTS.MENU_WIDTH && my >= 0 && my < actions.length * CONSTS.MENU_ITEM_HEIGHT) {
                const pickedIndex = Math.floor(my / CONSTS.MENU_ITEM_HEIGHT);
                const action = actions[pickedIndex];
                if (!isActionDisabled(action, hexes[selectedIdx])) {
                    if (selectedIdx !== null) {
                        addPlayerOrder(action, selectedIdx);
                    } else {
                        console.error("Menu action attempted with null selectedIdx!");
                        menuOpen = false;
                    }
                } else {
                    addToLog(`Action ${action} is not valid here.`, "System");
                    menuOpen = false;
                    selectedIdx = null;
                }
                return; // Handled menu click
            } else {
                menuOpen = false; // Clicked outside menu
                selectedIdx = null;
            }
        }

        // Map Click Handling (No longer handles initial ship spawn)
        let realClickedIdx = null; // Hex clicked regardless of visibility/exploration
        for (let i = 0; i < hexes.length; i++) {
            if (hexes[i] && pointInHex(mouseX, mouseY, hexes[i])) {
                realClickedIdx = i;
                break;
            }
        }

        const visibleClickedIdx = getHexUnderMouse(); // Hex clicked that is visible

        if (gameState.playerShip && visibleClickedIdx !== null) {
            const targetHex = hexes[visibleClickedIdx];
            if (!targetHex) return;

            const isAIColonyTarget = targetHex.colony && targetHex.colony.faction === CONSTS.FACTION_AI;
            const isAIShipTarget = gameState.aiShips.some(s => s.q === targetHex.q && s.r === targetHex.r);
            const isAIControlledTarget = isAIColonyTarget || isAIShipTarget;

            if (mouseButton === LEFT) {
                if (reachableSet.has(visibleClickedIdx)) {
                    if (isAIControlledTarget) { // Left-click on reachable enemy initiates attack
                         addPlayerOrder('Attack', visibleClickedIdx);
                    } else { // Left-click on reachable empty/friendly hex initiates sail
                        addPlayerOrder('Sail', visibleClickedIdx);
                    }
                } else if (isAIControlledTarget) {
                    addToLog(`Clicked on AI unit/colony at (${targetHex.q}, ${targetHex.r}). Use Right-Click for options or move closer.`, "System");
                    selectedIdx = visibleClickedIdx; // Select for info/potential menu
                } else if (visibleReachableSet.has(visibleClickedIdx)) { // Deprecated? reachableSet should be source of truth
                    addToLog(`Target (${targetHex.q}, ${targetHex.r}) is visible but out of sailing range.`, "System");
                    selectedIdx = visibleClickedIdx;
                } else { // Clicked on a visible hex that's not reachable (e.g. own hex, or blocked)
                    selectedIdx = visibleClickedIdx;
                }
            } else if (mouseButton === RIGHT) {
                selectedIdx = visibleClickedIdx;
                menuX = mouseX; menuY = mouseY;
                clampMenuToScreen();
                menuOpen = true;
            }
        } else if (realClickedIdx !== null) { // Clicked on map, but not a visible hex (or no player ship yet)
            const clickedHex = hexes[realClickedIdx];
            if (!clickedHex.isExplored) {
                addToLog("Clicked on unexplored area.", "System");
            } else { // Clicked on an explored but not currently visible hex
                addToLog(`Clicked into Fog of War at (${clickedHex.q}, ${clickedHex.r}).`, "System");
            }
            menuOpen = false;
            selectedIdx = null;
        } else { // Clicked outside any hex
            menuOpen = false;
            selectedIdx = null;
        }
      }

      /* ===== TURN LOGIC (Phases) ===== */
      function planAITurn() {
        addToLog("Planning AI turn...", CONSTS.FACTION_AI);
        gameState.aiShips.forEach(aiShip => {
          const shipId = aiShip.id;
          const currentOrders = [];
          let currentMp = aiShip.movesLeft;
          if (currentMp <= 0) {
            gameState.aiOrderQueues.set(shipId, []);
            return;
          }
          const currentIdx = axialToIndex(aiShip.q, aiShip.r);
          if (currentIdx === null) {
            gameState.aiOrderQueues.set(shipId, []);
            return;
          }

          let targetIdx = null;
          let sailOrder = null;
          let mpAfterSail = currentMp;
          let plannedEndIdx = currentIdx;
          let nearestPlayerColonyDist = Infinity;
          let nearestPlayerColonyIdx = null;

          if (gameState.playerColonyIndices) {
            gameState.playerColonyIndices.forEach(colonyIdx => {
              const h = hexes[colonyIdx];
              if (h && h.colony && h.colony.faction === CONSTS.FACTION_PLAYER) {
                const dist = axialDistance(aiShip, h);
                if (dist < nearestPlayerColonyDist && dist <= CONSTS.AI_TARGET_COLONY_RANGE) {
                  nearestPlayerColonyDist = dist;
                  nearestPlayerColonyIdx = colonyIdx;
                }
              }
            });
          }

          if (nearestPlayerColonyIdx !== null) {
            targetIdx = nearestPlayerColonyIdx;
          } else {
            let nearestCoastDist = Infinity;
            let nearestCoastIdx = null;
            if (gameState.coastHexIndices) {
              gameState.coastHexIndices.forEach(coastIdx => {
                const h = hexes[coastIdx];
                if (h && !h.colony) {
                  const dist = axialDistance(aiShip, h);
                  if (dist < nearestCoastDist) {
                    nearestCoastDist = dist;
                    nearestCoastIdx = coastIdx;
                  }
                }
              });
            }

            if (nearestCoastIdx !== null) {
              targetIdx = nearestCoastIdx;
            } else {
              const aiReachable = computeReachable(aiShip.q, aiShip.r, currentMp);
              const potentialTargets = [];
              aiReachable.forEach(idx => {
                const h = hexes[idx];
                if (h && (h.terrain === TerrainType.COAST || h.forageable || h.market) && !h.colony) {
                  potentialTargets.push(idx);
                }
              });
              if (potentialTargets.length > 0) {
                targetIdx = random(potentialTargets);
              }
            }
          }

          if (targetIdx !== null && targetIdx !== currentIdx) {
            const pathResult = aStar(currentIdx, targetIdx, MOVE_COST);
            if (pathResult && pathResult.path.length > 0) {
              let mpSpent = 0;
              let reachablePathEndIdx = currentIdx;
              for (const stepIdx of pathResult.path) {
                const stepCost = MOVE_COST[hexes[stepIdx].terrain] ?? CONSTS.DEFAULT_MOVE_COST;
                if (mpSpent + stepCost <= currentMp) {
                  mpSpent += stepCost;
                  reachablePathEndIdx = stepIdx;
                } else {
                  break;
                }
              }
              if (reachablePathEndIdx !== currentIdx) {
                sailOrder = { id: gameState.nextOrderId++, type: 'Sail', targetIdx: reachablePathEndIdx, cost: mpSpent };
                plannedEndIdx = reachablePathEndIdx;
                mpAfterSail = currentMp - mpSpent;
              }
            }
          }

          if (sailOrder) {
            currentOrders.push(sailOrder);
          }

          const plannedEndHex = hexes[plannedEndIdx];
          if (!plannedEndHex) {
            gameState.aiOrderQueues.set(shipId, currentOrders);
            return;
          }

          let performedSecondaryAction = false;
          if (plannedEndHex.terrain === TerrainType.COAST && !plannedEndHex.colony && aiShip.crew >= CONSTS.BUILD_CREW_COST && mpAfterSail >= CONSTS.BUILD_MP_COST) {
            const buildOrder = { id: gameState.nextOrderId++, type: 'Build Outpost', targetIdx: plannedEndIdx };
            currentOrders.push(buildOrder);
            mpAfterSail -= CONSTS.BUILD_MP_COST;
            performedSecondaryAction = true;
          }

          if (!performedSecondaryAction && plannedEndHex.forageable && mpAfterSail >= CONSTS.FORAGE_MP_COST) {
            const resourceType = (plannedEndHex.terrain === TerrainType.FOREST) ? CONSTS.RESOURCE_WOOD : CONSTS.RESOURCE_WHEAT;
            if (aiShip.cargo[resourceType] < CONSTS.SHIP_MAX_CARGO * 0.5 || (aiShip.cargo[CONSTS.RESOURCE_WHEAT] + aiShip.cargo[CONSTS.RESOURCE_WOOD]) < CONSTS.SHIP_MAX_CARGO) {
              const forageOrder = { id: gameState.nextOrderId++, type: 'Forage', targetIdx: plannedEndIdx };
              currentOrders.push(forageOrder);
              mpAfterSail -= CONSTS.FORAGE_MP_COST;
              performedSecondaryAction = true;
            }
          }

          if (!performedSecondaryAction && plannedEndHex.market && mpAfterSail >= CONSTS.TRADE_MP_COST) {
            const market = plannedEndHex.market;
            let tradeOrder = null;
            const resToBuy = aiShip.cargo[CONSTS.RESOURCE_WHEAT] < 5 ? CONSTS.RESOURCE_WHEAT : (aiShip.cargo[CONSTS.RESOURCE_WOOD] < 5 ? CONSTS.RESOURCE_WOOD : null);
            const resToSell = aiShip.cargo[CONSTS.RESOURCE_WHEAT] > CONSTS.SHIP_MAX_CARGO * 0.8 ? CONSTS.RESOURCE_WHEAT : (aiShip.cargo[CONSTS.RESOURCE_WOOD] > CONSTS.SHIP_MAX_CARGO * 0.8 ? CONSTS.RESOURCE_WOOD : null);

            if (resToBuy && market.buy[resToBuy] && aiShip.cargo[CONSTS.RESOURCE_GOLD] >= market.buy[resToBuy] && aiShip.cargo[resToBuy] < CONSTS.SHIP_MAX_CARGO) {
              tradeOrder = { id: gameState.nextOrderId++, type: 'Trade', targetIdx: plannedEndIdx, action: 'Buy', resource: resToBuy, amount: 1 };
            } else if (resToSell && market.sell[resToSell] && aiShip.cargo[resToSell] > 0) {
              tradeOrder = { id: gameState.nextOrderId++, type: 'Trade', targetIdx: plannedEndIdx, action: 'Sell', resource: resToSell, amount: 1 };
            }
            if (tradeOrder) {
              currentOrders.push(tradeOrder);
              mpAfterSail -= CONSTS.TRADE_MP_COST;
              performedSecondaryAction = true;
            }
          }
          gameState.aiOrderQueues.set(shipId, currentOrders);
        });
      }
      function executeAllTurnOrders() { addToLog(`--- Executing Orders Turn ${gameState.turnCount} ---`, "System"); if (gameState.playerShip) { const playerShip = gameState.playerShip; const playerQueue = [...gameState.playerOrderQueue]; gameState.playerOrderQueue = []; let currentShipIdx = axialToIndex(playerShip.q, playerShip.r); if (playerQueue.length > 0) { addToLog(`Executing Player [${playerShip.id}] orders (${playerQueue.length})...`); for (const order of playerQueue) { currentShipIdx = resolveOrder(order, playerShip, currentShipIdx); if (gameState.combat) { addToLog("Combat initiated, remaining orders for this ship discarded.", "System"); updateOrderPanel(); return; } } addToLog(`Player [${playerShip.id}] finished orders.`); } } else { if (gameState.playerOrderQueue.length > 0) { addToLog("Clearing player order queue (no ship present).", "System"); gameState.playerOrderQueue = []; } } gameState.aiShips.forEach(aiShip => { if (gameState.combat) return; const aiQueue = gameState.aiOrderQueues.get(aiShip.id) || []; gameState.aiOrderQueues.set(aiShip.id, []); let currentShipIdx = axialToIndex(aiShip.q, aiShip.r); if (aiQueue.length > 0) { addToLog(`Executing AI Ship [${aiShip.id}] orders (${aiQueue.length})...`, CONSTS.FACTION_AI); for (const order of aiQueue) { currentShipIdx = resolveOrder(order, aiShip, currentShipIdx); if (gameState.combat) { addToLog("Combat initiated, remaining orders for this ship discarded.", "System"); updateOrderPanel(); return; } } addToLog(`AI Ship [${aiShip.id}] finished orders.`, CONSTS.FACTION_AI); } else { addToLog(`AI Ship [${aiShip.id}] has no orders queued.`, CONSTS.FACTION_AI); } }); if (!gameState.combat) addToLog("--- Order Execution Complete ---", "System"); if (gameState.playerShip) { reachableSet = computeReachable(gameState.playerShip.q, gameState.playerShip.r, gameState.playerShip.movesLeft); } else { reachableSet.clear(); } updateVisibility(); updateOrderPanel(); select('#endTurnBtn').elt.disabled = true; }
      function resolveOrder(order, ship, currentShipIdx) { const faction = ship.faction; const logPrefix = faction === CONSTS.FACTION_AI ? CONSTS.FACTION_AI : CONSTS.FACTION_PLAYER; if (currentShipIdx === null) { addToLog(`Order ${order.id} (${order.type}) skipped: Ship ${ship.id} invalid state.`, logPrefix); return currentShipIdx; } const targetHex = hexes[order.targetIdx]; if (!targetHex) { addToLog(`Order ${order.id} (${order.type}) skipped: Invalid target index ${order.targetIdx}.`, logPrefix); return currentShipIdx; } const targetCoordsLabel = `(${targetHex.q}, ${targetHex.r})`; const needsPresence = ['Build Outpost', 'Forage', 'Trade', 'Scout']; if (needsPresence.includes(order.type) && currentShipIdx !== order.targetIdx) { addToLog(`Order ${order.id} (${order.type}) at ${targetCoordsLabel} skipped: Ship ${ship.id} not present.`, logPrefix); return currentShipIdx; } switch (order.type) { case 'Sail': case 'Attack': { const pathResult = aStar(currentShipIdx, order.targetIdx, MOVE_COST); const calculatedCost = pathResult ? pathResult.cost : Infinity; if (!pathResult || calculatedCost === Infinity) { addToLog(`Order ${order.id} (${order.type}) to ${targetCoordsLabel} failed: No path.`, logPrefix); return currentShipIdx; } if (calculatedCost > ship.movesLeft) { addToLog(`Order ${order.id} (${order.type}) to ${targetCoordsLabel} failed: Insufficient MP (Needs ${calculatedCost}, Has ${ship.movesLeft}).`, logPrefix); return currentShipIdx; } const destCoords = indexToAxial(order.targetIdx); if (!destCoords) { console.error(`Critical Error: ${order.type} destination index ${order.targetIdx}`); addToLog(`Order ${order.id} (${order.type}) critical error.`, logPrefix); return currentShipIdx; } ship.q = destCoords.q; ship.r = destCoords.r; ship.movesLeft -= calculatedCost; currentShipIdx = order.targetIdx; addToLog(`Order ${order.id}: Ship ${ship.id} moved to ${targetCoordsLabel} ${getTerrainName(targetHex.terrain)} for ${order.type} (Cost ${calculatedCost}, MP left ${ship.movesLeft}).`, logPrefix); if (order.type === 'Attack') { if (targetHex.colony && targetHex.colony.faction !== ship.faction) { enterCombat(ship, targetHex, CONSTS.COMBAT_CONTEXT_SHIP_VS_COLONY); } else { const enemyShipOnHex = gameState.aiShips.find(s => s.q === targetHex.q && s.r === targetHex.r && s.faction !== ship.faction) || (gameState.playerShip && ship.faction === CONSTS.FACTION_AI && gameState.playerShip.q === targetHex.q && gameState.playerShip.r === targetHex.r); if (enemyShipOnHex) { enterCombat(ship, enemyShipOnHex, CONSTS.COMBAT_CONTEXT_SHIP_VS_SHIP); } } } break; } case 'Scout': { if (CONSTS.SCOUT_MP_COST > ship.movesLeft) { addToLog(`Order ${order.id} (Scout) at ${targetCoordsLabel} failed: Insufficient MP.`, logPrefix); return currentShipIdx; } ship.movesLeft -= CONSTS.SCOUT_MP_COST; let revealedCount = 0; if (faction === CONSTS.FACTION_PLAYER) { for (const idx of spiral(targetHex.q, targetHex.r, 1)) { if (hexes[idx] && !hexes[idx].isExplored) { hexes[idx].isExplored = true; revealedCount++; } } addToLog(`Order ${order.id}: Ship ${ship.id} scouted at ${targetCoordsLabel}. Revealed ${revealedCount} hexes (Cost ${CONSTS.SCOUT_MP_COST}, MP left ${ship.movesLeft}).`, logPrefix); } else { addToLog(`Order ${order.id}: AI Ship ${ship.id} scouted at ${targetCoordsLabel} (Cost ${CONSTS.SCOUT_MP_COST}, MP left ${ship.movesLeft}).`, logPrefix); } break; } case 'Build Outpost': { if ([TerrainType.MOUNTAINS, TerrainType.OCEAN].includes(targetHex.terrain)) { addToLog(`Build failed: Cannot build on ${getTerrainName(targetHex.terrain)}.`, logPrefix); return currentShipIdx; } if (targetHex.colony !== null) { addToLog(`Build failed: Location occupied.`, logPrefix); return currentShipIdx; } if (CONSTS.BUILD_MP_COST > ship.movesLeft) { addToLog(`Build failed: Insufficient MP.`, logPrefix); return currentShipIdx; } if (ship.crew < CONSTS.BUILD_CREW_COST) { addToLog(`Build failed: Insufficient Crew.`, logPrefix); return currentShipIdx; } let resourceCostStr = ""; if (faction === CONSTS.FACTION_PLAYER) { if (gameState.resources[CONSTS.RESOURCE_WOOD] < CONSTS.BUILD_WOOD_COST) { addToLog(`Build failed: Insufficient Global ${CONSTS.RESOURCE_WOOD}.`, logPrefix); return currentShipIdx; } gameState.resources[CONSTS.RESOURCE_WOOD] -= CONSTS.BUILD_WOOD_COST; resourceCostStr = `${CONSTS.BUILD_WOOD_COST} ${CONSTS.RESOURCE_WOOD} (Global), `; } ship.movesLeft -= CONSTS.BUILD_MP_COST; ship.crew -= CONSTS.BUILD_CREW_COST; const newColonyName = generateColonyName(faction); targetHex.colony = { name: newColonyName, stock: { [CONSTS.RESOURCE_WHEAT]: 0, [CONSTS.RESOURCE_WOOD]: 0 }, crew: CONSTS.BUILD_CREW_COST, faction: faction, q: targetHex.q, r: targetHex.r }; addToLog(`Order ${order.id}: Ship ${ship.id} founded colony "${newColonyName}" at ${targetCoordsLabel} (Cost ${CONSTS.BUILD_MP_COST} MP, ${resourceCostStr}${CONSTS.BUILD_CREW_COST} Crew. MP left ${ship.movesLeft})`, logPrefix); if (faction === CONSTS.FACTION_PLAYER) { if (!gameState.playerColonyIndices) { gameState.playerColonyIndices = []; } gameState.playerColonyIndices.push(order.targetIdx); } break; } case 'Forage': { if (!targetHex.forageable) { addToLog(`Forage failed: Not forageable terrain.`, logPrefix); return currentShipIdx; } if (CONSTS.FORAGE_MP_COST > ship.movesLeft) { addToLog(`Forage failed: Insufficient MP.`, logPrefix); return currentShipIdx; } const resourceType = (targetHex.terrain === TerrainType.FOREST) ? CONSTS.RESOURCE_WOOD : CONSTS.RESOURCE_WHEAT; let yieldAmount = Math.floor(random(1, 4)); const totalCargoNow = Object.values(ship.cargo).reduce((a,b)=>a+b,0); const spaceAvailable = CONSTS.SHIP_MAX_CARGO - totalCargoNow; const actualAmount = Math.max(0, Math.min(yieldAmount, spaceAvailable)); ship.movesLeft -= CONSTS.FORAGE_MP_COST; if (actualAmount > 0) { ship.cargo[resourceType] = (ship.cargo[resourceType]||0) + actualAmount; addToLog(`Order ${order.id}: Ship ${ship.id} foraged ${actualAmount} ${resourceType} at ${targetCoordsLabel} (Cost ${CONSTS.FORAGE_MP_COST}, MP left ${ship.movesLeft}).`, logPrefix); if (yieldAmount > actualAmount) { addToLog(`   (Cargo capacity reached)`, logPrefix); } } else { addToLog(`Order ${order.id}: Ship ${ship.id} attempted forage at ${targetCoordsLabel}, but cargo full. MP Spent. (MP left ${ship.movesLeft}).`, logPrefix); } break; } case 'Trade': { const market = targetHex.market; if (!market) { addToLog(`Trade failed: No market.`, logPrefix); return currentShipIdx; } if (CONSTS.TRADE_MP_COST > ship.movesLeft) { addToLog(`Trade failed: Insufficient MP.`, logPrefix); return currentShipIdx; } ship.movesLeft -= CONSTS.TRADE_MP_COST; let action = null; let resource = null; let amount = 1; if (faction === CONSTS.FACTION_AI && order.action && order.resource) { action = order.action; resource = order.resource; amount = order.amount || 1; } else { if (ship.cargo[CONSTS.RESOURCE_GOLD] >= market.buy[CONSTS.RESOURCE_WHEAT] && (ship.cargo[CONSTS.RESOURCE_WHEAT]||0) < CONSTS.SHIP_MAX_CARGO) { action = 'Buy'; resource = CONSTS.RESOURCE_WHEAT; amount = 1; } else if ((ship.cargo[CONSTS.RESOURCE_WHEAT]||0) > 0 && market.sell[CONSTS.RESOURCE_WHEAT] > 0) { action = 'Sell'; resource = CONSTS.RESOURCE_WHEAT; amount = 1; } } if (action && resource && market.buy[resource] !== null && market.sell[resource] !== null) { if (action === 'Buy') { const cost = market.buy[resource] * amount; const canAfford = ship.cargo[CONSTS.RESOURCE_GOLD] >= cost; const totalCargoNow = Object.values(ship.cargo).reduce((a,b)=>a+b,0) - (ship.cargo[resource]||0); const hasSpace = (totalCargoNow + amount) <= CONSTS.SHIP_MAX_CARGO; if (canAfford && hasSpace) { ship.cargo[resource] = (ship.cargo[resource]||0) + amount; ship.cargo[CONSTS.RESOURCE_GOLD] -= cost; addToLog(`Order ${order.id}: Ship ${ship.id} bought ${amount} ${resource} for ${cost} ${CONSTS.RESOURCE_GOLD} at ${targetCoordsLabel}.`, logPrefix); } else { addToLog(`Trade (Buy ${resource}) failed (Afford: ${canAfford}, Space: ${hasSpace}).`, logPrefix); } } else if (action === 'Sell') { const hasResource = (ship.cargo[resource]||0) >= amount; const canSell = market.sell[resource] > 0; if (hasResource && canSell) { const earnings = market.sell[resource] * amount; ship.cargo[resource] -= amount; ship.cargo[CONSTS.RESOURCE_GOLD] += earnings; addToLog(`Order ${order.id}: Ship ${ship.id} sold ${amount} ${resource} for ${earnings} ${CONSTS.RESOURCE_GOLD} at ${targetCoordsLabel}.`, logPrefix); } else { addToLog(`Trade (Sell ${resource}) failed (Have: ${hasResource}, Market Buys: ${canSell}).`, logPrefix); } } } else { addToLog(`Trade attempt at ${targetCoordsLabel}, no valid transaction. MP Spent.`, logPrefix); } addToLog(`   (MP left ${ship.movesLeft})`, logPrefix); break; } default: addToLog(`Order ${order.id} skipped: Unknown order type "${order.type}".`, logPrefix); } return currentShipIdx; }
      function performColonyUpkeep() { let playerColonies = hexes.filter(h => h && h.colony && h.colony.faction === CONSTS.FACTION_PLAYER); if (playerColonies.length === 0) return; addToLog("Performing player colony upkeep..."); let totalWheatConsumed = 0; let starvedColonies = 0; playerColonies.forEach(h => { const colony = h.colony; let needed = (CONSTS.COLONY_UPKEEP_WHEAT_PER_CREW * colony.crew) || 1; let consumed = 0; let localConsume = Math.min(needed, colony.stock[CONSTS.RESOURCE_WHEAT]); if (localConsume > 0) { colony.stock[CONSTS.RESOURCE_WHEAT] -= localConsume; consumed += localConsume; needed -= localConsume; } if (needed > 0) { let globalConsume = Math.min(needed, gameState.resources[CONSTS.RESOURCE_WHEAT]); if (globalConsume > 0) { gameState.resources[CONSTS.RESOURCE_WHEAT] -= globalConsume; consumed += globalConsume; needed -= globalConsume; addToLog(`Colony "${colony.name}" drew ${globalConsume} ${CONSTS.RESOURCE_WHEAT} from global stock.`); } } if (needed > 0) { addToLog(`Colony "${colony.name}" at (${h.q}, ${h.r}) suffers hunger! (Lacked ${needed} ${CONSTS.RESOURCE_WHEAT}) Crew: ${colony.crew}`, "System"); starvedColonies++; } else { totalWheatConsumed += consumed; } }); if (totalWheatConsumed > 0) addToLog(`Total player colony upkeep: ${totalWheatConsumed} ${CONSTS.RESOURCE_WHEAT} consumed.`); if (starvedColonies === 0 && playerColonies.length > 0) addToLog("All player colonies fed."); else if (starvedColonies > 0) addToLog(`${starvedColonies} player colonies experienced hunger.`, "System"); }
      function performShipColonyTransfer() { if ((!gameState.playerShip && gameState.aiShips.length === 0) || !hexes.some(h => h && h.colony)) return; addToLog("Performing Ship->Colony transfers...", "System"); let transferOccurred = false; if (gameState.playerShip) { const ship = gameState.playerShip; const currentShipIdx = axialToIndex(ship.q, ship.r); if (currentShipIdx !== null) { const endTurnHex = hexes[currentShipIdx]; if (endTurnHex && endTurnHex.colony && endTurnHex.colony.faction === CONSTS.FACTION_PLAYER) { const colony = endTurnHex.colony; const transferLimit = 5; const wheatToTransfer = Math.min(transferLimit, ship.cargo[CONSTS.RESOURCE_WHEAT]||0); if (wheatToTransfer > 0) { colony.stock[CONSTS.RESOURCE_WHEAT] = (colony.stock[CONSTS.RESOURCE_WHEAT]||0) + wheatToTransfer; ship.cargo[CONSTS.RESOURCE_WHEAT] -= wheatToTransfer; addToLog(`Ship ${ship.id} transferred ${wheatToTransfer} ${CONSTS.RESOURCE_WHEAT} to colony "${colony.name}".`); transferOccurred = true; } const woodToTransfer = Math.min(transferLimit, ship.cargo[CONSTS.RESOURCE_WOOD]||0); if (woodToTransfer > 0) { colony.stock[CONSTS.RESOURCE_WOOD] = (colony.stock[CONSTS.RESOURCE_WOOD]||0) + woodToTransfer; ship.cargo[CONSTS.RESOURCE_WOOD] -= woodToTransfer; addToLog(`Ship ${ship.id} transferred ${woodToTransfer} ${CONSTS.RESOURCE_WOOD} to colony "${colony.name}".`); transferOccurred = true; } } } } gameState.aiShips.forEach(ship => { const currentShipIdx = axialToIndex(ship.q, ship.r); if (currentShipIdx !== null) { const endTurnHex = hexes[currentShipIdx]; if (endTurnHex && endTurnHex.colony && endTurnHex.colony.faction === CONSTS.FACTION_AI) { const colony = endTurnHex.colony; const transferLimit = 5; const wheatToTransfer = Math.min(transferLimit, ship.cargo[CONSTS.RESOURCE_WHEAT]||0); if (wheatToTransfer > 0) { colony.stock[CONSTS.RESOURCE_WHEAT] = (colony.stock[CONSTS.RESOURCE_WHEAT]||0) + wheatToTransfer; ship.cargo[CONSTS.RESOURCE_WHEAT] -= wheatToTransfer; addToLog(`AI Ship ${ship.id} transferred ${wheatToTransfer} ${CONSTS.RESOURCE_WHEAT} to colony "${colony.name}".`, CONSTS.FACTION_AI); transferOccurred = true; } const woodToTransfer = Math.min(transferLimit, ship.cargo[CONSTS.RESOURCE_WOOD]||0); if (woodToTransfer > 0) { colony.stock[CONSTS.RESOURCE_WOOD] = (colony.stock[CONSTS.RESOURCE_WOOD]||0) + woodToTransfer; ship.cargo[CONSTS.RESOURCE_WOOD] -= woodToTransfer; addToLog(`AI Ship ${ship.id} transferred ${woodToTransfer} ${CONSTS.RESOURCE_WOOD} to colony "${colony.name}".`, CONSTS.FACTION_AI); transferOccurred = true; } } } }); if (!transferOccurred) { addToLog("No ship-colony transfers occurred.", "System"); } }
      function applyHazards() { if (gameState.activeHazards.length === 0) return; addToLog("Applying Hazard effects...", "System"); const remainingHazards = []; let hazardEffectsApplied = false; gameState.activeHazards.forEach(hazard => { hazard.ttl--; if (hazard.ttl <= 0) { addToLog(`Hazard ${hazard.kind} at (${hexes[hazard.idx].q}, ${hexes[hazard.idx].r}) dissipated.`, "System"); return; } if (gameState.playerShip) { const playerIdx = axialToIndex(gameState.playerShip.q, gameState.playerShip.r); if (playerIdx === hazard.idx) { applyHazardEffect(gameState.playerShip, hazard); hazardEffectsApplied = true; } } gameState.aiShips.forEach(aiShip => { const aiIdx = axialToIndex(aiShip.q, aiShip.r); if (aiIdx === hazard.idx) { applyHazardEffect(aiShip, hazard); hazardEffectsApplied = true; } }); remainingHazards.push(hazard); }); gameState.activeHazards = remainingHazards; if (!hazardEffectsApplied) { addToLog("No ships were affected by hazards this turn.", "System"); } }
      function applyHazardEffect(ship, hazard) { if (!ship.status) ship.status = {}; const logPrefix = ship.faction === CONSTS.FACTION_AI ? CONSTS.FACTION_AI : CONSTS.FACTION_PLAYER; if (hazard.kind === 'Storm') { ship.status.stormPenaltyNextTurn = true; addToLog(`Ship ${ship.id} caught in ${hazard.kind} at (${hexes[hazard.idx].q}, ${hexes[hazard.idx].r})! (-1 MP next turn).`, logPrefix); } else if (hazard.kind === 'Reef') { if (random() < 0.3) { ship.status.leak = (ship.status.leak || 0) + 1; addToLog(`Ship ${ship.id} struck a reef at (${hexes[hazard.idx].q}, ${hexes[hazard.idx].r})! Hull damaged (Leaking).`, logPrefix); } else { addToLog(`Ship ${ship.id} navigated the reef at (${hexes[hazard.idx].q}, ${hexes[hazard.idx].r}) safely.`, logPrefix); } } else if (hazard.kind === 'Pirates') { const goldLoss = Math.min(ship.cargo[CONSTS.RESOURCE_GOLD], Math.floor(random(1, 6))); if (goldLoss > 0) { ship.cargo[CONSTS.RESOURCE_GOLD] -= goldLoss; addToLog(`Ship ${ship.id} ambushed by pirates at (${hexes[hazard.idx].q}, ${hexes[hazard.idx].r})! Lost ${goldLoss} ${CONSTS.RESOURCE_GOLD}.`, logPrefix); } else { addToLog(`Ship ${ship.id} encountered pirates at (${hexes[hazard.idx].q}, ${hexes[hazard.idx].r}) but had nothing to steal.`, logPrefix); } } }
      function spawnStormNear(ship) { const centerQ = ship.q; const centerR = ship.r; const potentialSpawns = []; for (let radius = 2; radius <= 3; radius++) { for (const idx of spiral(centerQ, centerR, radius)) { if (axialDistance({q:centerQ, r:centerR}, hexes[idx]) !== radius) continue; const h = hexes[idx]; if (h && (h.terrain === TerrainType.OCEAN || h.terrain === TerrainType.COAST)) { const isOccupied = gameState.activeHazards.some(haz => haz.idx === idx) || h.colony || (gameState.playerShip && axialToIndex(gameState.playerShip.q, gameState.playerShip.r) === idx) || gameState.aiShips.some(s => axialToIndex(s.q, s.r) === idx); if (!isOccupied) { potentialSpawns.push({idx: idx, weight: (h.terrain === TerrainType.OCEAN ? 2 : 1)}); } } } if (potentialSpawns.length > 0) break; } if (potentialSpawns.length > 0) { let weightedList = []; potentialSpawns.forEach(s => { for(let i=0; i<s.weight; i++) weightedList.push(s.idx); }); const targetIdx = random(weightedList); return { id: gameState.nextHazardId++, idx: targetIdx, kind: 'Storm', ttl: CONSTS.STORM_DEFAULT_TTL }; } return null; }
      function reshuffleDeck() { addToLog("Reshuffling event discard pile into deck.", "System"); gameState.eventDeck = shuffleByWeight(gameState.discardPile.length > 0 ? gameState.discardPile : EVENT_POOL); gameState.discardPile = []; if (gameState.eventDeck.length === 0) { console.error("CRITICAL: Event deck empty after reshuffle! Check EVENT_POOL."); addToLog("CRITICAL: Event deck empty after reshuffle!", "System"); } }
      let pendingEventDraws = []; let currentModalCard = null;
      function processEventPhase() { addToLog("--- Event Phase ---", "System"); pendingEventDraws = []; let shipsToProcess = []; if(gameState.playerShip) shipsToProcess.push(gameState.playerShip); shipsToProcess = shipsToProcess.concat(gameState.aiShips); if (shipsToProcess.length === 0) { addToLog("No ships present for event phase.", "System"); gameState.postCombatTurnResumeCallback = null; select('#endTurnBtn').elt.disabled = isEventModalOpen || (gameState.playerShip && gameState.playerOrderQueue.length > 0); return; } shipsToProcess.forEach(ship => { if (gameState.eventDeck.length === 0) { reshuffleDeck(); } if (gameState.eventDeck.length === 0) return; const card = gameState.eventDeck.pop(); if (!card) { console.error("Popped undefined card from deck!"); return; } pendingEventDraws.push({ ship, card }); gameState.discardPile.push(card); }); processNextEvent(); }
      function processNextEvent() { if (pendingEventDraws.length === 0) { addToLog("--- Event Phase Complete ---", "System"); gameState.postCombatTurnResumeCallback = null; select('#endTurnBtn').elt.disabled = isEventModalOpen || (gameState.playerShip && gameState.playerOrderQueue.length > 0); return; } const { ship, card } = pendingEventDraws.shift(); addToLog(`Drawing event "${card.name}" for ${ship.faction} Ship ${ship.id}...`, "Event"); if (card.type === 'Instant') { card.effectFn(ship); processNextEvent(); } else if (card.type === 'Choice') { if (ship.faction === CONSTS.FACTION_PLAYER) { showEventModal(card, ship); } else { aiEventAutoResolve(card, ship); processNextEvent(); } } else { addToLog(`Unknown event type "${card.type}" for card "${card.name}". Skipping.`, "System"); processNextEvent(); } }
      function showEventModal(card, ship) { isEventModalOpen = true; currentModalCard = { card, ship }; eventModalTitle.textContent = card.name; eventModalBody.textContent = card.desc || "Make your choice."; eventModalButtons.innerHTML = ''; (card.options || ['OK']).forEach((optionText, index) => { const button = document.createElement('button'); button.textContent = optionText; button.classList.add(index === 0 ? 'primary' : 'secondary'); button.onclick = () => resolveChoice(optionText); eventModalButtons.appendChild(button); }); eventModalBackdrop.style.display = 'block'; eventModal.style.display = 'block'; select('#endTurnBtn').elt.disabled = true; tooltipElement.hide(); }
      function resolveChoice(choiceString) { if (!currentModalCard) { console.error("resolveChoice called with no currentModalCard!"); hideEventModal(); return; } const { card, ship } = currentModalCard; if (card.effectFn) { card.effectFn(ship, choiceString); } else { addToLog(`Card "${card.name}" resolved choice "${choiceString}" (no effectFn).`, "Event"); } hideEventModal(); currentModalCard = null; processNextEvent(); }
      function hideEventModal() { isEventModalOpen = false; eventModalBackdrop.style.display = 'none'; eventModal.style.display = 'none'; select('#endTurnBtn').elt.disabled = (gameState.playerShip && gameState.playerOrderQueue.length > 0); }
      function aiEventAutoResolve(card, ship) { const logPrefix = CONSTS.FACTION_AI; addToLog(`AI Ship ${ship.id} encounters event: "${card.name}"`, logPrefix); if (card.type === 'Choice') { const choice = card.options[card.options.length - 1]; addToLog(`   AI chooses: "${choice}"`, logPrefix); if (card.effectFn) { card.effectFn(ship, choice); } } else { if (card.effectFn) { card.effectFn(ship); } } }
      function updateShipStatuses() { if (!gameState.playerShip && gameState.aiShips.length === 0) return; addToLog("Updating ship statuses...", "System"); let statusChanged = false; const processShipStatus = (ship) => { if (!ship.status) return; const logPrefix = ship.faction === CONSTS.FACTION_AI ? CONSTS.FACTION_AI : CONSTS.FACTION_PLAYER; if (ship.status.crewSick > 0) { ship.status.crewSick--; statusChanged = true; if (ship.status.crewSick === 0) { addToLog(`Ship ${ship.id} crew sickness subsided.`, logPrefix); delete ship.status.crewSick; } } if (ship.status.leak > 0) { ship.status.leak--; statusChanged = true; addToLog(`Ship ${ship.id} continues leaking...`, logPrefix); if (ship.status.leak === 0) { addToLog(`Ship ${ship.id} hull leak repaired.`, logPrefix); delete ship.status.leak; } } }; if(gameState.playerShip) processShipStatus(gameState.playerShip); gameState.aiShips.forEach(processShipStatus); if (!statusChanged) { addToLog("No ship status changes.", "System"); } }
      function checkForSpontaneousCombat() { if (gameState.combat || !gameState.playerShip) return false; const playerShip = gameState.playerShip; const playerHex = indexToAxial(axialToIndex(playerShip.q, playerShip.r)); if (!playerHex) return false; for (const aiShip of gameState.aiShips) { const aiHex = indexToAxial(axialToIndex(aiShip.q, aiShip.r)); if (!aiHex) continue; if (axialDistance(playerHex, aiHex) === 1) { addToLog(`Spontaneous combat: Player Ship ${playerShip.id} vs AI Ship ${aiShip.id}`, "Combat"); enterCombat(playerShip, aiShip, CONSTS.COMBAT_CONTEXT_SHIP_VS_SHIP); return true; } } return false; }
      function endTurn() { if (isEventModalOpen || gameState.combat || gameState.isTurnProcessingPausedForCombat) { addToLog("Cannot end turn: Event modal, combat in progress, or turn processing paused.", "System"); return; } select('#endTurnBtn').elt.disabled = true; menuOpen = false; selectedIdx = null; currentPathPreview = null; addToLog(`--- Player Ending Turn ${gameState.turnCount} ---`, "System"); planAITurn(); executeAllTurnOrders(); if (gameState.combat) { gameState.isTurnProcessingPausedForCombat = true; gameState.postCombatTurnResumeCallback = resumeEndTurnSequenceAfterCombat; addToLog("Turn processing paused for combat (initiated by order).", "System"); return; } if (checkForSpontaneousCombat()) { gameState.isTurnProcessingPausedForCombat = true; gameState.postCombatTurnResumeCallback = resumeEndTurnSequenceAfterCombat; addToLog("Turn processing paused for combat (spontaneous).", "System"); return; } resumeEndTurnSequenceAfterCombat(); }
      function resumeEndTurnSequenceAfterCombat() { gameState.isTurnProcessingPausedForCombat = false; gameState.postCombatTurnResumeCallback = null; if (gameState.combat) { addToLog("Error: Trying to resume turn sequence while still in combat.", "System"); return; } addToLog("Resuming end of turn sequence (hazards, upkeep, events, MP reset)...", "System"); applyHazards(); performColonyUpkeep(); performShipColonyTransfer(); updateShipStatuses(); gameState.turnCount++; const applyMPModifiers = (ship) => { let baseMP = CONSTS.MOVE_POINTS_PER_TURN; let mpMod = 0; let reason = []; if (!ship.status) ship.status = {}; if (ship.status.stormPenaltyNextTurn) { mpMod -= 1; reason.push("Storm"); delete ship.status.stormPenaltyNextTurn; } if (ship.status.crewSick > 0) { mpMod -= 1; reason.push("Sickness"); } if (ship.status.leak > 0) { mpMod -= 1; reason.push("Leak"); } if (ship.status.windBoost > 0) { mpMod += ship.status.windBoost; reason.push(`Wind (+${ship.status.windBoost})`); delete ship.status.windBoost; } ship.movesLeft = Math.max(1, baseMP + mpMod); if (mpMod !== 0) { addToLog(`Ship ${ship.id} MP modified for Turn ${gameState.turnCount} due to: ${reason.join(', ')}. MP: ${ship.movesLeft}/${baseMP}`, ship.faction); } else { ship.movesLeft = baseMP; } }; if (gameState.playerShip) { applyMPModifiers(gameState.playerShip); } gameState.aiShips.forEach(applyMPModifiers); if (gameState.playerShip) { reachableSet = computeReachable(gameState.playerShip.q, gameState.playerShip.r, gameState.playerShip.movesLeft); } else { reachableSet.clear(); visibleReachableSet.clear(); } updateVisibility(); const playerMPStr = gameState.playerShip ? `${gameState.playerShip.movesLeft}/${CONSTS.MOVE_POINTS_PER_TURN}` : '-/-'; addToLog(`--- Starting Turn ${gameState.turnCount}. Player MP: ${playerMPStr} ---`, "System"); processEventPhase(); }

      /* ========================================================== TACTICAL COMBAT ========================================================== */
      function initCombatBoard(attackerEntity, defenderEntity, context) { const board = Array(CONSTS.COMBAT_GRID_DIM).fill(null).map(() => Array(CONSTS.COMBAT_GRID_DIM).fill(null).map(() => ({ terrain: 'Open' }))); const units = []; const combatantsOriginalData = []; const attackerStartY = Math.floor(CONSTS.COMBAT_GRID_DIM / 2) + CONSTS.COMBAT_UNIT_START_Y_OFFSET_FROM_CENTER; const defenderStartY = attackerStartY; units.push({ id: `combatUnit_${attackerEntity.id}`, originalId: attackerEntity.id, originalType: 'SHIP', faction: attackerEntity.faction, hp: CONSTS.COMBAT_DEFAULT_UNIT_HP, x: CONSTS.COMBAT_ATTACKER_START_X_OFFSET, y: attackerStartY, }); combatantsOriginalData.push({ id: attackerEntity.id, type: 'SHIP', q: attackerEntity.q, r: attackerEntity.r, faction: attackerEntity.faction }); const defenderOriginalQ = context === CONSTS.COMBAT_CONTEXT_SHIP_VS_COLONY ? defenderEntity.q : defenderEntity.q; const defenderOriginalR = context === CONSTS.COMBAT_CONTEXT_SHIP_VS_COLONY ? defenderEntity.r : defenderEntity.r; if (context === CONSTS.COMBAT_CONTEXT_SHIP_VS_COLONY) { const colony = defenderEntity.colony; units.push({ id: `combatUnit_colony_${colony.name.replace(/\s+/g, '_')}`, originalId: colony.name, originalType: 'COLONY', faction: colony.faction, hp: CONSTS.COMBAT_DEFAULT_COLONY_HP, x: CONSTS.COMBAT_GRID_DIM - CONSTS.COMBAT_DEFENDER_START_X_OFFSET_FROM_EDGE, y: defenderStartY, }); combatantsOriginalData.push({ id: colony.name, type: 'COLONY', q: defenderOriginalQ, r: defenderOriginalR, faction: colony.faction }); } else { units.push({ id: `combatUnit_${defenderEntity.id}`, originalId: defenderEntity.id, originalType: 'SHIP', faction: defenderEntity.faction, hp: CONSTS.COMBAT_DEFAULT_UNIT_HP, x: CONSTS.COMBAT_GRID_DIM - CONSTS.COMBAT_DEFENDER_START_X_OFFSET_FROM_EDGE, y: defenderStartY, }); combatantsOriginalData.push({ id: defenderEntity.id, type: 'SHIP', q: defenderOriginalQ, r: defenderOriginalR, faction: defenderEntity.faction }); } let turnFaction; let activeUnitIdxLocal; const playerIsAttacker = attackerEntity.faction === CONSTS.FACTION_PLAYER; const defenderFaction = units[1].faction; const playerIsDefender = defenderFaction === CONSTS.FACTION_PLAYER; if (playerIsAttacker || playerIsDefender) { turnFaction = CONSTS.FACTION_PLAYER; activeUnitIdxLocal = playerIsAttacker ? 0 : 1; } else { turnFaction = attackerEntity.faction; activeUnitIdxLocal = 0; } return { board, units, round: 1, turn: turnFaction, context, combatantsOriginalData, awaitingMoveClick: false, activeUnitIndex: activeUnitIdxLocal, gridStartX: (width - CONSTS.COMBAT_GRID_DIM * CONSTS.COMBAT_CELL_PIXEL_SIZE) / 2, gridStartY: (height - CONSTS.COMBAT_GRID_DIM * CONSTS.COMBAT_CELL_PIXEL_SIZE) / 2, }; }
      function enterCombat(attackerEntity, defenderEntity, context) { if (gameState.combat) return; addToLog(`Entering Combat! Context: ${context}`, "Combat"); gameState.combat = initCombatBoard(attackerEntity, defenderEntity, context); select('#uiContainer').elt.style.display = 'none'; select('#logPanelContainer').elt.style.display = 'none'; select('#endTurnBtn').elt.style.display = 'none'; menuOpen = false; combatUiContainer.style('display', 'flex'); updateCombatUi(); if (gameState.combat.turn === CONSTS.FACTION_AI) { setTimeout(runCombatAITurn, CONSTS.COMBAT_UI_AI_THINKING_DELAY_MS); } }
      function endCombat(outcome, winningFaction) { if (!gameState.combat) return; addToLog(`Combat Ended. Outcome: ${outcome}, Winner: ${winningFaction || 'None'}`, "Combat"); const combatData = gameState.combat; combatData.units.forEach(unit => { const originalData = combatData.combatantsOriginalData.find(co => co.id === unit.originalId && co.type === unit.originalType); if (!originalData) { console.error("Could not find original data for combat unit:", unit); return; } if (unit.hp <= 0) { addToLog(`${unit.faction} ${unit.originalType} '${unit.originalId}' destroyed!`, "Combat"); if (unit.originalType === 'SHIP') { if (gameState.playerShip && gameState.playerShip.id === unit.originalId) { gameState.playerShip = null; addToLog("Player ship lost!", "System"); } else { gameState.aiShips = gameState.aiShips.filter(s => s.id !== unit.originalId); } } else if (unit.originalType === 'COLONY') { const colonyHexIndex = axialToIndex(originalData.q, originalData.r); const colonyHex = hexes[colonyHexIndex]; if (colonyHex && colonyHex.colony) { if (colonyHex.colony.faction === CONSTS.FACTION_PLAYER && gameState.playerColonyIndices) { const indexToRemove = gameState.playerColonyIndices.indexOf(colonyHexIndex); if (indexToRemove > -1) { gameState.playerColonyIndices.splice(indexToRemove, 1); addToLog(`Player colony at (${originalData.q},${originalData.r}) removed from playerColonyIndices.`, "System"); } } colonyHex.colony = null; addToLog(`Colony at (${originalData.q},${originalData.r}) destroyed!`, "System"); } } } else { if (unit.originalType === 'SHIP') { let shipToUpdate = (gameState.playerShip && gameState.playerShip.id === unit.originalId) ? gameState.playerShip : gameState.aiShips.find(s => s.id === unit.originalId); if (shipToUpdate) { shipToUpdate.q = originalData.q; shipToUpdate.r = originalData.r; shipToUpdate.movesLeft = 0; addToLog(`${unit.faction} Ship ${unit.originalId} returns to (${originalData.q},${originalData.r}), MP set to 0.`, "Combat"); } } } }); gameState.combat = null; select('#uiContainer').elt.style.display = 'flex'; select('#logPanelContainer').elt.style.display = 'block'; select('#endTurnBtn').elt.style.display = 'block'; combatUiContainer.style('display', 'none'); updateVisibility(); if (gameState.playerShip) { reachableSet = computeReachable(gameState.playerShip.q, gameState.playerShip.r, gameState.playerShip.movesLeft); } else { reachableSet.clear(); visibleReachableSet.clear(); } if (gameState.isTurnProcessingPausedForCombat && gameState.postCombatTurnResumeCallback) { gameState.postCombatTurnResumeCallback(); } else { select('#endTurnBtn').elt.disabled = isEventModalOpen || (gameState.playerShip && gameState.playerOrderQueue.length === 0); } }
      function drawCombat() { background(50); if (!gameState.combat) return; const { board, units, gridStartX, gridStartY } = gameState.combat; for (let r = 0; r < CONSTS.COMBAT_GRID_DIM; r++) { for (let c = 0; c < CONSTS.COMBAT_GRID_DIM; c++) { const x = gridStartX + c * CONSTS.COMBAT_CELL_PIXEL_SIZE; const y = gridStartY + r * CONSTS.COMBAT_CELL_PIXEL_SIZE; stroke(100); fill(board[r][c].terrain === 'Open' ? 120 : 80); rect(x, y, CONSTS.COMBAT_CELL_PIXEL_SIZE, CONSTS.COMBAT_CELL_PIXEL_SIZE); } } units.forEach(unit => { if (unit.hp <= 0) return; const unitCenterX = gridStartX + unit.x * CONSTS.COMBAT_CELL_PIXEL_SIZE + CONSTS.COMBAT_CELL_PIXEL_SIZE / 2; const unitCenterY = gridStartY + unit.y * CONSTS.COMBAT_CELL_PIXEL_SIZE + CONSTS.COMBAT_CELL_PIXEL_SIZE / 2; const unitSize = CONSTS.COMBAT_CELL_PIXEL_SIZE * 0.4; push(); translate(unitCenterX, unitCenterY); fill(unit.faction === CONSTS.FACTION_PLAYER ? CONSTS.PLAYER_COLOUR : CONSTS.AI_COLOUR); noStroke(); if (unit.originalType === 'SHIP') { triangle(0, -unitSize, unitSize * 0.8, unitSize * 0.6, -unitSize * 0.8, unitSize * 0.6); } else { rectMode(CENTER); rect(0,0, unitSize * 1.5, unitSize * 1.5); } fill(255,0,0); for (let i = 0; i < unit.hp; i++) { ellipse(-unitSize * 0.5 + i * (unitSize * 0.4), unitSize * 1.2, unitSize*0.3, unitSize*0.3); } pop(); }); if (gameState.combat.awaitingMoveClick) { const activeUnit = gameState.combat.units[gameState.combat.activeUnitIndex]; if (activeUnit.faction === CONSTS.FACTION_PLAYER) { const validMoves = getValidCombatMoves(activeUnit); validMoves.forEach(move => { fill(0, 255, 0, 100); rect(gridStartX + move.x * CONSTS.COMBAT_CELL_PIXEL_SIZE, gridStartY + move.y * CONSTS.COMBAT_CELL_PIXEL_SIZE, CONSTS.COMBAT_CELL_PIXEL_SIZE, CONSTS.COMBAT_CELL_PIXEL_SIZE); }); } } }
      function updateCombatUi() { if (!gameState.combat) return; combatRoundBanner.html(`Round ${gameState.combat.round} / ${CONSTS.COMBAT_MAX_ROUNDS}`); if (gameState.combat.turn === CONSTS.FACTION_PLAYER) { combatActionButtonsDiv.style('display', 'block'); enableCombatActions(); } else { combatActionButtonsDiv.style('display', 'none'); disableCombatActions(); } }
      function enableCombatActions() { if (!gameState.combat || gameState.combat.turn !== CONSTS.FACTION_PLAYER) return; combatAttackBtn.removeAttribute('disabled'); combatMoveBtn.removeAttribute('disabled'); combatRetreatBtn.removeAttribute('disabled'); }
      function disableCombatActions() { combatAttackBtn.attribute('disabled', true); combatMoveBtn.attribute('disabled', true); combatRetreatBtn.attribute('disabled', true); if (gameState.combat) gameState.combat.awaitingMoveClick = false; }
      function getValidCombatMoves(unit) { const moves = []; const directions = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}]; directions.forEach(dir => { const nextX = unit.x + dir.x; const nextY = unit.y + dir.y; if (nextX >= 0 && nextX < CONSTS.COMBAT_GRID_DIM && nextY >= 0 && nextY < CONSTS.COMBAT_GRID_DIM) { const isOccupied = gameState.combat.units.some(u => u.hp > 0 && u.x === nextX && u.y === nextY); if (!isOccupied) { moves.push({x: nextX, y: nextY}); } } }); return moves; }
      function handleCombatMousePressed() { if (!gameState.combat || !gameState.combat.awaitingMoveClick || gameState.combat.turn !== CONSTS.FACTION_PLAYER) return; const { gridStartX, gridStartY, units, activeUnitIndex } = gameState.combat; const c = Math.floor((mouseX - gridStartX) / CONSTS.COMBAT_CELL_PIXEL_SIZE); const r = Math.floor((mouseY - gridStartY) / CONSTS.COMBAT_CELL_PIXEL_SIZE); const activeUnit = units[activeUnitIndex]; const validMoves = getValidCombatMoves(activeUnit); const isValidMove = validMoves.some(move => move.x === c && move.y === r); if (isValidMove) { addToLog(`Player ${activeUnit.originalType} ${activeUnit.originalId} moves to (${c}, ${r})`, "Combat"); activeUnit.x = c; activeUnit.y = r; gameState.combat.awaitingMoveClick = false; advanceCombatTurn(); } else { addToLog("Invalid move selected.", "Combat"); } }
      function handleCombatPlayerAction(action) { if (!gameState.combat || gameState.combat.turn !== CONSTS.FACTION_PLAYER) return; const combat = gameState.combat; const playerUnit = combat.units[combat.activeUnitIndex]; const aiUnit = combat.units.find(u => u.faction === CONSTS.FACTION_AI && u.hp > 0); disableCombatActions(); switch(action) { case 'ATTACK': if (aiUnit) { attemptCombatAttack(playerUnit, aiUnit); } else { addToLog("No AI unit to attack.", "Combat"); enableCombatActions(); } break; case 'MOVE': combat.awaitingMoveClick = true; addToLog("Select a cell to move to.", "Combat"); enableCombatActions(); combatMoveBtn.attribute('disabled', true); break; case 'RETREAT': addToLog(`Player ${playerUnit.originalType} ${playerUnit.originalId} retreats!`, "Combat"); endCombat(CONSTS.COMBAT_OUTCOME_PLAYER_DEFEAT, CONSTS.FACTION_AI); break; } }
      function attemptCombatAttack(attacker, defender) { if (!attacker || !defender || attacker.hp <= 0 || defender.hp <= 0) { advanceCombatTurn(); return; } addToLog(`${attacker.faction} ${attacker.originalType} '${attacker.originalId}' attacks ${defender.faction} ${defender.originalType} '${defender.originalId}'!`, "Combat"); const roll = Math.floor(random(1, 7)); if (roll >= CONSTS.COMBAT_ATTACK_HIT_ROLL_THRESHOLD) { defender.hp--; addToLog(`Hit! (Rolled ${roll}). ${defender.originalType} HP: ${defender.hp}`, "Combat"); } else { addToLog(`Miss! (Rolled ${roll})`, "Combat"); } advanceCombatTurn(); }
      function runCombatAITurn() { if (!gameState.combat || gameState.combat.turn !== CONSTS.FACTION_AI) return; const combat = gameState.combat; const aiUnit = combat.units[combat.activeUnitIndex]; const playerUnit = combat.units.find(u => u.faction === CONSTS.FACTION_PLAYER && u.hp > 0); if (!aiUnit || aiUnit.hp <=0 || !playerUnit) { advanceCombatTurn(); return; } if (aiUnit.hp <= CONSTS.COMBAT_AI_RETREAT_HP_THRESHOLD && CONSTS.COMBAT_DEFAULT_UNIT_HP > 1 && random() < CONSTS.COMBAT_AI_RETREAT_CHANCE) { addToLog(`AI ${aiUnit.originalType} ${aiUnit.originalId} retreats!`, "Combat"); endCombat(CONSTS.COMBAT_OUTCOME_PLAYER_VICTORY, CONSTS.FACTION_PLAYER); } else { attemptCombatAttack(aiUnit, playerUnit); } }
      function advanceCombatTurn() { if (!gameState.combat) return; if (checkCombatEndConditions()) return; const combat = gameState.combat; const oldTurnFaction = combat.units[combat.activeUnitIndex].faction; combat.activeUnitIndex = (combat.activeUnitIndex + 1) % combat.units.length; while(combat.units[combat.activeUnitIndex].hp <= 0) { combat.activeUnitIndex = (combat.activeUnitIndex + 1) % combat.units.length; } const newTurnFaction = combat.units[combat.activeUnitIndex].faction; combat.turn = newTurnFaction; if (newTurnFaction === CONSTS.FACTION_PLAYER && oldTurnFaction === CONSTS.FACTION_AI) { combat.round++; addToLog(`Starting Round ${combat.round}`, "Combat"); if (checkCombatEndConditions()) return; } updateCombatUi(); if (combat.turn === CONSTS.FACTION_AI) { setTimeout(runCombatAITurn, CONSTS.COMBAT_AI_TURN_DELAY_MS); } else { addToLog("Player's turn.", "Combat"); } }
      function checkCombatEndConditions() { if (!gameState.combat) return false; const { units, round } = gameState.combat; const livingPlayerUnits = units.filter(u => u.faction === CONSTS.FACTION_PLAYER && u.hp > 0); const livingAiUnits = units.filter(u => u.faction === CONSTS.FACTION_AI && u.hp > 0); if (livingPlayerUnits.length === 0) { endCombat(CONSTS.COMBAT_OUTCOME_PLAYER_DEFEAT, CONSTS.FACTION_AI); return true; } if (livingAiUnits.length === 0) { endCombat(CONSTS.COMBAT_OUTCOME_PLAYER_VICTORY, CONSTS.FACTION_PLAYER); return true; } if (round > CONSTS.COMBAT_MAX_ROUNDS) { addToLog("Combat reached max rounds. It's a draw!", "Combat"); endCombat(CONSTS.COMBAT_OUTCOME_DRAW_MAX_ROUNDS, null); return true; } return false; }
      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        if (gameState) { // Ensure gameState is initialized
            gameState.gridOffsetX = width / 2 - (CONSTS.GRID_W / 2 * CONSTS.HEX_SIZE * CONSTS.HEX_WIDTH_FACTOR);
            gameState.gridOffsetY = height / 2 - (CONSTS.GRID_H / 2 * CONSTS.HEX_SIZE * CONSTS.SQRT3);
        }
        if (gameState.combat) {
          gameState.combat.gridStartX = (width - CONSTS.COMBAT_GRID_DIM * CONSTS.COMBAT_CELL_PIXEL_SIZE) / 2;
          gameState.combat.gridStartY = (height - CONSTS.COMBAT_GRID_DIM * CONSTS.COMBAT_CELL_PIXEL_SIZE) / 2;
        }
      }
    </script>
  </body>
</html>
