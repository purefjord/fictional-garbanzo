<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2D Minecraft - Side Scroller</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #87CEEB;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
        }
        #gameCanvas {
            display: block;
            cursor: crosshair;
        }
        #ui { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 4px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 8px; border: 2px solid #555; }
        .slot { width: 50px; height: 50px; background: rgba(139,139,139,0.8); border: 2px solid #373737; border-radius: 4px; display: flex; align-items: center; justify-content: center; position: relative; cursor: pointer; }
        .slot.selected { border-color: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
        .slot-count { position: absolute; bottom: 2px; right: 4px; color: white; font-size: 12px; font-weight: bold; text-shadow: 1px 1px 2px black; }
        .slot-key { position: absolute; top: 2px; left: 4px; color: #aaa; font-size: 10px; }
        .panel { position: absolute; color: white; text-shadow: 1px 1px 2px black; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; }
        #info { top: 10px; left: 10px; font-size: 14px; }
        #controls { top: 10px; right: 10px; font-size: 12px; max-width: 200px; }
        #miningProgress { position: absolute; width: 40px; height: 6px; background: rgba(0,0,0,0.5); border-radius: 3px; display: none; }
        #miningProgress .fill { height: 100%; background: #4CAF50; border-radius: 3px; transition: width 0.05s; }

        /* Mobile Touch Controls */
        #touchControls { display: none; position: fixed; bottom: 0; left: 0; right: 0; pointer-events: none; z-index: 100; }
        .touch-visible #touchControls { display: block; }
        .touch-visible #controls { display: none; }
        .touch-visible #ui { bottom: 140px; }
        .touch-btn { position: absolute; width: 60px; height: 60px; background: rgba(255,255,255,0.25); border: 3px solid rgba(255,255,255,0.4); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; color: white; text-shadow: 1px 1px 3px black; pointer-events: all; user-select: none; -webkit-user-select: none; touch-action: none; transition: background 0.1s, transform 0.1s; }
        .touch-btn:active, .touch-btn.active { background: rgba(255,255,255,0.5); transform: scale(0.95); }
        .touch-btn.left-btn { bottom: 20px; left: 20px; }
        .touch-btn.right-btn { bottom: 20px; left: 100px; }
        .touch-btn.jump-btn { bottom: 20px; right: 20px; }
        .touch-btn.mode-btn { bottom: 100px; right: 20px; width: 50px; height: 50px; font-size: 20px; }
        .touch-btn.mode-btn.place-mode { background: rgba(100,200,100,0.4); border-color: rgba(100,255,100,0.6); }
        #modeLabel { position: absolute; bottom: 160px; right: 15px; color: white; font-size: 12px; text-shadow: 1px 1px 2px black; text-align: center; width: 60px; pointer-events: none; }
        #touchCrosshair { position: absolute; width: 40px; height: 40px; border: 2px solid rgba(255,255,255,0.7); border-radius: 4px; pointer-events: none; display: none; z-index: 50; }
        #touchCrosshair::before { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 6px; height: 6px; background: rgba(255,255,255,0.9); border-radius: 50%; }
        .touch-visible #touchCrosshair { display: block; }
        .touch-visible .slot { width: 40px; height: 40px; }
        .touch-visible .slot-key { display: none; }
        .touch-visible #info { font-size: 12px; padding: 6px; }
        #saveNotification { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: #4CAF50; padding: 15px 30px; border-radius: 8px; font-size: 18px; font-weight: bold; z-index: 1000; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        #saveNotification.show { opacity: 1; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui"></div>
    <div id="info" class="panel">
        <div>FPS: <span id="fps">0</span></div>
        <div>Position: <span id="position">0, 0</span></div>
        <div>Time: <span id="timeDisplay">Day</span></div>
    </div>
    <div id="controls" class="panel">
        <strong>Controls:</strong><br>
        WASD / Arrows - Move<br>
        Space - Jump<br>
        Left Click - Break block<br>
        Right Click - Place block<br>
        1-9 - Select hotbar<br>
        Scroll - Change slot<br>
        P - Save game<br>
        N - New game
    </div>
    <div id="miningProgress"><div class="fill"></div></div>
    <div id="saveNotification">Game Saved</div>

    <!-- Mobile Touch Controls -->
    <div id="touchControls">
        <div id="touchCrosshair"></div>
        <div class="touch-btn left-btn" data-action="left">&#9664;</div>
        <div class="touch-btn right-btn" data-action="right">&#9654;</div>
        <div class="touch-btn jump-btn" data-action="jump">&#9650;</div>
        <div class="touch-btn mode-btn" data-action="mode">&#9935;</div>
        <div id="modeLabel">Mine</div>
    </div>

    <script>
    // ============================================
    // 2D MINECRAFT SIDE-SCROLLER
    // Single HTML file implementation
    // ============================================

    // --- CONFIGURATION ---
    const CONFIG = {
        BLOCK_SIZE: 32,
        WORLD_WIDTH: 512,      // blocks
        WORLD_HEIGHT: 256,     // blocks
        SURFACE_HEIGHT: 180,   // base surface level
        GRAVITY: 0.5,
        JUMP_FORCE: 10,
        MOVE_SPEED: 5,
        PLAYER_WIDTH: 0.6,     // in blocks
        PLAYER_HEIGHT: 1.8,    // in blocks
        REACH_DISTANCE: 5,     // blocks
        DAY_LENGTH: 600,       // seconds for full day cycle
    };

    // --- BLOCK TYPES ---
    const BLOCKS = {
        AIR: { id: 0, name: 'Air', solid: false, transparent: true },
        GRASS: { id: 1, name: 'Grass', solid: true, hardness: 0.6, drops: 'DIRT' },
        DIRT: { id: 2, name: 'Dirt', solid: true, hardness: 0.5 },
        STONE: { id: 3, name: 'Stone', solid: true, hardness: 1.5, drops: 'COBBLESTONE' },
        COBBLESTONE: { id: 4, name: 'Cobblestone', solid: true, hardness: 2 },
        WOOD: { id: 5, name: 'Wood', solid: true, hardness: 2 },
        LEAVES: { id: 6, name: 'Leaves', solid: true, hardness: 0.2, transparent: true },
        SAND: { id: 7, name: 'Sand', solid: true, hardness: 0.5 },
        WATER: { id: 8, name: 'Water', solid: false, transparent: true },
        COAL_ORE: { id: 9, name: 'Coal Ore', solid: true, hardness: 3 },
        IRON_ORE: { id: 10, name: 'Iron Ore', solid: true, hardness: 3 },
        GOLD_ORE: { id: 11, name: 'Gold Ore', solid: true, hardness: 3 },
        DIAMOND_ORE: { id: 12, name: 'Diamond Ore', solid: true, hardness: 3 },
        BEDROCK: { id: 13, name: 'Bedrock', solid: true, hardness: Infinity },
        PLANKS: { id: 14, name: 'Planks', solid: true, hardness: 2 },
        GLASS: { id: 15, name: 'Glass', solid: true, hardness: 0.3, transparent: true },
        SNOW_GRASS: { id: 16, name: 'Snow Grass', solid: true, hardness: 0.6, drops: 'DIRT' },
        CACTUS: { id: 17, name: 'Cactus', solid: true, hardness: 0.4 },
        SNOW_LEAVES: { id: 18, name: 'Snow Leaves', solid: true, hardness: 0.2, transparent: true },
    };

    // Biome definitions
    const BIOMES = {
        FOREST: { id: 0, surfaceBlock: 'GRASS', treeChance: 0.6, treeDensity: 8 },
        PLAINS: { id: 1, surfaceBlock: 'GRASS', treeChance: 0.2, treeDensity: 15 },
        DESERT: { id: 2, surfaceBlock: 'SAND', treeChance: 0.15, treeDensity: 12, cactus: true },
        SNOW: { id: 3, surfaceBlock: 'SNOW_GRASS', treeChance: 0.4, treeDensity: 10, snowyTrees: true },
    };

    // Create ID to block mapping
    const BLOCK_BY_ID = {};
    for (const [key, block] of Object.entries(BLOCKS)) {
        block.key = key;
        BLOCK_BY_ID[block.id] = block;
    }

    // --- SIMPLEX NOISE IMPLEMENTATION ---
    class SimplexNoise {
        constructor(seed = Math.random() * 10000) {
            this.p = new Uint8Array(512);
            const perm = new Uint8Array(256);
            for (let i = 0; i < 256; i++) perm[i] = i;

            // Seed-based shuffle
            let s = seed;
            for (let i = 255; i > 0; i--) {
                s = (s * 16807) % 2147483647;
                const j = s % (i + 1);
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }

            for (let i = 0; i < 512; i++) this.p[i] = perm[i & 255];
        }

        noise2D(x, y) {
            const F2 = 0.5 * (Math.sqrt(3) - 1);
            const G2 = (3 - Math.sqrt(3)) / 6;

            const s = (x + y) * F2;
            const i = Math.floor(x + s);
            const j = Math.floor(y + s);

            const t = (i + j) * G2;
            const X0 = i - t;
            const Y0 = j - t;
            const x0 = x - X0;
            const y0 = y - Y0;

            const [i1, j1] = x0 > y0 ? [1, 0] : [0, 1];

            const x1 = x0 - i1 + G2;
            const y1 = y0 - j1 + G2;
            const x2 = x0 - 1 + 2 * G2;
            const y2 = y0 - 1 + 2 * G2;

            const ii = i & 255;
            const jj = j & 255;

            const grad = (hash, x, y) => {
                const h = hash & 7;
                const u = h < 4 ? x : y;
                const v = h < 4 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
            };

            let n0 = 0, n1 = 0, n2 = 0;

            let t0 = 0.5 - x0*x0 - y0*y0;
            if (t0 >= 0) {
                t0 *= t0;
                n0 = t0 * t0 * grad(this.p[ii + this.p[jj]], x0, y0);
            }

            let t1 = 0.5 - x1*x1 - y1*y1;
            if (t1 >= 0) {
                t1 *= t1;
                n1 = t1 * t1 * grad(this.p[ii + i1 + this.p[jj + j1]], x1, y1);
            }

            let t2 = 0.5 - x2*x2 - y2*y2;
            if (t2 >= 0) {
                t2 *= t2;
                n2 = t2 * t2 * grad(this.p[ii + 1 + this.p[jj + 1]], x2, y2);
            }

            return 70 * (n0 + n1 + n2);
        }

        octaveNoise(x, y, octaves, persistence = 0.5) {
            let total = 0;
            let frequency = 1;
            let amplitude = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                total += this.noise2D(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }

            return total / maxValue;
        }
    }

    // --- TEXTURE GENERATOR ---
    const TextureGenerator = {
        cache: {},

        createTexture(blockType, size = CONFIG.BLOCK_SIZE) {
            const cacheKey = `${blockType}_${size}`;
            if (this.cache[cacheKey]) return this.cache[cacheKey];

            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            switch(blockType) {
                case 'GRASS':
                    this.drawGrass(ctx, size);
                    break;
                case 'DIRT':
                    this.drawDirt(ctx, size);
                    break;
                case 'STONE':
                    this.drawStone(ctx, size);
                    break;
                case 'COBBLESTONE':
                    this.drawCobblestone(ctx, size);
                    break;
                case 'WOOD':
                    this.drawWood(ctx, size);
                    break;
                case 'LEAVES':
                    this.drawLeaves(ctx, size);
                    break;
                case 'SAND':
                    this.drawSand(ctx, size);
                    break;
                case 'WATER':
                    this.drawWater(ctx, size);
                    break;
                case 'COAL_ORE':
                    this.drawOre(ctx, size, '#333');
                    break;
                case 'IRON_ORE':
                    this.drawOre(ctx, size, '#d4a574');
                    break;
                case 'GOLD_ORE':
                    this.drawOre(ctx, size, '#ffd700');
                    break;
                case 'DIAMOND_ORE':
                    this.drawOre(ctx, size, '#00ffff');
                    break;
                case 'BEDROCK':
                    this.drawBedrock(ctx, size);
                    break;
                case 'PLANKS':
                    this.drawPlanks(ctx, size);
                    break;
                case 'GLASS':
                    this.drawGlass(ctx, size);
                    break;
                case 'SNOW_GRASS':
                    this.drawSnowGrass(ctx, size);
                    break;
                case 'CACTUS':
                    this.drawCactus(ctx, size);
                    break;
                case 'SNOW_LEAVES':
                    this.drawSnowLeaves(ctx, size);
                    break;
                default:
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(0, 0, size, size);
            }

            this.cache[cacheKey] = canvas;
            return canvas;
        },

        drawGrass(ctx, size) {
            // Dirt base
            ctx.fillStyle = '#8B5A2B';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#6B4226', 0.3);

            // Green top
            const gradient = ctx.createLinearGradient(0, 0, 0, size * 0.4);
            gradient.addColorStop(0, '#5d8c32');
            gradient.addColorStop(1, '#4a7029');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size * 0.35);

            // Grass blades
            ctx.strokeStyle = '#7cb342';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * size;
                ctx.beginPath();
                ctx.moveTo(x, size * 0.35);
                ctx.lineTo(x + (Math.random() - 0.5) * 4, 0);
                ctx.stroke();
            }
        },

        drawDirt(ctx, size) {
            this.drawNoiseTexture(ctx, size, '#8B5A2B', ['#6B4226', '#9B6A3B'], [0.4, 0.2]);
            this.drawSpots(ctx, size, '#5a4020', 4, 2);
        },

        drawStone(ctx, size) {
            this.drawNoiseTexture(ctx, size, '#808080', ['#666666', '#999999'], [0.3, 0.2]);
            this.drawCracks(ctx, size, '#555', 2);
        },

        drawCobblestone(ctx, size) {
            ctx.fillStyle = '#6a6a6a';
            ctx.fillRect(0, 0, size, size);
            [[0, 0, 0.5, 0.45], [0.5, 0, 0.5, 0.5], [0, 0.45, 0.6, 0.55], [0.55, 0.5, 0.45, 0.5]].forEach(([x, y, w, h], i) => {
                ctx.fillStyle = i % 2 ? '#7a7a7a' : '#5a5a5a';
                ctx.fillRect(x * size + 1, y * size + 1, w * size - 2, h * size - 2);
            });
        },

        drawWood(ctx, size) {
            ctx.fillStyle = '#6B4423';
            ctx.fillRect(0, 0, size, size);
            ctx.strokeStyle = '#4a3020';
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) { const x = i * size / 4 + Math.random() * 4; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x + (Math.random() - 0.5) * 4, size); ctx.stroke(); }
            ctx.fillStyle = '#5a3818';
            ctx.beginPath();
            ctx.ellipse(size/2, size/2, size*0.3, size*0.35, 0, 0, Math.PI * 2);
            ctx.fill();
        },

        drawLeaves(ctx, size) {
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 0, size, size);
            for (let i = 0; i < 15; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#32CD32' : '#1e7b1e';
                ctx.beginPath();
                ctx.arc(Math.random() * size, Math.random() * size, 2 + Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }
        },

        drawSand(ctx, size) {
            this.drawNoiseTexture(ctx, size, '#e6d59e', ['#d4c48a', '#c4b47a'], [0.3, 0.2]);
        },

        drawWater(ctx, size) {
            const gradient = ctx.createLinearGradient(0, 0, size, size);
            gradient.addColorStop(0, 'rgba(30, 144, 255, 0.7)');
            gradient.addColorStop(1, 'rgba(0, 100, 180, 0.7)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 3; i++) { ctx.beginPath(); ctx.moveTo(0, size * 0.3 * i); ctx.quadraticCurveTo(size/2, size * 0.3 * i - 5, size, size * 0.3 * i); ctx.stroke(); }
        },

        drawOre(ctx, size, oreColor) {
            this.drawStone(ctx, size);
            ctx.fillStyle = oreColor;
            for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
                const x = 4 + Math.random() * (size - 8), y = 4 + Math.random() * (size - 8), s = 3 + Math.random() * 4;
                ctx.beginPath(); ctx.moveTo(x, y - s); ctx.lineTo(x + s, y); ctx.lineTo(x, y + s); ctx.lineTo(x - s, y); ctx.closePath(); ctx.fill();
            }
        },

        drawBedrock(ctx, size) {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, size, size);
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#333' : '#0a0a0a';
                ctx.fillRect(Math.random() * size, Math.random() * size, 3 + Math.random() * 6, 3 + Math.random() * 6);
            }
        },

        drawPlanks(ctx, size) {
            ctx.fillStyle = '#ba8c51';
            ctx.fillRect(0, 0, size, size);
            ctx.strokeStyle = '#8a5c31';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) { ctx.beginPath(); ctx.moveTo(0, i * size / 4 + size / 8); ctx.lineTo(size, i * size / 4 + size / 8); ctx.stroke(); }
            ctx.strokeStyle = 'rgba(100, 60, 20, 0.3)';
            for (let i = 0; i < 8; i++) { ctx.beginPath(); ctx.moveTo(Math.random() * size, 0); ctx.lineTo(Math.random() * size, size); ctx.stroke(); }
        },

        drawGlass(ctx, size) {
            ctx.fillStyle = 'rgba(200, 230, 255, 0.4)';
            ctx.fillRect(0, 0, size, size);
            ctx.strokeStyle = 'rgba(180, 210, 235, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, size - 2, size - 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(2, 2);
            ctx.lineTo(size * 0.4, 2);
            ctx.lineTo(2, size * 0.4);
            ctx.closePath();
            ctx.fill();
        },

        drawSnowGrass(ctx, size) {
            ctx.fillStyle = '#8B5A2B';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#6B4226', 0.3);
            // Snow top
            const gradient = ctx.createLinearGradient(0, 0, 0, size * 0.4);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(1, '#e8e8f0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size * 0.35);
            // Snow sparkles
            ctx.fillStyle = 'rgba(200, 220, 255, 0.8)';
            for (let i = 0; i < 5; i++) ctx.fillRect(Math.random() * size, Math.random() * size * 0.3, 1, 1);
        },

        drawCactus(ctx, size) {
            ctx.fillStyle = '#2d5a27';
            ctx.fillRect(size * 0.2, 0, size * 0.6, size);
            ctx.fillStyle = '#3d7a37';
            ctx.fillRect(size * 0.25, 0, size * 0.1, size);
            // Spines
            ctx.strokeStyle = '#1a3a17';
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                const y = size * 0.1 + i * size * 0.15;
                ctx.beginPath(); ctx.moveTo(size * 0.2, y); ctx.lineTo(size * 0.1, y - 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(size * 0.8, y); ctx.lineTo(size * 0.9, y - 2); ctx.stroke();
            }
        },

        drawSnowLeaves(ctx, size) {
            ctx.fillStyle = '#1a5a1a';
            ctx.fillRect(0, 0, size, size);
            for (let i = 0; i < 12; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#2a7a2a' : '#104010';
                ctx.beginPath();
                ctx.arc(Math.random() * size, Math.random() * size, 2 + Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            // Snow patches
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            for (let i = 0; i < 8; i++) ctx.fillRect(Math.random() * size, Math.random() * size, 2 + Math.random() * 3, 2);
        },

        addNoise(ctx, size, color, intensity) {
            ctx.fillStyle = color;
            for (let i = 0; i < size * size * intensity; i++) {
                ctx.fillRect(Math.floor(Math.random() * size), Math.floor(Math.random() * size), 1, 1);
            }
        },

        drawNoiseTexture(ctx, size, base, colors, intensities) {
            ctx.fillStyle = base;
            ctx.fillRect(0, 0, size, size);
            colors.forEach((c, i) => this.addNoise(ctx, size, c, intensities[i]));
        },

        drawSpots(ctx, size, color, count, maxRadius) {
            ctx.fillStyle = color;
            for (let i = 0; i < count; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * size, Math.random() * size, 1 + Math.random() * maxRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        },

        drawCracks(ctx, size, color, count) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            for (let i = 0; i < count; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * size, Math.random() * size);
                ctx.lineTo(Math.random() * size, Math.random() * size);
                ctx.stroke();
            }
        }
    };

    // --- WORLD GENERATION ---
    class World {
        constructor(width, height, seed) {
            this.width = width;
            this.height = height;
            this.seed = seed || Math.random() * 10000;
            this.noise = new SimplexNoise(this.seed);
            this.caveNoise = new SimplexNoise(this.seed + 1000);
            this.oreNoise = new SimplexNoise(this.seed + 2000);
            this.biomeNoise = new SimplexNoise(this.seed + 3000);

            // Chunk-based loading
            this.chunkSize = 16;
            this.chunks = new Map();
            this.modifiedBlocks = new Map(); // Track player modifications
        }

        getBiome(x) {
            const biomeValue = this.biomeNoise.noise2D(x * 0.005, 0);
            if (biomeValue < -0.3) return BIOMES.SNOW;
            if (biomeValue < 0.1) return BIOMES.FOREST;
            if (biomeValue < 0.4) return BIOMES.PLAINS;
            return BIOMES.DESERT;
        }

        getChunkKey(cx, cy) {
            return `${cx},${cy}`;
        }

        getBlock(x, y) {
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
                return BLOCKS.AIR;
            }

            // Check for player modifications first
            const modKey = `${x},${y}`;
            if (this.modifiedBlocks.has(modKey)) {
                return BLOCK_BY_ID[this.modifiedBlocks.get(modKey)];
            }

            // Generate if needed
            const cx = Math.floor(x / this.chunkSize);
            const cy = Math.floor(y / this.chunkSize);
            const chunkKey = this.getChunkKey(cx, cy);

            if (!this.chunks.has(chunkKey)) {
                this.generateChunk(cx, cy);
            }

            const chunk = this.chunks.get(chunkKey);
            const lx = x - cx * this.chunkSize;
            const ly = y - cy * this.chunkSize;

            return BLOCK_BY_ID[chunk[ly * this.chunkSize + lx]] || BLOCKS.AIR;
        }

        setBlock(x, y, blockType) {
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;

            const modKey = `${x},${y}`;
            this.modifiedBlocks.set(modKey, blockType.id);
        }

        generateChunk(cx, cy) {
            const chunk = new Uint8Array(this.chunkSize * this.chunkSize);

            for (let ly = 0; ly < this.chunkSize; ly++) {
                for (let lx = 0; lx < this.chunkSize; lx++) {
                    const x = cx * this.chunkSize + lx;
                    const y = cy * this.chunkSize + ly;

                    chunk[ly * this.chunkSize + lx] = this.generateBlock(x, y);
                }
            }

            this.chunks.set(this.getChunkKey(cx, cy), chunk);
        }

        generateBlock(x, y) {
            const biome = this.getBiome(x);
            // Get surface height using multi-octave noise
            const surfaceNoise = this.noise.octaveNoise(x * 0.02, 0, 4, 0.5);
            const surfaceHeight = CONFIG.SURFACE_HEIGHT + Math.floor(surfaceNoise * 20);

            // Bedrock layer
            if (y >= this.height - 3) {
                if (y >= this.height - 1 || Math.random() < 0.5) {
                    return BLOCKS.BEDROCK.id;
                }
            }

            // Above ground
            if (y < surfaceHeight) {
                return BLOCKS.AIR.id;
            }

            // Cave generation
            const caveValue = this.caveNoise.octaveNoise(x * 0.05, y * 0.05, 3, 0.5);
            const caveThreshold = 0.3 + (y / this.height) * 0.1;

            if (y > surfaceHeight + 5 && caveValue > caveThreshold) {
                return BLOCKS.AIR.id;
            }

            // Surface layer - use biome-specific block
            if (y === surfaceHeight) {
                return BLOCKS[biome.surfaceBlock].id;
            }

            // Subsurface layer (3-5 blocks deep)
            const subDepth = 3 + Math.floor(this.noise.noise2D(x * 0.1, y * 0.1) * 2);
            if (y <= surfaceHeight + subDepth) {
                return biome === BIOMES.DESERT ? BLOCKS.SAND.id : BLOCKS.DIRT.id;
            }

            // Stone with ores
            const depth = y - surfaceHeight;
            const ores = [
                [BLOCKS.DIAMOND_ORE, 100, Infinity, 0.1, 0, 0.85],
                [BLOCKS.GOLD_ORE, 60, Infinity, 0.15, 100, 0.8],
                [BLOCKS.IRON_ORE, 20, Infinity, 0.12, 200, 0.75],
                [BLOCKS.COAL_ORE, 5, 80, 0.08, 300, 0.7],
            ];
            for (const [block, min, max, scale, offset, threshold] of ores) {
                if (depth > min && depth < max && this.oreNoise.noise2D(x * scale + offset, y * scale) > threshold)
                    return block.id;
            }
            return BLOCKS.STONE.id;
        }

        // Generate trees after initial terrain
        generateTree(baseX, baseY, snowy = false) {
            const trunkHeight = 4 + Math.floor(Math.random() * 3);
            const leafBlock = snowy ? BLOCKS.SNOW_LEAVES : BLOCKS.LEAVES;

            // Trunk
            for (let y = 0; y < trunkHeight; y++) {
                this.setBlock(baseX, baseY - y - 1, BLOCKS.WOOD);
            }

            // Leaves
            const leafStart = baseY - trunkHeight;
            for (let dy = -2; dy <= 1; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    if (Math.abs(dx) === 2 && Math.abs(dy) === 1) continue;
                    if (dx === 0 && dy <= 0) continue;
                    if (Math.abs(dx) + Math.abs(dy) > 3) continue;
                    const lx = baseX + dx, ly = leafStart + dy;
                    if (this.getBlock(lx, ly).id === BLOCKS.AIR.id) this.setBlock(lx, ly, leafBlock);
                }
            }
            // Top leaves
            this.setBlock(baseX, leafStart - 2, leafBlock);
            this.setBlock(baseX - 1, leafStart - 1, leafBlock);
            this.setBlock(baseX + 1, leafStart - 1, leafBlock);
            this.setBlock(baseX, leafStart - 1, leafBlock);
        }

        generateCactus(baseX, baseY) {
            const height = 2 + Math.floor(Math.random() * 2);
            for (let y = 0; y < height; y++) {
                this.setBlock(baseX, baseY - y - 1, BLOCKS.CACTUS);
            }
        }
    }

    // --- PLAYER ---
    class Player {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.width = CONFIG.PLAYER_WIDTH;
            this.height = CONFIG.PLAYER_HEIGHT;
            this.onGround = false;
            this.facingRight = true;

            // Inventory: array of {blockId, count}
            this.inventory = new Array(9).fill(null);
            this.selectedSlot = 0;

            // Give starting items
            this.addToInventory(BLOCKS.DIRT, 64);
            this.addToInventory(BLOCKS.STONE, 32);
            this.addToInventory(BLOCKS.WOOD, 16);
        }

        addToInventory(block, count = 1) {
            // Try to stack with existing
            for (let i = 0; i < this.inventory.length; i++) {
                if (this.inventory[i] && this.inventory[i].blockId === block.id) {
                    this.inventory[i].count += count;
                    return true;
                }
            }

            // Find empty slot
            for (let i = 0; i < this.inventory.length; i++) {
                if (!this.inventory[i]) {
                    this.inventory[i] = { blockId: block.id, count: count };
                    return true;
                }
            }

            return false; // Inventory full
        }

        removeFromInventory(slot, count = 1) {
            if (!this.inventory[slot]) return false;

            this.inventory[slot].count -= count;
            if (this.inventory[slot].count <= 0) {
                this.inventory[slot] = null;
            }
            return true;
        }

        getSelectedBlock() {
            const item = this.inventory[this.selectedSlot];
            return item ? BLOCK_BY_ID[item.blockId] : null;
        }

        update(world, keys) {
            // Horizontal movement
            const moveSpeed = CONFIG.MOVE_SPEED;
            if (keys.left) {
                this.vx = -moveSpeed;
                this.facingRight = false;
            } else if (keys.right) {
                this.vx = moveSpeed;
                this.facingRight = true;
            } else {
                this.vx = 0;
            }

            // Jumping
            if (keys.jump && this.onGround) {
                this.vy = -CONFIG.JUMP_FORCE;
                this.onGround = false;
            }

            // Gravity
            this.vy += CONFIG.GRAVITY;
            if (this.vy > 15) this.vy = 15; // Terminal velocity

            // Move with collision detection
            this.moveWithCollision(world, this.vx * 0.1, 0);
            this.moveWithCollision(world, 0, this.vy * 0.1);
        }

        moveWithCollision(world, dx, dy) {
            const steps = 10;
            const stepX = dx / steps;
            const stepY = dy / steps;

            for (let i = 0; i < steps; i++) {
                const newX = this.x + stepX;
                const newY = this.y + stepY;

                if (!this.checkCollision(world, newX, this.y)) {
                    this.x = newX;
                }

                if (!this.checkCollision(world, this.x, newY)) {
                    this.y = newY;
                } else {
                    if (dy > 0) {
                        this.onGround = true;
                    }
                    this.vy = 0;
                }
            }

            // Check if still on ground
            if (!this.checkCollision(world, this.x, this.y + 0.1)) {
                this.onGround = false;
            }
        }

        checkCollision(world, x, y) {
            // Check all corners and edges of player hitbox
            const left = x - this.width / 2;
            const right = x + this.width / 2;
            const top = y - this.height;
            const bottom = y;

            // Sample multiple points
            const points = [
                [left, top], [right, top],
                [left, bottom - 0.01], [right, bottom - 0.01],
                [left, (top + bottom) / 2], [right, (top + bottom) / 2]
            ];

            for (const [px, py] of points) {
                const block = world.getBlock(Math.floor(px), Math.floor(py));
                if (block.solid) return true;
            }

            return false;
        }
    }

    // --- GAME ---
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');

            this.resize();
            window.addEventListener('resize', () => this.resize());

            // Try to load saved game
            const saveData = this.loadGame();

            // Generate world (with saved seed if available)
            const seed = saveData ? saveData.seed : undefined;
            this.world = new World(CONFIG.WORLD_WIDTH, CONFIG.WORLD_HEIGHT, seed);

            if (saveData) {
                // Restore saved game
                console.log('Restoring saved game...');

                // Restore world modifications
                this.world.modifiedBlocks = new Map(saveData.world.modifiedBlocks);

                // Restore player
                this.player = new Player(saveData.player.x, saveData.player.y);
                this.player.inventory = saveData.player.inventory;
                this.player.selectedSlot = saveData.player.selectedSlot;

                // Restore time
                this.gameTime = saveData.gameTime || 0;

                this.showNotification('Game Loaded');
            } else {
                // New game - find spawn point
                const spawnX = Math.floor(CONFIG.WORLD_WIDTH / 2);
                let spawnY = 0;
                for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                    if (this.world.getBlock(spawnX, y).solid) {
                        spawnY = y - 1;
                        break;
                    }
                }

                this.player = new Player(spawnX + 0.5, spawnY);

                // Generate vegetation near spawn based on biome
                for (let i = -15; i < 15; i++) {
                    const tx = spawnX + i * 8 + Math.floor(Math.random() * 4);
                    if (Math.abs(tx - spawnX) < 4) continue;
                    const biome = this.world.getBiome(tx);
                    let ty = 0;
                    const surfaceBlocks = [BLOCKS.GRASS.id, BLOCKS.SAND.id, BLOCKS.SNOW_GRASS.id];
                    for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                        if (surfaceBlocks.includes(this.world.getBlock(tx, y).id)) { ty = y; break; }
                    }
                    if (ty > 0 && Math.random() < biome.treeChance) {
                        if (biome.cactus) this.world.generateCactus(tx, ty);
                        else this.world.generateTree(tx, ty, biome.snowyTrees);
                    }
                }

                // Clear spawn area (in case of any obstructions)
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -3; dy <= 0; dy++) {
                        const block = this.world.getBlock(spawnX + dx, spawnY + dy);
                        if (block.solid && block.id !== BLOCKS.BEDROCK.id) {
                            this.world.setBlock(spawnX + dx, spawnY + dy, BLOCKS.AIR);
                        }
                    }
                }

                this.gameTime = 0;
            }

            // Camera
            this.cameraX = this.player.x;
            this.cameraY = this.player.y;

            // Input
            this.keys = { left: false, right: false, jump: false };
            this.mouse = { x: 0, y: 0, left: false, right: false };
            this.setupInput();

            // Mining
            this.mining = { active: false, x: 0, y: 0, progress: 0, target: null };

            // Touch controls
            this.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            this.touchMode = 'mine'; // 'mine' or 'place'
            this.touchTarget = { x: 0, y: 0 }; // Where to aim on touch devices
            if (this.isTouchDevice) {
                document.body.classList.add('touch-visible');
                this.setupTouchControls();
            }

            // Day/night cycle
            this.dayProgress = (this.gameTime / CONFIG.DAY_LENGTH) % 1;
            if (this.dayProgress === 0) this.dayProgress = 0.25; // Start at morning for new games

            // FPS
            this.frameCount = 0;
            this.lastFpsUpdate = Date.now();
            this.fps = 0;

            // Preload textures
            for (const key of Object.keys(BLOCKS)) {
                if (key !== 'AIR') {
                    TextureGenerator.createTexture(key);
                }
            }

            // UI
            this.setupUI();

            // Auto-save every 30 seconds
            this.autoSaveInterval = setInterval(() => this.saveGame(), 30000);

            // Save on page unload
            window.addEventListener('beforeunload', () => this.saveGame());

            // Start game loop
            this.lastTime = performance.now();
            this.loop();
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.ctx.imageSmoothingEnabled = false;
        }

        setupInput() {
            const keyMap = {
                KeyA: 'left', ArrowLeft: 'left',
                KeyD: 'right', ArrowRight: 'right',
                KeyW: 'jump', ArrowUp: 'jump', Space: 'jump'
            };

            document.addEventListener('keydown', (e) => {
                if (keyMap[e.code]) {
                    this.keys[keyMap[e.code]] = true;
                    if (e.code === 'Space') e.preventDefault();
                } else if (e.code.startsWith('Digit')) {
                    this.player.selectedSlot = parseInt(e.code.slice(-1)) - 1;
                    this.updateUI();
                } else if (e.code === 'KeyP') {
                    this.saveGame();
                } else if (e.code === 'KeyN' && confirm('Start a new game? Your current progress will be lost.')) {
                    this.deleteSave();
                    location.reload();
                }
            });

            document.addEventListener('keyup', (e) => {
                if (keyMap[e.code]) this.keys[keyMap[e.code]] = false;
            });

            this.canvas.addEventListener('mousemove', (e) => {
                this.mouse.x = e.clientX;
                this.mouse.y = e.clientY;
            });

            this.canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (e.button === 0) this.mouse.left = true;
                if (e.button === 2) this.mouse.right = true;
            });

            this.canvas.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    this.mouse.left = false;
                    this.mining.active = false;
                }
                if (e.button === 2) this.mouse.right = false;
            });

            this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            this.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY > 0) {
                    this.player.selectedSlot = (this.player.selectedSlot + 1) % 9;
                } else {
                    this.player.selectedSlot = (this.player.selectedSlot - 1 + 9) % 9;
                }
                this.updateUI();
            });
        }

        setupTouchControls() {
            const buttons = document.querySelectorAll('.touch-btn');
            const modeBtn = document.querySelector('.mode-btn');
            const modeLabel = document.getElementById('modeLabel');
            const crosshair = document.getElementById('touchCrosshair');

            // Track active touches for multi-touch support
            const activeTouches = new Map();

            // Prevent default touch behaviors on canvas
            this.canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
            this.canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

            // Handle button touches
            const setKey = (action, val) => { if (action in this.keys) this.keys[action] = val; };
            buttons.forEach(btn => {
                const action = btn.dataset.action;
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    btn.classList.add('active');
                    setKey(action, true);
                    if (action === 'mode') {
                        this.touchMode = this.touchMode === 'mine' ? 'place' : 'mine';
                        modeLabel.textContent = this.touchMode === 'mine' ? 'Mine' : 'Place';
                        modeBtn.textContent = this.touchMode === 'mine' ? '\u26CF' : '\u25A3';
                        modeBtn.classList.toggle('place-mode', this.touchMode === 'place');
                    }
                }, { passive: false });
                const endTouch = () => { btn.classList.remove('active'); setKey(action, false); };
                btn.addEventListener('touchend', (e) => { e.preventDefault(); endTouch(); }, { passive: false });
                btn.addEventListener('touchcancel', endTouch);
            });

            // Handle canvas touch for mining/placing
            let touchHoldTimer = null;
            let isTouchingCanvas = false;

            this.canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    isTouchingCanvas = true;

                    // Update mouse position for block targeting
                    this.mouse.x = touch.clientX;
                    this.mouse.y = touch.clientY;

                    // Update crosshair position
                    this.updateTouchCrosshair();

                    // Start hold timer for mining
                    if (this.touchMode === 'mine') {
                        touchHoldTimer = setTimeout(() => {
                            if (isTouchingCanvas) {
                                this.mouse.left = true;
                            }
                        }, 150); // Small delay to distinguish tap from hold
                    }
                }
            }, { passive: false });

            this.canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isTouchingCanvas) {
                    const touch = e.touches[0];
                    this.mouse.x = touch.clientX;
                    this.mouse.y = touch.clientY;
                    this.updateTouchCrosshair();
                }
            }, { passive: false });

            this.canvas.addEventListener('touchend', (e) => {
                if (touchHoldTimer) {
                    clearTimeout(touchHoldTimer);
                    touchHoldTimer = null;
                }

                if (isTouchingCanvas && e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];

                    // If it was a quick tap and in place mode, place a block
                    if (this.touchMode === 'place' && !this.mouse.left) {
                        this.mouse.x = touch.clientX;
                        this.mouse.y = touch.clientY;
                        this.mouse.right = true;
                        // Reset after a frame
                        setTimeout(() => { this.mouse.right = false; }, 50);
                    }

                    this.mouse.left = false;
                    this.mining.active = false;
                    isTouchingCanvas = false;
                }
            }, { passive: false });

            this.canvas.addEventListener('touchcancel', () => {
                if (touchHoldTimer) {
                    clearTimeout(touchHoldTimer);
                    touchHoldTimer = null;
                }
                this.mouse.left = false;
                this.mining.active = false;
                isTouchingCanvas = false;
            });

            // Initial crosshair position (center of screen)
            this.mouse.x = window.innerWidth / 2;
            this.mouse.y = window.innerHeight / 2;
            this.updateTouchCrosshair();
        }

        updateTouchCrosshair() {
            const crosshair = document.getElementById('touchCrosshair');
            const blockSize = CONFIG.BLOCK_SIZE;

            // Snap crosshair to block grid
            const target = this.getBlockAtMouse();
            const screenCenterX = this.canvas.width / 2;
            const screenCenterY = this.canvas.height / 2;

            const screenX = screenCenterX + (target.x - this.cameraX) * blockSize;
            const screenY = screenCenterY + (target.y - this.cameraY) * blockSize;

            crosshair.style.left = screenX + 'px';
            crosshair.style.top = screenY + 'px';
            crosshair.style.width = blockSize + 'px';
            crosshair.style.height = blockSize + 'px';
        }

        setupUI() {
            const ui = document.getElementById('ui');
            ui.innerHTML = '';

            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'slot' + (i === this.player.selectedSlot ? ' selected' : '');
                slot.innerHTML = `<span class="slot-key">${i + 1}</span><span class="slot-count"></span>`;
                slot.onclick = () => {
                    this.player.selectedSlot = i;
                    this.updateUI();
                };
                ui.appendChild(slot);
            }

            this.updateUI();
        }

        updateUI() {
            const slots = document.querySelectorAll('.slot');

            slots.forEach((slot, i) => {
                slot.className = 'slot' + (i === this.player.selectedSlot ? ' selected' : '');

                const item = this.player.inventory[i];
                const countEl = slot.querySelector('.slot-count');

                // Clear previous block preview
                const existingPreview = slot.querySelector('.block-preview');
                if (existingPreview) existingPreview.remove();

                if (item) {
                    const block = BLOCK_BY_ID[item.blockId];
                    const preview = document.createElement('canvas');
                    preview.className = 'block-preview';
                    preview.width = 32;
                    preview.height = 32;
                    preview.style.width = '32px';
                    preview.style.height = '32px';

                    const texture = TextureGenerator.createTexture(block.key);
                    preview.getContext('2d').drawImage(texture, 0, 0, 32, 32);

                    slot.insertBefore(preview, countEl);
                    countEl.textContent = item.count > 1 ? item.count : '';
                } else {
                    countEl.textContent = '';
                }
            });
        }

        getBlockAtMouse() {
            const blockSize = CONFIG.BLOCK_SIZE;
            const screenCenterX = this.canvas.width / 2;
            const screenCenterY = this.canvas.height / 2;

            const worldX = this.cameraX + (this.mouse.x - screenCenterX) / blockSize;
            const worldY = this.cameraY + (this.mouse.y - screenCenterY) / blockSize;

            return {
                x: Math.floor(worldX),
                y: Math.floor(worldY),
                worldX,
                worldY
            };
        }

        handleBlockInteraction(dt) {
            const target = this.getBlockAtMouse();
            const dx = target.worldX - this.player.x;
            const dy = target.worldY - (this.player.y - this.player.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > CONFIG.REACH_DISTANCE) {
                this.mining.active = false;
                return;
            }

            // Left click - mine
            if (this.mouse.left) {
                const block = this.world.getBlock(target.x, target.y);

                if (block.id !== BLOCKS.AIR.id && block.hardness !== Infinity) {
                    if (!this.mining.active || this.mining.x !== target.x || this.mining.y !== target.y) {
                        this.mining = {
                            active: true,
                            x: target.x,
                            y: target.y,
                            progress: 0,
                            target: block
                        };
                    }

                    this.mining.progress += dt / (block.hardness * 1000);

                    // Update mining progress bar
                    const progressBar = document.getElementById('miningProgress');
                    const fill = progressBar.querySelector('.fill');
                    progressBar.style.display = 'block';
                    progressBar.style.left = this.mouse.x - 20 + 'px';
                    progressBar.style.top = this.mouse.y + 20 + 'px';
                    fill.style.width = Math.min(100, this.mining.progress * 100) + '%';

                    if (this.mining.progress >= 1) {
                        // Break block
                        const dropBlock = block.drops ? BLOCKS[block.drops] : block;
                        this.player.addToInventory(dropBlock);
                        this.world.setBlock(target.x, target.y, BLOCKS.AIR);
                        this.mining.active = false;
                        progressBar.style.display = 'none';
                        this.updateUI();
                    }
                }
            } else {
                this.mining.active = false;
                document.getElementById('miningProgress').style.display = 'none';
            }

            // Right click - place
            if (this.mouse.right) {
                this.mouse.right = false; // Single place per click

                const currentBlock = this.world.getBlock(target.x, target.y);
                if (currentBlock.id === BLOCKS.AIR.id) {
                    const selectedBlock = this.player.getSelectedBlock();
                    if (selectedBlock) {
                        // Check not placing inside player
                        const playerBlocks = [
                            { x: Math.floor(this.player.x), y: Math.floor(this.player.y) },
                            { x: Math.floor(this.player.x), y: Math.floor(this.player.y - 1) }
                        ];

                        const isPlayerPos = playerBlocks.some(pb => pb.x === target.x && pb.y === target.y);

                        if (!isPlayerPos) {
                            this.world.setBlock(target.x, target.y, selectedBlock);
                            this.player.removeFromInventory(this.player.selectedSlot);
                            this.updateUI();
                        }
                    }
                }
            }
        }

        update(dt) {
            // Update player
            this.player.update(this.world, this.keys);

            // Smooth camera follow
            const smoothing = 0.1;
            this.cameraX += (this.player.x - this.cameraX) * smoothing;
            this.cameraY += (this.player.y - this.player.height / 2 - this.cameraY) * smoothing;

            // Handle block interactions
            this.handleBlockInteraction(dt);

            // Update time
            this.gameTime += dt / 1000;
            this.dayProgress = (this.gameTime / CONFIG.DAY_LENGTH) % 1;
        }

        render() {
            const ctx = this.ctx;
            const blockSize = CONFIG.BLOCK_SIZE;
            const screenCenterX = this.canvas.width / 2;
            const screenCenterY = this.canvas.height / 2;

            // Sky gradient based on time of day
            this.renderSky();

            // Calculate visible range
            const viewWidth = Math.ceil(this.canvas.width / blockSize) + 2;
            const viewHeight = Math.ceil(this.canvas.height / blockSize) + 2;

            const startX = Math.floor(this.cameraX - viewWidth / 2);
            const startY = Math.floor(this.cameraY - viewHeight / 2);

            // Render blocks
            for (let y = startY; y < startY + viewHeight; y++) {
                for (let x = startX; x < startX + viewWidth; x++) {
                    const block = this.world.getBlock(x, y);

                    if (block.id === BLOCKS.AIR.id) continue;

                    const screenX = screenCenterX + (x - this.cameraX) * blockSize;
                    const screenY = screenCenterY + (y - this.cameraY) * blockSize;

                    const texture = TextureGenerator.createTexture(block.key);
                    ctx.drawImage(texture, screenX, screenY, blockSize, blockSize);

                    // Subtle block borders
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.strokeRect(screenX, screenY, blockSize, blockSize);
                }
            }

            // Render player
            this.renderPlayer();

            // Highlight hovered block
            const target = this.getBlockAtMouse();
            const dx = target.worldX - this.player.x;
            const dy = target.worldY - (this.player.y - this.player.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= CONFIG.REACH_DISTANCE) {
                const block = this.world.getBlock(target.x, target.y);
                const screenX = screenCenterX + (target.x - this.cameraX) * blockSize;
                const screenY = screenCenterY + (target.y - this.cameraY) * blockSize;

                ctx.strokeStyle = block.id === BLOCKS.AIR.id ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, blockSize, blockSize);
                ctx.lineWidth = 1;

                // Mining crack overlay
                if (this.mining.active && this.mining.x === target.x && this.mining.y === target.y) {
                    ctx.fillStyle = `rgba(0,0,0,${this.mining.progress * 0.5})`;
                    ctx.fillRect(screenX, screenY, blockSize, blockSize);
                }
            }

            // Update info display
            document.getElementById('position').textContent =
                `${Math.floor(this.player.x)}, ${Math.floor(this.player.y)}`;

            const hour = Math.floor(this.dayProgress * 24);
            const isDay = hour >= 6 && hour < 18;
            document.getElementById('timeDisplay').textContent =
                `${hour.toString().padStart(2, '0')}:00 (${isDay ? 'Day' : 'Night'})`;

            // Update touch crosshair position (follows camera)
            if (this.isTouchDevice) {
                this.updateTouchCrosshair();
            }
        }

        renderSky() {
            const ctx = this.ctx;
            const hour = this.dayProgress * 24;
            const isDay = hour >= 6 && hour < 18;

            // Sky colors: [hour, topColor, bottomColor]
            const getSkyColors = () => {
                if (hour < 6) return ['#0a0a1e', '#1a1a3e'];
                if (hour < 8) { const t = (hour - 6) / 2; return [this.lerpColor('#1a1a3e', '#87CEEB', t), this.lerpColor('#4a3060', '#e0f0ff', t)]; }
                if (hour < 17) return ['#87CEEB', '#e0f0ff'];
                if (hour < 20) { const t = (hour - 17) / 3; return [this.lerpColor('#87CEEB', '#1a1a3e', t), this.lerpColor('#e0f0ff', '#4a3060', t)]; }
                return ['#0a0a1e', '#1a1a3e'];
            };
            const [skyTop, skyBottom] = getSkyColors();
            const gradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
            gradient.addColorStop(0, skyTop);
            gradient.addColorStop(1, skyBottom);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // Stars at night
            if (!isDay && hour >= 20 || hour < 6) {
                ctx.fillStyle = 'white';
                const starSeed = Math.floor(this.cameraX / 100);
                for (let i = 0; i < 100; i++) {
                    ctx.beginPath();
                    ctx.arc(((i * 7919 + starSeed * 104729) % 1000) / 1000 * this.canvas.width,
                            ((i * 7901 + starSeed * 104723) % 1000) / 1000 * this.canvas.height * 0.6,
                            ((i * 7907) % 3) + 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Sun/Moon
            const cx = this.canvas.width * (0.2 + this.dayProgress * 0.6);
            const cy = this.canvas.height * 0.2 + Math.sin(this.dayProgress * Math.PI) * this.canvas.height * 0.15;
            ctx.fillStyle = isDay ? '#fff5b5' : '#e8e8e8';
            ctx.shadowColor = isDay ? '#ffdd00' : '#ccccff';
            ctx.shadowBlur = isDay ? 30 : 20;
            ctx.beginPath();
            ctx.arc(cx, cy, isDay ? 40 : 30, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Parallax clouds (scroll at 0.1x speed)
            if (isDay) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                const cloudOffset = this.cameraX * 0.1;
                for (let i = 0; i < 8; i++) {
                    const seed = i * 12345;
                    const baseX = ((seed % 2000) - cloudOffset) % (this.canvas.width + 200) - 100;
                    const y = 40 + (seed * 7 % 80);
                    const w = 60 + (seed * 3 % 80);
                    ctx.beginPath();
                    ctx.ellipse(baseX, y, w, 20, 0, 0, Math.PI * 2);
                    ctx.ellipse(baseX - w * 0.4, y + 5, w * 0.6, 15, 0, 0, Math.PI * 2);
                    ctx.ellipse(baseX + w * 0.4, y + 5, w * 0.5, 15, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Parallax distant mountains (scroll at 0.2x speed)
            const mountainOffset = this.cameraX * 0.2;
            const mountainY = this.canvas.height * 0.5;
            const mountainColor = isDay ? 'rgba(100, 120, 150, 0.4)' : 'rgba(30, 40, 60, 0.5)';
            ctx.fillStyle = mountainColor;
            ctx.beginPath();
            ctx.moveTo(0, mountainY + 100);
            for (let x = 0; x <= this.canvas.width + 100; x += 20) {
                const worldX = x + mountainOffset;
                const h = Math.sin(worldX * 0.01) * 40 + Math.sin(worldX * 0.023) * 25 + Math.sin(worldX * 0.007) * 60;
                ctx.lineTo(x, mountainY - h);
            }
            ctx.lineTo(this.canvas.width, mountainY + 100);
            ctx.closePath();
            ctx.fill();

            // Parallax closer hills (scroll at 0.35x speed)
            const hillOffset = this.cameraX * 0.35;
            const hillY = this.canvas.height * 0.6;
            const hillColor = isDay ? 'rgba(80, 130, 80, 0.5)' : 'rgba(20, 50, 30, 0.6)';
            ctx.fillStyle = hillColor;
            ctx.beginPath();
            ctx.moveTo(0, hillY + 80);
            for (let x = 0; x <= this.canvas.width + 50; x += 15) {
                const worldX = x + hillOffset;
                const h = Math.sin(worldX * 0.015) * 30 + Math.sin(worldX * 0.031) * 20;
                ctx.lineTo(x, hillY - h);
            }
            ctx.lineTo(this.canvas.width, hillY + 80);
            ctx.closePath();
            ctx.fill();
        }

        renderPlayer() {
            const ctx = this.ctx;
            const blockSize = CONFIG.BLOCK_SIZE;
            const screenCenterX = this.canvas.width / 2;
            const screenCenterY = this.canvas.height / 2;

            const px = screenCenterX + (this.player.x - this.cameraX) * blockSize;
            const py = screenCenterY + (this.player.y - this.cameraY) * blockSize;

            const w = this.player.width * blockSize;
            const h = this.player.height * blockSize;

            // Body
            ctx.fillStyle = '#3b82f6'; // Blue shirt
            ctx.fillRect(px - w/2, py - h * 0.7, w, h * 0.5);

            // Head
            ctx.fillStyle = '#f5deb3'; // Skin tone
            ctx.fillRect(px - w/2 * 0.8, py - h, w * 0.8, h * 0.35);

            // Eyes
            ctx.fillStyle = '#000';
            const eyeOffset = this.player.facingRight ? 0.15 : -0.15;
            ctx.fillRect(px - w * 0.1 + w * eyeOffset, py - h * 0.9, w * 0.1, w * 0.1);
            ctx.fillRect(px + w * 0.1 + w * eyeOffset, py - h * 0.9, w * 0.1, w * 0.1);

            // Hair
            ctx.fillStyle = '#4a3728';
            ctx.fillRect(px - w/2 * 0.8, py - h, w * 0.8, h * 0.1);

            // Legs
            ctx.fillStyle = '#1e3a5f'; // Dark blue pants
            ctx.fillRect(px - w/2, py - h * 0.2, w * 0.4, h * 0.2);
            ctx.fillRect(px + w/2 - w * 0.4, py - h * 0.2, w * 0.4, h * 0.2);
        }

        lerpColor(a, b, t) {
            const ah = parseInt(a.replace(/#/g, ''), 16);
            const bh = parseInt(b.replace(/#/g, ''), 16);

            const ar = ah >> 16, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
            const br = bh >> 16, bg = (bh >> 8) & 0xff, bb = bh & 0xff;

            const rr = Math.round(ar + (br - ar) * t);
            const rg = Math.round(ag + (bg - ag) * t);
            const rb = Math.round(ab + (bb - ab) * t);

            return `#${((1 << 24) + (rr << 16) + (rg << 8) + rb).toString(16).slice(1)}`;
        }

        // --- SAVE/LOAD SYSTEM ---
        saveGame() {
            try {
                const saveData = {
                    version: 1,
                    timestamp: Date.now(),
                    seed: this.world.seed,
                    player: {
                        x: this.player.x,
                        y: this.player.y,
                        inventory: this.player.inventory,
                        selectedSlot: this.player.selectedSlot
                    },
                    world: {
                        // Convert Map to array of [key, value] pairs
                        modifiedBlocks: Array.from(this.world.modifiedBlocks.entries())
                    },
                    gameTime: this.gameTime
                };

                localStorage.setItem('minecraft2d_save', JSON.stringify(saveData));
                this.showNotification('Game Saved');
                console.log(`Game saved: ${saveData.world.modifiedBlocks.length} block changes`);
                return true;
            } catch (e) {
                console.error('Failed to save game:', e);
                this.showNotification('Save Failed!');
                return false;
            }
        }

        loadGame() {
            try {
                const saveJson = localStorage.getItem('minecraft2d_save');
                if (!saveJson) return null;

                const saveData = JSON.parse(saveJson);
                console.log(`Loading save from ${new Date(saveData.timestamp).toLocaleString()}`);
                return saveData;
            } catch (e) {
                console.error('Failed to load game:', e);
                return null;
            }
        }

        deleteSave() {
            localStorage.removeItem('minecraft2d_save');
            this.showNotification('Save Deleted');
        }

        showNotification(message) {
            const notif = document.getElementById('saveNotification');
            notif.textContent = message;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), 1500);
        }

        loop() {
            const now = performance.now();
            const dt = now - this.lastTime;
            this.lastTime = now;

            // FPS counter
            this.frameCount++;
            if (now - this.lastFpsUpdate >= 1000) {
                this.fps = this.frameCount;
                this.frameCount = 0;
                this.lastFpsUpdate = now;
                document.getElementById('fps').textContent = this.fps;
            }

            this.update(dt);
            this.render();

            requestAnimationFrame(() => this.loop());
        }
    }

    // --- START GAME ---
    window.addEventListener('load', () => {
        try {
            new Game();
            console.log('2D Minecraft initialized successfully!');
        } catch (error) {
            console.error('Game initialization failed:', error);
            alert('Failed to initialize game. Check console for details.');
        }
    });
    </script>
</body>
</html>
