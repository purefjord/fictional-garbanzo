<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2D Minecraft - Side Scroller</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #87CEEB;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
        }
        #gameCanvas {
            display: block;
            cursor: crosshair;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            border: 2px solid #555;
        }
        .slot {
            width: 50px;
            height: 50px;
            background: rgba(139,139,139,0.8);
            border: 2px solid #373737;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }
        .slot.selected {
            border-color: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        .slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        .slot-key {
            position: absolute;
            top: 2px;
            left: 4px;
            color: #aaa;
            font-size: 10px;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.8);
        }
        #crosshair::before {
            width: 2px; height: 20px;
            left: 9px; top: 0;
        }
        #crosshair::after {
            width: 20px; height: 2px;
            left: 0; top: 9px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px black;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
            max-width: 200px;
        }
        #miningProgress {
            position: absolute;
            width: 40px;
            height: 6px;
            background: rgba(0,0,0,0.5);
            border-radius: 3px;
            display: none;
        }
        #miningProgress .fill {
            height: 100%;
            background: #4CAF50;
            border-radius: 3px;
            transition: width 0.05s;
        }
        /* Health Bar */
        #healthBar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            padding: 5px 10px;
            background: rgba(0,0,0,0.4);
            border-radius: 5px;
        }
        .heart {
            width: 18px;
            height: 18px;
            position: relative;
        }
        .heart::before {
            content: '♥';
            position: absolute;
            font-size: 20px;
            line-height: 18px;
            color: #333;
            text-shadow: 0 0 2px #000;
        }
        .heart::after {
            content: '♥';
            position: absolute;
            font-size: 20px;
            line-height: 18px;
            color: #ff0000;
            text-shadow: 0 0 2px #000;
            clip-path: inset(0 0 0 0);
            transition: clip-path 0.1s;
        }
        .heart.empty::after {
            clip-path: inset(0 100% 0 0);
        }
        .heart.half::after {
            clip-path: inset(0 50% 0 0);
        }
        #damageOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 0, 0, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 500;
        }
        #damageOverlay.flash {
            opacity: 1;
        }
        #deathScreen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(100, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #deathScreen.show {
            display: flex;
        }
        #deathScreen h1 {
            color: #fff;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px #000;
        }
        #deathScreen button {
            padding: 15px 30px;
            font-size: 20px;
            background: #555;
            color: white;
            border: 2px solid #777;
            border-radius: 5px;
            cursor: pointer;
        }
        #deathScreen button:hover {
            background: #666;
        }

        /* Mobile Touch Controls */
        #touchControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            z-index: 100;
        }
        .touch-visible #touchControls {
            display: block;
        }
        .touch-visible #controls {
            display: none;
        }
        .touch-visible #ui {
            bottom: 140px;
        }
        .touch-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.25);
            border: 3px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px 3px black;
            pointer-events: all;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            transition: background 0.1s, transform 0.1s;
        }
        .touch-btn:active, .touch-btn.active {
            background: rgba(255,255,255,0.5);
            transform: scale(0.95);
        }
        .touch-btn.left-btn { bottom: 20px; left: 20px; }
        .touch-btn.right-btn { bottom: 20px; left: 100px; }
        .touch-btn.jump-btn { bottom: 20px; right: 20px; }
        .touch-btn.mode-btn {
            bottom: 100px;
            right: 20px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }
        .touch-btn.mode-btn.place-mode {
            background: rgba(100,200,100,0.4);
            border-color: rgba(100,255,100,0.6);
        }
        #modeLabel {
            position: absolute;
            bottom: 160px;
            right: 15px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px black;
            text-align: center;
            width: 60px;
            pointer-events: none;
        }
        /* Touch crosshair for aiming */
        #touchCrosshair {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255,255,255,0.7);
            border-radius: 4px;
            pointer-events: none;
            display: none;
            z-index: 50;
        }
        #touchCrosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: rgba(255,255,255,0.9);
            border-radius: 50%;
        }
        .touch-visible #touchCrosshair {
            display: block;
        }
        /* Larger slots on mobile */
        .touch-visible .slot {
            width: 40px;
            height: 40px;
        }
        .touch-visible .slot-key {
            display: none;
        }
        .touch-visible #info {
            font-size: 12px;
            padding: 6px;
        }
        #saveNotification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: #4CAF50;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        #saveNotification.show {
            opacity: 1;
        }

        /* Crafting UI */
        #craftingOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 800;
        }
        #craftingOverlay.show {
            display: flex;
        }
        #craftingPanel {
            background: #8b8b8b;
            border: 4px solid #373737;
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #craftingPanel h2 {
            color: #fff;
            text-shadow: 2px 2px #373737;
            margin: 0 0 15px 0;
            text-align: center;
            font-size: 24px;
        }
        .craft-section {
            margin-bottom: 20px;
        }
        .craft-section h3 {
            color: #ddd;
            font-size: 14px;
            margin: 0 0 10px 0;
            border-bottom: 2px solid #555;
            padding-bottom: 5px;
        }
        .recipe-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
        }
        .recipe-item {
            background: #5a5a5a;
            border: 2px solid #444;
            border-radius: 4px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .recipe-item:hover {
            background: #6a6a6a;
            border-color: #888;
        }
        .recipe-item.can-craft {
            border-color: #5a5;
            background: #4a5a4a;
        }
        .recipe-item.can-craft:hover {
            background: #5a6a5a;
            border-color: #7c7;
        }
        .recipe-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        .recipe-icon {
            width: 32px;
            height: 32px;
            background: #333;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .recipe-name {
            color: #fff;
            font-weight: bold;
            font-size: 14px;
        }
        .recipe-count {
            color: #aaa;
            font-size: 12px;
        }
        .recipe-ingredients {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .ingredient {
            display: flex;
            align-items: center;
            gap: 4px;
            background: #444;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 11px;
        }
        .ingredient-icon {
            width: 16px;
            height: 16px;
        }
        .ingredient-text {
            color: #ccc;
        }
        .ingredient-text.has-enough {
            color: #8f8;
        }
        .ingredient-text.not-enough {
            color: #f88;
        }
        #craftingClose {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            text-shadow: 2px 2px #000;
        }
        #craftingClose:hover {
            color: #f88;
        }
        .crafting-hint {
            color: #aaa;
            font-size: 12px;
            text-align: center;
            margin-top: 10px;
        }

        /* Furnace UI */
        #furnaceOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 800;
        }
        #furnaceOverlay.show {
            display: flex;
        }
        #furnacePanel {
            background: #8b8b8b;
            border: 4px solid #373737;
            border-radius: 8px;
            padding: 20px;
            position: relative;
        }
        #furnacePanel h2 {
            color: #fff;
            text-shadow: 2px 2px #373737;
            margin: 0 0 15px 0;
            text-align: center;
            font-size: 24px;
        }
        #furnaceClose {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            text-shadow: 2px 2px #000;
        }
        #furnaceClose:hover {
            color: #f88;
        }
        .furnace-grid {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .furnace-row {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .furnace-slot {
            width: 50px;
            height: 50px;
            background: #5a5a5a;
            border: 2px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }
        .furnace-slot:hover {
            border-color: #888;
        }
        .furnace-slot canvas {
            width: 32px;
            height: 32px;
        }
        .furnace-slot .slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        .furnace-arrow {
            font-size: 32px;
            color: #666;
        }
        .furnace-arrow.active {
            color: #fa0;
        }
        .furnace-fire {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #444;
        }
        .furnace-fire.burning {
            color: #f80;
            animation: flicker 0.5s infinite alternate;
        }
        @keyframes flicker {
            from { opacity: 0.8; }
            to { opacity: 1; }
        }
        .furnace-progress {
            width: 50px;
            height: 6px;
            background: #444;
            border-radius: 3px;
            margin-top: 5px;
        }
        .furnace-progress-fill {
            height: 100%;
            background: #fa0;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s;
        }
        .furnace-label {
            color: #aaa;
            font-size: 11px;
            text-align: center;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="healthBar"></div>
    <div id="damageOverlay"></div>
    <div id="deathScreen">
        <h1>You Died!</h1>
        <button id="respawnBtn">Respawn</button>
    </div>
    <div id="ui"></div>
    <div id="info">
        <div>FPS: <span id="fps">0</span></div>
        <div>Position: <span id="position">0, 0</span></div>
        <div>Time: <span id="timeDisplay">Day</span></div>
    </div>
    <div id="controls">
        <strong>Controls:</strong><br>
        WASD / Arrows - Move<br>
        Space - Jump<br>
        Left Click - Break block<br>
        Right Click - Place/Use<br>
        1-9 - Select hotbar<br>
        E - Crafting menu<br>
        P - Save game<br>
        N - New game
    </div>
    <div id="miningProgress"><div class="fill"></div></div>
    <div id="saveNotification">Game Saved</div>

    <!-- Crafting UI -->
    <div id="craftingOverlay">
        <div id="craftingPanel">
            <span id="craftingClose">&times;</span>
            <h2>Crafting</h2>
            <div id="craftingRecipes"></div>
            <div class="crafting-hint">Click a recipe to craft. Press E or Escape to close.</div>
        </div>
    </div>

    <!-- Furnace UI -->
    <div id="furnaceOverlay">
        <div id="furnacePanel">
            <span id="furnaceClose">&times;</span>
            <h2>Furnace</h2>
            <div class="furnace-grid">
                <div class="furnace-row">
                    <div>
                        <div class="furnace-slot" id="furnaceInput"></div>
                        <div class="furnace-label">Input</div>
                    </div>
                    <div class="furnace-arrow" id="furnaceArrow">&#10132;</div>
                    <div>
                        <div class="furnace-slot" id="furnaceOutput"></div>
                        <div class="furnace-label">Output</div>
                    </div>
                </div>
                <div class="furnace-row">
                    <div>
                        <div class="furnace-fire" id="furnaceFire">&#128293;</div>
                        <div class="furnace-slot" id="furnaceFuel"></div>
                        <div class="furnace-label">Fuel (Coal)</div>
                    </div>
                    <div class="furnace-progress">
                        <div class="furnace-progress-fill" id="furnaceProgress"></div>
                    </div>
                </div>
            </div>
            <div class="crafting-hint">Click slots to transfer items. Press Escape to close.</div>
        </div>
    </div>

    <!-- Mobile Touch Controls -->
    <div id="touchControls">
        <div id="touchCrosshair"></div>
        <div class="touch-btn left-btn" data-action="left">&#9664;</div>
        <div class="touch-btn right-btn" data-action="right">&#9654;</div>
        <div class="touch-btn jump-btn" data-action="jump">&#9650;</div>
        <div class="touch-btn mode-btn" data-action="mode">&#9935;</div>
        <div id="modeLabel">Mine</div>
    </div>

    <script>
    // ============================================
    // 2D MINECRAFT SIDE-SCROLLER
    // Single HTML file implementation
    // ============================================

    // --- CONFIGURATION ---
    const CONFIG = {
        BLOCK_SIZE: 32,
        WORLD_WIDTH: 512,      // blocks
        WORLD_HEIGHT: 256,     // blocks
        SURFACE_HEIGHT: 180,   // base surface level
        // Physics values in blocks/second or blocks/second²
        GRAVITY: 30,           // blocks/second² (acceleration)
        JUMP_FORCE: 10,        // blocks/second (initial velocity)
        MOVE_SPEED: 5,         // blocks/second
        TERMINAL_VELOCITY: 20, // blocks/second (max fall speed)
        MAX_DT: 50,            // ms - clamp dt to prevent huge jumps after tab switch
        PLAYER_WIDTH: 0.6,     // in blocks
        PLAYER_HEIGHT: 1.8,    // in blocks
        REACH_DISTANCE: 5,     // blocks
        DAY_LENGTH: 600,       // seconds for full day cycle
    };

    // --- DETERMINISTIC RNG HELPER ---
    // Seeded hash for reproducible random values based on coordinates
    function hash2i(seed, x, y) {
        let h = (seed | 0) ^ Math.imul(x | 0, 374761393) ^ Math.imul(y | 0, 668265263);
        h = Math.imul(h ^ (h >>> 13), 1274126177);
        h ^= h >>> 16;
        return (h >>> 0) / 4294967296;
    }

    // --- BLOCK TYPES ---
    // toolType: 'pickaxe' for stone/ore, 'axe' for wood, 'shovel' for dirt/sand
    // dropsItem: item ID to drop instead of block (for ores)
    const BLOCKS = {
        AIR: { id: 0, name: 'Air', solid: false, transparent: true },
        GRASS: { id: 1, name: 'Grass', solid: true, hardness: 0.6, drops: 'DIRT', toolType: 'shovel' },
        DIRT: { id: 2, name: 'Dirt', solid: true, hardness: 0.5, toolType: 'shovel' },
        STONE: { id: 3, name: 'Stone', solid: true, hardness: 1.5, drops: 'COBBLESTONE', toolType: 'pickaxe' },
        COBBLESTONE: { id: 4, name: 'Cobblestone', solid: true, hardness: 2, toolType: 'pickaxe' },
        WOOD: { id: 5, name: 'Wood', solid: true, hardness: 2, toolType: 'axe' },
        LEAVES: { id: 6, name: 'Leaves', solid: true, hardness: 0.2, transparent: true, randomDrop: { itemId: 204, chance: 0.1 } }, // 10% chance for apple
        SAND: { id: 7, name: 'Sand', solid: true, hardness: 0.5, toolType: 'shovel' },
        WATER: { id: 8, name: 'Water', solid: false, transparent: true },
        COAL_ORE: { id: 9, name: 'Coal Ore', solid: true, hardness: 3, toolType: 'pickaxe', dropsItem: 201 }, // Drops Coal
        IRON_ORE: { id: 10, name: 'Iron Ore', solid: true, hardness: 3, toolType: 'pickaxe', minTier: 1 }, // Drops itself for smelting
        GOLD_ORE: { id: 11, name: 'Gold Ore', solid: true, hardness: 3, toolType: 'pickaxe', minTier: 2 },
        DIAMOND_ORE: { id: 12, name: 'Diamond Ore', solid: true, hardness: 3, toolType: 'pickaxe', minTier: 2, dropsItem: 203 }, // Drops Diamond
        BEDROCK: { id: 13, name: 'Bedrock', solid: true, hardness: Infinity },
        PLANKS: { id: 14, name: 'Planks', solid: true, hardness: 2, toolType: 'axe' },
        GLASS: { id: 15, name: 'Glass', solid: true, hardness: 0.3, transparent: true, dropsNothing: true },
        FURNACE: { id: 16, name: 'Furnace', solid: true, hardness: 3.5, toolType: 'pickaxe', interactive: true },
    };

    // Create ID to block mapping
    const BLOCK_BY_ID = {};
    for (const [key, block] of Object.entries(BLOCKS)) {
        block.key = key;
        block.kind = 'block';
        BLOCK_BY_ID[block.id] = block;
    }

    // --- TOOLS ---
    // Tools are items that speed up mining and are required for certain blocks
    const TOOL_TIERS = {
        wood: { tier: 0, speedMultiplier: 2, durability: 60, color: '#8B5A2B' },
        stone: { tier: 1, speedMultiplier: 4, durability: 132, color: '#808080' },
        iron: { tier: 2, speedMultiplier: 6, durability: 251, color: '#C0C0C0' },
        diamond: { tier: 3, speedMultiplier: 8, durability: 1562, color: '#00CED1' }
    };

    const TOOLS = {
        // Pickaxes - for stone, ores (damage: 2-5 by tier)
        WOOD_PICKAXE: { id: 100, name: 'Wood Pickaxe', kind: 'tool', type: 'pickaxe', tier: 'wood', damage: 2, isItem: true, stackable: false },
        STONE_PICKAXE: { id: 101, name: 'Stone Pickaxe', kind: 'tool', type: 'pickaxe', tier: 'stone', damage: 3, isItem: true, stackable: false },
        IRON_PICKAXE: { id: 102, name: 'Iron Pickaxe', kind: 'tool', type: 'pickaxe', tier: 'iron', damage: 4, isItem: true, stackable: false },
        DIAMOND_PICKAXE: { id: 103, name: 'Diamond Pickaxe', kind: 'tool', type: 'pickaxe', tier: 'diamond', damage: 5, isItem: true, stackable: false },
        // Axes - for wood (damage: 4-7 by tier, axes hit harder)
        WOOD_AXE: { id: 110, name: 'Wood Axe', kind: 'tool', type: 'axe', tier: 'wood', damage: 4, isItem: true, stackable: false },
        STONE_AXE: { id: 111, name: 'Stone Axe', kind: 'tool', type: 'axe', tier: 'stone', damage: 5, isItem: true, stackable: false },
        IRON_AXE: { id: 112, name: 'Iron Axe', kind: 'tool', type: 'axe', tier: 'iron', damage: 6, isItem: true, stackable: false },
        DIAMOND_AXE: { id: 113, name: 'Diamond Axe', kind: 'tool', type: 'axe', tier: 'diamond', damage: 7, isItem: true, stackable: false },
        // Shovels - for dirt, sand (damage: 1-2 by tier, shovels are weak weapons)
        WOOD_SHOVEL: { id: 120, name: 'Wood Shovel', kind: 'tool', type: 'shovel', tier: 'wood', damage: 1, isItem: true, stackable: false },
        STONE_SHOVEL: { id: 121, name: 'Stone Shovel', kind: 'tool', type: 'shovel', tier: 'stone', damage: 2, isItem: true, stackable: false },
        IRON_SHOVEL: { id: 122, name: 'Iron Shovel', kind: 'tool', type: 'shovel', tier: 'iron', damage: 2, isItem: true, stackable: false },
        DIAMOND_SHOVEL: { id: 123, name: 'Diamond Shovel', kind: 'tool', type: 'shovel', tier: 'diamond', damage: 3, isItem: true, stackable: false },
    };

    // Create ID to tool mapping
    const TOOL_BY_ID = {};
    for (const [key, tool] of Object.entries(TOOLS)) {
        tool.key = key;
        TOOL_BY_ID[tool.id] = tool;
    }

    // --- MATERIALS (non-block, non-tool items) ---
    const ITEMS = {
        STICK: { id: 200, name: 'Stick', kind: 'item', isItem: true, stackable: true },
        COAL: { id: 201, name: 'Coal', kind: 'item', isItem: true, stackable: true },
        IRON_INGOT: { id: 202, name: 'Iron Ingot', kind: 'item', isItem: true, stackable: true },
        DIAMOND: { id: 203, name: 'Diamond', kind: 'item', isItem: true, stackable: true },
        APPLE: { id: 204, name: 'Apple', kind: 'item', isItem: true, stackable: true, food: true, healAmount: 4 },
    };

    // Create ID to item mapping
    const ITEM_BY_ID = {};
    for (const [key, item] of Object.entries(ITEMS)) {
        item.key = key;
        ITEM_BY_ID[item.id] = item;
    }

    // Combined item lookup (blocks + tools + items)
    function getItemById(id) {
        return BLOCK_BY_ID[id] || TOOL_BY_ID[id] || ITEM_BY_ID[id];
    }

    // --- CRAFTING RECIPES ---
    const RECIPES = [
        // Basic materials
        { result: BLOCKS.PLANKS, resultCount: 4, ingredients: [{ item: BLOCKS.WOOD, count: 1 }], name: 'Planks' },
        { result: ITEMS.STICK, resultCount: 4, ingredients: [{ item: BLOCKS.PLANKS, count: 2 }], name: 'Sticks' },

        // Furnace
        { result: BLOCKS.FURNACE, resultCount: 1, ingredients: [{ item: BLOCKS.COBBLESTONE, count: 8 }], name: 'Furnace' },

        // Wood tools
        { result: TOOLS.WOOD_PICKAXE, resultCount: 1, ingredients: [{ item: BLOCKS.PLANKS, count: 3 }, { item: ITEMS.STICK, count: 2 }], name: 'Wood Pickaxe' },
        { result: TOOLS.WOOD_AXE, resultCount: 1, ingredients: [{ item: BLOCKS.PLANKS, count: 3 }, { item: ITEMS.STICK, count: 2 }], name: 'Wood Axe' },
        { result: TOOLS.WOOD_SHOVEL, resultCount: 1, ingredients: [{ item: BLOCKS.PLANKS, count: 1 }, { item: ITEMS.STICK, count: 2 }], name: 'Wood Shovel' },

        // Stone tools
        { result: TOOLS.STONE_PICKAXE, resultCount: 1, ingredients: [{ item: BLOCKS.COBBLESTONE, count: 3 }, { item: ITEMS.STICK, count: 2 }], name: 'Stone Pickaxe' },
        { result: TOOLS.STONE_AXE, resultCount: 1, ingredients: [{ item: BLOCKS.COBBLESTONE, count: 3 }, { item: ITEMS.STICK, count: 2 }], name: 'Stone Axe' },
        { result: TOOLS.STONE_SHOVEL, resultCount: 1, ingredients: [{ item: BLOCKS.COBBLESTONE, count: 1 }, { item: ITEMS.STICK, count: 2 }], name: 'Stone Shovel' },

        // Iron tools
        { result: TOOLS.IRON_PICKAXE, resultCount: 1, ingredients: [{ item: ITEMS.IRON_INGOT, count: 3 }, { item: ITEMS.STICK, count: 2 }], name: 'Iron Pickaxe' },
        { result: TOOLS.IRON_AXE, resultCount: 1, ingredients: [{ item: ITEMS.IRON_INGOT, count: 3 }, { item: ITEMS.STICK, count: 2 }], name: 'Iron Axe' },
        { result: TOOLS.IRON_SHOVEL, resultCount: 1, ingredients: [{ item: ITEMS.IRON_INGOT, count: 1 }, { item: ITEMS.STICK, count: 2 }], name: 'Iron Shovel' },

        // Diamond tools
        { result: TOOLS.DIAMOND_PICKAXE, resultCount: 1, ingredients: [{ item: ITEMS.DIAMOND, count: 3 }, { item: ITEMS.STICK, count: 2 }], name: 'Diamond Pickaxe' },
        { result: TOOLS.DIAMOND_AXE, resultCount: 1, ingredients: [{ item: ITEMS.DIAMOND, count: 3 }, { item: ITEMS.STICK, count: 2 }], name: 'Diamond Axe' },
        { result: TOOLS.DIAMOND_SHOVEL, resultCount: 1, ingredients: [{ item: ITEMS.DIAMOND, count: 1 }, { item: ITEMS.STICK, count: 2 }], name: 'Diamond Shovel' },
    ];

    // --- SMELTING RECIPES ---
    const SMELTING_RECIPES = [
        { input: BLOCKS.IRON_ORE, output: ITEMS.IRON_INGOT, time: 10 }, // 10 seconds
        { input: BLOCKS.COBBLESTONE, output: BLOCKS.STONE, time: 10 },
        { input: BLOCKS.SAND, output: BLOCKS.GLASS, time: 10 },
    ];

    // Smelting lookup map (avoids linear search)
    const SMELT_BY_INPUT = new Map(SMELTING_RECIPES.map(r => [r.input.id, r]));

    // --- SIMPLEX NOISE IMPLEMENTATION ---
    class SimplexNoise {
        constructor(seed = Math.random() * 10000) {
            this.p = new Uint8Array(512);
            const perm = new Uint8Array(256);
            for (let i = 0; i < 256; i++) perm[i] = i;

            // Seed-based shuffle
            let s = seed;
            for (let i = 255; i > 0; i--) {
                s = (s * 16807) % 2147483647;
                const j = s % (i + 1);
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }

            for (let i = 0; i < 512; i++) this.p[i] = perm[i & 255];
        }

        noise2D(x, y) {
            const F2 = 0.5 * (Math.sqrt(3) - 1);
            const G2 = (3 - Math.sqrt(3)) / 6;

            const s = (x + y) * F2;
            const i = Math.floor(x + s);
            const j = Math.floor(y + s);

            const t = (i + j) * G2;
            const X0 = i - t;
            const Y0 = j - t;
            const x0 = x - X0;
            const y0 = y - Y0;

            const [i1, j1] = x0 > y0 ? [1, 0] : [0, 1];

            const x1 = x0 - i1 + G2;
            const y1 = y0 - j1 + G2;
            const x2 = x0 - 1 + 2 * G2;
            const y2 = y0 - 1 + 2 * G2;

            const ii = i & 255;
            const jj = j & 255;

            const grad = (hash, x, y) => {
                const h = hash & 7;
                const u = h < 4 ? x : y;
                const v = h < 4 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
            };

            let n0 = 0, n1 = 0, n2 = 0;

            let t0 = 0.5 - x0*x0 - y0*y0;
            if (t0 >= 0) {
                t0 *= t0;
                n0 = t0 * t0 * grad(this.p[ii + this.p[jj]], x0, y0);
            }

            let t1 = 0.5 - x1*x1 - y1*y1;
            if (t1 >= 0) {
                t1 *= t1;
                n1 = t1 * t1 * grad(this.p[ii + i1 + this.p[jj + j1]], x1, y1);
            }

            let t2 = 0.5 - x2*x2 - y2*y2;
            if (t2 >= 0) {
                t2 *= t2;
                n2 = t2 * t2 * grad(this.p[ii + 1 + this.p[jj + 1]], x2, y2);
            }

            return 70 * (n0 + n1 + n2);
        }

        octaveNoise(x, y, octaves, persistence = 0.5) {
            let total = 0;
            let frequency = 1;
            let amplitude = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                total += this.noise2D(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }

            return total / maxValue;
        }
    }

    // --- TEXTURE GENERATOR ---
    const TextureGenerator = {
        cache: {},

        createTexture(blockType, size = CONFIG.BLOCK_SIZE) {
            const cacheKey = `${blockType}_${size}`;
            if (this.cache[cacheKey]) return this.cache[cacheKey];

            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            switch(blockType) {
                case 'GRASS':
                    this.drawGrass(ctx, size);
                    break;
                case 'DIRT':
                    this.drawDirt(ctx, size);
                    break;
                case 'STONE':
                    this.drawStone(ctx, size);
                    break;
                case 'COBBLESTONE':
                    this.drawCobblestone(ctx, size);
                    break;
                case 'WOOD':
                    this.drawWood(ctx, size);
                    break;
                case 'LEAVES':
                    this.drawLeaves(ctx, size);
                    break;
                case 'SAND':
                    this.drawSand(ctx, size);
                    break;
                case 'WATER':
                    this.drawWater(ctx, size);
                    break;
                case 'COAL_ORE':
                    this.drawOre(ctx, size, '#333');
                    break;
                case 'IRON_ORE':
                    this.drawOre(ctx, size, '#d4a574');
                    break;
                case 'GOLD_ORE':
                    this.drawOre(ctx, size, '#ffd700');
                    break;
                case 'DIAMOND_ORE':
                    this.drawOre(ctx, size, '#00ffff');
                    break;
                case 'BEDROCK':
                    this.drawBedrock(ctx, size);
                    break;
                case 'PLANKS':
                    this.drawPlanks(ctx, size);
                    break;
                case 'GLASS':
                    this.drawGlass(ctx, size);
                    break;
                case 'FURNACE':
                    this.drawFurnace(ctx, size);
                    break;
                default:
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(0, 0, size, size);
            }

            this.cache[cacheKey] = canvas;
            return canvas;
        },

        drawGrass(ctx, size) {
            // Dirt base
            ctx.fillStyle = '#8B5A2B';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#6B4226', 0.3);

            // Green top
            const gradient = ctx.createLinearGradient(0, 0, 0, size * 0.4);
            gradient.addColorStop(0, '#5d8c32');
            gradient.addColorStop(1, '#4a7029');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size * 0.35);

            // Grass blades
            ctx.strokeStyle = '#7cb342';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * size;
                ctx.beginPath();
                ctx.moveTo(x, size * 0.35);
                ctx.lineTo(x + (Math.random() - 0.5) * 4, 0);
                ctx.stroke();
            }
        },

        drawDirt(ctx, size) {
            ctx.fillStyle = '#8B5A2B';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#6B4226', 0.4);
            this.addNoise(ctx, size, '#9B6A3B', 0.2);

            // Small rocks
            ctx.fillStyle = '#5a4020';
            for (let i = 0; i < 4; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                ctx.beginPath();
                ctx.arc(x, y, 1 + Math.random() * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        },

        drawStone(ctx, size) {
            ctx.fillStyle = '#808080';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#666666', 0.3);
            this.addNoise(ctx, size, '#999999', 0.2);

            // Cracks
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            for (let i = 0; i < 2; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * size, Math.random() * size);
                ctx.lineTo(Math.random() * size, Math.random() * size);
                ctx.stroke();
            }
        },

        drawCobblestone(ctx, size) {
            ctx.fillStyle = '#6a6a6a';
            ctx.fillRect(0, 0, size, size);

            // Irregular stones
            const stones = [
                [0, 0, size*0.5, size*0.45],
                [size*0.5, 0, size*0.5, size*0.5],
                [0, size*0.45, size*0.6, size*0.55],
                [size*0.55, size*0.5, size*0.45, size*0.5]
            ];

            stones.forEach(([x, y, w, h], i) => {
                ctx.fillStyle = i % 2 ? '#7a7a7a' : '#5a5a5a';
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
            });
        },

        drawWood(ctx, size) {
            ctx.fillStyle = '#6B4423';
            ctx.fillRect(0, 0, size, size);

            // Bark lines
            ctx.strokeStyle = '#4a3020';
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) {
                const x = i * (size / 4) + Math.random() * 4;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x + (Math.random() - 0.5) * 4, size);
                ctx.stroke();
            }

            // Rings hint
            ctx.fillStyle = '#5a3818';
            ctx.beginPath();
            ctx.ellipse(size/2, size/2, size*0.3, size*0.35, 0, 0, Math.PI * 2);
            ctx.fill();
        },

        drawLeaves(ctx, size) {
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 0, size, size);

            // Leaf clusters
            for (let i = 0; i < 15; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#32CD32' : '#1e7b1e';
                const x = Math.random() * size;
                const y = Math.random() * size;
                ctx.beginPath();
                ctx.arc(x, y, 2 + Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }
        },

        drawSand(ctx, size) {
            ctx.fillStyle = '#e6d59e';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#d4c48a', 0.3);

            // Sand grains
            ctx.fillStyle = '#c4b47a';
            for (let i = 0; i < 20; i++) {
                ctx.fillRect(
                    Math.random() * size,
                    Math.random() * size,
                    1, 1
                );
            }
        },

        drawWater(ctx, size) {
            const gradient = ctx.createLinearGradient(0, 0, size, size);
            gradient.addColorStop(0, 'rgba(30, 144, 255, 0.7)');
            gradient.addColorStop(1, 'rgba(0, 100, 180, 0.7)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            // Wave highlights
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(0, size * 0.3 * (i + 1));
                ctx.quadraticCurveTo(size/2, size * 0.3 * (i + 1) - 5, size, size * 0.3 * (i + 1));
                ctx.stroke();
            }
        },

        drawOre(ctx, size, oreColor) {
            // Stone base
            this.drawStone(ctx, size);

            // Ore deposits
            ctx.fillStyle = oreColor;
            const deposits = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < deposits; i++) {
                const x = 4 + Math.random() * (size - 8);
                const y = 4 + Math.random() * (size - 8);
                const s = 3 + Math.random() * 4;

                ctx.beginPath();
                ctx.moveTo(x, y - s);
                ctx.lineTo(x + s, y);
                ctx.lineTo(x, y + s);
                ctx.lineTo(x - s, y);
                ctx.closePath();
                ctx.fill();
            }
        },

        drawBedrock(ctx, size) {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, size, size);

            // Chaotic pattern
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#333' : '#0a0a0a';
                ctx.fillRect(
                    Math.random() * size,
                    Math.random() * size,
                    3 + Math.random() * 6,
                    3 + Math.random() * 6
                );
            }
        },

        drawPlanks(ctx, size) {
            ctx.fillStyle = '#ba8c51';
            ctx.fillRect(0, 0, size, size);

            // Horizontal planks
            ctx.strokeStyle = '#8a5c31';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                const y = i * (size / 4) + size / 8;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(size, y);
                ctx.stroke();
            }

            // Wood grain
            ctx.strokeStyle = 'rgba(100, 60, 20, 0.3)';
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * size, 0);
                ctx.lineTo(Math.random() * size, size);
                ctx.stroke();
            }
        },

        drawGlass(ctx, size) {
            ctx.fillStyle = 'rgba(200, 230, 255, 0.4)';
            ctx.fillRect(0, 0, size, size);

            // Frame
            ctx.strokeStyle = 'rgba(180, 210, 235, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, size - 2, size - 2);

            // Shine
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(2, 2);
            ctx.lineTo(size * 0.4, 2);
            ctx.lineTo(2, size * 0.4);
            ctx.closePath();
            ctx.fill();
        },

        drawFurnace(ctx, size) {
            // Stone base
            ctx.fillStyle = '#6a6a6a';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#555', 0.2);

            // Dark border
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, size - 2, size - 2);

            // Furnace opening (dark hole)
            const holeX = size * 0.25;
            const holeY = size * 0.4;
            const holeW = size * 0.5;
            const holeH = size * 0.45;

            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(holeX, holeY, holeW, holeH);

            // Inner glow hint
            ctx.fillStyle = '#333';
            ctx.fillRect(holeX + 2, holeY + 2, holeW - 4, holeH - 4);

            // Top vent
            ctx.fillStyle = '#555';
            ctx.fillRect(size * 0.3, size * 0.1, size * 0.4, size * 0.15);
            ctx.fillStyle = '#222';
            ctx.fillRect(size * 0.35, size * 0.12, size * 0.1, size * 0.1);
            ctx.fillRect(size * 0.55, size * 0.12, size * 0.1, size * 0.1);
        },

        addNoise(ctx, size, color, intensity) {
            ctx.fillStyle = color;
            for (let i = 0; i < size * size * intensity; i++) {
                ctx.fillRect(
                    Math.floor(Math.random() * size),
                    Math.floor(Math.random() * size),
                    1, 1
                );
            }
        },

        // Tool textures
        createToolTexture(toolKey, size = 32) {
            const cacheKey = `tool_${toolKey}_${size}`;
            if (this.cache[cacheKey]) return this.cache[cacheKey];

            const tool = TOOLS[toolKey];
            if (!tool) return null;

            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const tierInfo = TOOL_TIERS[tool.tier];
            const headColor = tierInfo.color;
            const handleColor = '#6B4423';

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            if (tool.type === 'pickaxe') {
                this.drawPickaxe(ctx, size, headColor, handleColor);
            } else if (tool.type === 'axe') {
                this.drawAxe(ctx, size, headColor, handleColor);
            } else if (tool.type === 'shovel') {
                this.drawShovel(ctx, size, headColor, handleColor);
            }

            this.cache[cacheKey] = canvas;
            return canvas;
        },

        drawPickaxe(ctx, size, headColor, handleColor) {
            const s = size / 32;
            // Handle (diagonal)
            ctx.strokeStyle = handleColor;
            ctx.lineWidth = 4 * s;
            ctx.beginPath();
            ctx.moveTo(8 * s, 24 * s);
            ctx.lineTo(24 * s, 8 * s);
            ctx.stroke();

            // Pickaxe head
            ctx.fillStyle = headColor;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1 * s;

            ctx.beginPath();
            ctx.moveTo(16 * s, 4 * s);
            ctx.lineTo(28 * s, 10 * s);
            ctx.lineTo(24 * s, 14 * s);
            ctx.lineTo(20 * s, 12 * s);
            ctx.lineTo(18 * s, 18 * s);
            ctx.lineTo(12 * s, 12 * s);
            ctx.lineTo(10 * s, 14 * s);
            ctx.lineTo(6 * s, 10 * s);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        },

        drawAxe(ctx, size, headColor, handleColor) {
            const s = size / 32;
            // Handle
            ctx.strokeStyle = handleColor;
            ctx.lineWidth = 4 * s;
            ctx.beginPath();
            ctx.moveTo(8 * s, 24 * s);
            ctx.lineTo(22 * s, 10 * s);
            ctx.stroke();

            // Axe head
            ctx.fillStyle = headColor;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1 * s;

            ctx.beginPath();
            ctx.moveTo(18 * s, 6 * s);
            ctx.quadraticCurveTo(30 * s, 8 * s, 26 * s, 18 * s);
            ctx.lineTo(20 * s, 14 * s);
            ctx.lineTo(18 * s, 12 * s);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        },

        drawShovel(ctx, size, headColor, handleColor) {
            const s = size / 32;
            // Handle
            ctx.strokeStyle = handleColor;
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(10 * s, 26 * s);
            ctx.lineTo(22 * s, 14 * s);
            ctx.stroke();

            // Shovel head
            ctx.fillStyle = headColor;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1 * s;

            ctx.beginPath();
            ctx.moveTo(20 * s, 16 * s);
            ctx.quadraticCurveTo(28 * s, 8 * s, 24 * s, 4 * s);
            ctx.quadraticCurveTo(20 * s, 2 * s, 16 * s, 6 * s);
            ctx.quadraticCurveTo(14 * s, 10 * s, 18 * s, 14 * s);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        },

        // Item textures (materials)
        createItemTexture(itemKey, size = 32) {
            const cacheKey = `item_${itemKey}_${size}`;
            if (this.cache[cacheKey]) return this.cache[cacheKey];

            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            switch (itemKey) {
                case 'STICK':
                    this.drawStick(ctx, size);
                    break;
                case 'COAL':
                    this.drawCoal(ctx, size);
                    break;
                case 'IRON_INGOT':
                    this.drawIngot(ctx, size, '#C0C0C0', '#888');
                    break;
                case 'DIAMOND':
                    this.drawDiamond(ctx, size);
                    break;
                case 'APPLE':
                    this.drawApple(ctx, size);
                    break;
                default:
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(size * 0.25, size * 0.25, size * 0.5, size * 0.5);
            }

            this.cache[cacheKey] = canvas;
            return canvas;
        },

        drawStick(ctx, size) {
            const s = size / 32;
            ctx.strokeStyle = '#6B4423';
            ctx.lineWidth = 4 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(10 * s, 26 * s);
            ctx.lineTo(22 * s, 6 * s);
            ctx.stroke();

            // Highlight
            ctx.strokeStyle = '#8B6443';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(11 * s, 24 * s);
            ctx.lineTo(21 * s, 8 * s);
            ctx.stroke();
        },

        drawCoal(ctx, size) {
            const s = size / 32;
            ctx.fillStyle = '#1a1a1a';

            // Irregular coal chunk
            ctx.beginPath();
            ctx.moveTo(8 * s, 16 * s);
            ctx.lineTo(12 * s, 8 * s);
            ctx.lineTo(20 * s, 6 * s);
            ctx.lineTo(26 * s, 12 * s);
            ctx.lineTo(24 * s, 22 * s);
            ctx.lineTo(16 * s, 26 * s);
            ctx.lineTo(10 * s, 24 * s);
            ctx.closePath();
            ctx.fill();

            // Shiny spots
            ctx.fillStyle = '#333';
            ctx.fillRect(14 * s, 12 * s, 4 * s, 3 * s);
            ctx.fillRect(18 * s, 16 * s, 3 * s, 4 * s);
        },

        drawIngot(ctx, size, color, shadow) {
            const s = size / 32;

            // 3D ingot shape
            ctx.fillStyle = shadow;
            ctx.beginPath();
            ctx.moveTo(4 * s, 20 * s);
            ctx.lineTo(8 * s, 26 * s);
            ctx.lineTo(28 * s, 26 * s);
            ctx.lineTo(28 * s, 16 * s);
            ctx.lineTo(24 * s, 12 * s);
            ctx.lineTo(4 * s, 12 * s);
            ctx.closePath();
            ctx.fill();

            // Top face
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(4 * s, 12 * s);
            ctx.lineTo(8 * s, 8 * s);
            ctx.lineTo(28 * s, 8 * s);
            ctx.lineTo(24 * s, 12 * s);
            ctx.closePath();
            ctx.fill();

            // Front face
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(4 * s, 12 * s);
            ctx.lineTo(4 * s, 20 * s);
            ctx.lineTo(8 * s, 26 * s);
            ctx.lineTo(8 * s, 8 * s);
            ctx.closePath();
            ctx.fill();

            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(6 * s, 9 * s, 18 * s, 2 * s);
        },

        drawDiamond(ctx, size) {
            const s = size / 32;

            // Diamond gem shape
            ctx.fillStyle = '#00CED1';
            ctx.beginPath();
            ctx.moveTo(16 * s, 4 * s);   // Top
            ctx.lineTo(26 * s, 12 * s);  // Top right
            ctx.lineTo(22 * s, 28 * s);  // Bottom right
            ctx.lineTo(10 * s, 28 * s);  // Bottom left
            ctx.lineTo(6 * s, 12 * s);   // Top left
            ctx.closePath();
            ctx.fill();

            // Facets
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = 1 * s;
            ctx.beginPath();
            ctx.moveTo(16 * s, 4 * s);
            ctx.lineTo(16 * s, 28 * s);
            ctx.moveTo(6 * s, 12 * s);
            ctx.lineTo(26 * s, 12 * s);
            ctx.moveTo(16 * s, 12 * s);
            ctx.lineTo(10 * s, 28 * s);
            ctx.moveTo(16 * s, 12 * s);
            ctx.lineTo(22 * s, 28 * s);
            ctx.stroke();

            // Shine
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.moveTo(16 * s, 4 * s);
            ctx.lineTo(10 * s, 12 * s);
            ctx.lineTo(16 * s, 12 * s);
            ctx.closePath();
            ctx.fill();
        },

        drawApple(ctx, size) {
            const s = size / 32;

            // Apple body (red)
            ctx.fillStyle = '#cc2222';
            ctx.beginPath();
            ctx.ellipse(16 * s, 18 * s, 10 * s, 11 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Darker shade
            ctx.fillStyle = '#aa1111';
            ctx.beginPath();
            ctx.ellipse(20 * s, 20 * s, 6 * s, 8 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.ellipse(12 * s, 14 * s, 4 * s, 5 * s, -0.5, 0, Math.PI * 2);
            ctx.fill();

            // Stem
            ctx.strokeStyle = '#5a3d2b';
            ctx.lineWidth = 2 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(16 * s, 7 * s);
            ctx.quadraticCurveTo(18 * s, 4 * s, 20 * s, 5 * s);
            ctx.stroke();

            // Leaf
            ctx.fillStyle = '#228822';
            ctx.beginPath();
            ctx.ellipse(22 * s, 6 * s, 4 * s, 2 * s, 0.5, 0, Math.PI * 2);
            ctx.fill();
        }
    };

    // --- WORLD GENERATION ---
    class World {
        constructor(width, height, seed) {
            this.width = width;
            this.height = height;
            this.seed = seed || Math.random() * 10000;
            this.noise = new SimplexNoise(this.seed);
            this.caveNoise = new SimplexNoise(this.seed + 1000);
            this.oreNoise = new SimplexNoise(this.seed + 2000);

            // Chunk-based loading
            this.chunkSize = 16;
            this.chunks = new Map();
            this.modifiedBlocks = new Map(); // Track player modifications
        }

        getChunkKey(cx, cy) {
            return `${cx},${cy}`;
        }

        getBlock(x, y) {
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
                return BLOCKS.AIR;
            }

            // Check for player modifications first
            const modKey = `${x},${y}`;
            if (this.modifiedBlocks.has(modKey)) {
                return BLOCK_BY_ID[this.modifiedBlocks.get(modKey)];
            }

            // Generate if needed
            const cx = Math.floor(x / this.chunkSize);
            const cy = Math.floor(y / this.chunkSize);
            const chunkKey = this.getChunkKey(cx, cy);

            if (!this.chunks.has(chunkKey)) {
                this.generateChunk(cx, cy);
            }

            const chunk = this.chunks.get(chunkKey);
            const lx = x - cx * this.chunkSize;
            const ly = y - cy * this.chunkSize;

            return BLOCK_BY_ID[chunk[ly * this.chunkSize + lx]] || BLOCKS.AIR;
        }

        setBlock(x, y, blockType) {
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;

            const modKey = `${x},${y}`;
            this.modifiedBlocks.set(modKey, blockType.id);
        }

        generateChunk(cx, cy) {
            const chunk = new Uint8Array(this.chunkSize * this.chunkSize);

            for (let ly = 0; ly < this.chunkSize; ly++) {
                for (let lx = 0; lx < this.chunkSize; lx++) {
                    const x = cx * this.chunkSize + lx;
                    const y = cy * this.chunkSize + ly;

                    chunk[ly * this.chunkSize + lx] = this.generateBlock(x, y);
                }
            }

            this.chunks.set(this.getChunkKey(cx, cy), chunk);
        }

        generateBlock(x, y) {
            // Get surface height using multi-octave noise
            const surfaceNoise = this.noise.octaveNoise(x * 0.02, 0, 4, 0.5);
            const surfaceHeight = CONFIG.SURFACE_HEIGHT + Math.floor(surfaceNoise * 20);

            // Bedrock layer (deterministic based on seed + coords)
            if (y >= this.height - 3) {
                if (y >= this.height - 1 || hash2i(this.seed, x, y) < 0.5) {
                    return BLOCKS.BEDROCK.id;
                }
            }

            // Above ground
            if (y < surfaceHeight) {
                return BLOCKS.AIR.id;
            }

            // Cave generation
            const caveValue = this.caveNoise.octaveNoise(x * 0.05, y * 0.05, 3, 0.5);
            const caveThreshold = 0.3 + (y / this.height) * 0.1; // Caves more common deeper

            if (y > surfaceHeight + 5 && caveValue > caveThreshold) {
                return BLOCKS.AIR.id;
            }

            // Surface layer
            if (y === surfaceHeight) {
                return BLOCKS.GRASS.id;
            }

            // Dirt layer (3-5 blocks deep)
            const dirtDepth = 3 + Math.floor(this.noise.noise2D(x * 0.1, y * 0.1) * 2);
            if (y <= surfaceHeight + dirtDepth) {
                return BLOCKS.DIRT.id;
            }

            // Stone with ores
            const depth = y - surfaceHeight;

            // Diamond (deep)
            if (depth > 100 && this.oreNoise.noise2D(x * 0.1, y * 0.1) > 0.85) {
                return BLOCKS.DIAMOND_ORE.id;
            }

            // Gold (medium-deep)
            if (depth > 60 && this.oreNoise.noise2D(x * 0.15 + 100, y * 0.15) > 0.8) {
                return BLOCKS.GOLD_ORE.id;
            }

            // Iron (everywhere below surface)
            if (depth > 20 && this.oreNoise.noise2D(x * 0.12 + 200, y * 0.12) > 0.75) {
                return BLOCKS.IRON_ORE.id;
            }

            // Coal (shallow to medium)
            if (depth > 5 && depth < 80 && this.oreNoise.noise2D(x * 0.08 + 300, y * 0.08) > 0.7) {
                return BLOCKS.COAL_ORE.id;
            }

            return BLOCKS.STONE.id;
        }

        // Generate trees after initial terrain
        generateTree(baseX, baseY) {
            // Tree height is deterministic based on position
            const trunkHeight = 4 + Math.floor(hash2i(this.seed, baseX, baseY) * 3);

            // Trunk
            for (let y = 0; y < trunkHeight; y++) {
                this.setBlock(baseX, baseY - y - 1, BLOCKS.WOOD);
            }

            // Leaves
            const leafStart = baseY - trunkHeight;
            for (let dy = -2; dy <= 1; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    if (Math.abs(dx) === 2 && Math.abs(dy) === 1) continue;
                    if (dx === 0 && dy <= 0) continue; // Leave space for trunk top
                    if (Math.abs(dx) + Math.abs(dy) > 3) continue;

                    const lx = baseX + dx;
                    const ly = leafStart + dy;

                    if (this.getBlock(lx, ly).id === BLOCKS.AIR.id) {
                        this.setBlock(lx, ly, BLOCKS.LEAVES);
                    }
                }
            }

            // Top leaves
            this.setBlock(baseX, leafStart - 2, BLOCKS.LEAVES);
            this.setBlock(baseX - 1, leafStart - 1, BLOCKS.LEAVES);
            this.setBlock(baseX + 1, leafStart - 1, BLOCKS.LEAVES);
            this.setBlock(baseX, leafStart - 1, BLOCKS.LEAVES);
        }
    }

    // --- PLAYER ---
    // --- ENTITY BASE CLASS (shared physics/collision) ---
    class Entity {
        constructor(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.width = width;
            this.height = height;
            this.onGround = false;
            this.facingRight = true;
        }

        // Shared collision detection
        checkCollision(world, x, y) {
            const left = x - this.width / 2;
            const right = x + this.width / 2;
            const top = y - this.height;
            const bottom = y;

            // Sample multiple points for accurate collision
            const points = [
                [left, top], [right, top],
                [left, bottom - 0.01], [right, bottom - 0.01],
                [left, (top + bottom) / 2], [right, (top + bottom) / 2]
            ];

            for (const [px, py] of points) {
                const block = world.getBlock(Math.floor(px), Math.floor(py));
                if (block.solid) return true;
            }
            return false;
        }

        // Shared movement with collision
        moveWithCollision(world, dx, dy, steps = 10) {
            const stepX = dx / steps;
            const stepY = dy / steps;

            for (let i = 0; i < steps; i++) {
                const newX = this.x + stepX;
                const newY = this.y + stepY;

                if (!this.checkCollision(world, newX, this.y)) {
                    this.x = newX;
                }

                if (!this.checkCollision(world, this.x, newY)) {
                    this.y = newY;
                } else {
                    if (dy > 0) {
                        this.onGround = true;
                    }
                    this.vy = 0;
                }
            }

            // Check if still on ground
            if (!this.checkCollision(world, this.x, this.y + 0.1)) {
                this.onGround = false;
            }
        }

        // Distance to another entity or point
        distanceTo(other) {
            const dx = (other.x !== undefined ? other.x : other) - this.x;
            const dy = (other.y !== undefined ? other.y : 0) - this.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
    }

    class Player extends Entity {
        constructor(x, y) {
            super(x, y, CONFIG.PLAYER_WIDTH, CONFIG.PLAYER_HEIGHT);

            // Health system
            this.maxHealth = 20;
            this.health = this.maxHealth;
            this.isDead = false;

            // Fall damage tracking
            this.fallStartY = y;
            this.isFalling = false;

            // Swing animation
            this.swingAngle = 0;
            this.isSwinging = false;
            this.swingProgress = 0;

            // Inventory: array of {itemId, count} - can be blocks or tools
            this.inventory = new Array(9).fill(null);
            this.selectedSlot = 0;

            // Give starting items (including a wood pickaxe!)
            this.addToInventory(TOOLS.WOOD_PICKAXE, 1);
            this.addToInventory(BLOCKS.DIRT, 64);
            this.addToInventory(BLOCKS.STONE, 32);
            this.addToInventory(BLOCKS.WOOD, 16);
        }

        // Get held item (block or tool)
        getHeldItem() {
            const slot = this.inventory[this.selectedSlot];
            if (!slot) return null;
            return getItemById(slot.itemId);
        }

        // Get held tool (if any) - only returns actual tools, not materials
        getHeldTool() {
            const slot = this.inventory[this.selectedSlot];
            if (!slot) return null;
            return TOOL_BY_ID[slot.itemId] || null;
        }

        // Calculate mining speed multiplier based on tool
        getMiningSpeed(block) {
            const tool = this.getHeldTool();
            if (!tool) return 1; // No tool = base speed

            const tierInfo = TOOL_TIERS[tool.tier];

            // Check if tool matches block type
            if (block.toolType && tool.type === block.toolType) {
                // Check tier requirement
                const minTier = block.minTier || 0;
                if (tierInfo.tier >= minTier) {
                    return tierInfo.speedMultiplier;
                }
            }

            // Wrong tool type or tier too low
            return 1;
        }

        // Check if tool can harvest block (for ore tier requirements)
        canHarvest(block) {
            if (!block.minTier) return true;

            const tool = this.getHeldTool();
            if (!tool || tool.type !== block.toolType) return false;

            const tierInfo = TOOL_TIERS[tool.tier];
            return tierInfo.tier >= block.minTier;
        }

        // Start swing animation
        startSwing() {
            if (!this.isSwinging) {
                this.isSwinging = true;
                this.swingProgress = 0;
            }
        }

        // Update swing animation
        updateSwing(dt) {
            if (this.isSwinging) {
                this.swingProgress += dt / 200; // 200ms swing duration
                this.swingAngle = Math.sin(this.swingProgress * Math.PI) * 90;
                if (this.swingProgress >= 1) {
                    this.isSwinging = false;
                    this.swingAngle = 0;
                    this.swingProgress = 0;
                }
            }
        }

        takeDamage(amount) {
            if (this.isDead) return;
            this.health = Math.max(0, this.health - amount);
            if (this.health <= 0) {
                this.isDead = true;
            }
            return this.health;
        }

        heal(amount) {
            this.health = Math.min(this.maxHealth, this.health + amount);
        }

        respawn(x, y) {
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.health = this.maxHealth;
            this.isDead = false;
            this.fallStartY = y;
            this.isFalling = false;
        }

        addToInventory(item, count = 1) {
            // Returns number of items that couldn't be added (0 = complete success)
            // Items stack if they have stackable: true (or undefined for blocks which default to stackable)
            // Tools explicitly have stackable: false
            const canStack = item.stackable !== false;
            const maxStack = canStack ? 64 : 1;
            let remaining = count;

            // Try to stack with existing slots first (only for stackable items)
            if (canStack) {
                for (let i = 0; i < this.inventory.length && remaining > 0; i++) {
                    if (this.inventory[i] && this.inventory[i].itemId === item.id) {
                        const space = maxStack - this.inventory[i].count;
                        if (space > 0) {
                            const toAdd = Math.min(space, remaining);
                            this.inventory[i].count += toAdd;
                            remaining -= toAdd;
                        }
                    }
                }
            }

            // Fill empty slots with remainder
            for (let i = 0; i < this.inventory.length && remaining > 0; i++) {
                if (!this.inventory[i]) {
                    const toAdd = Math.min(maxStack, remaining);
                    this.inventory[i] = { itemId: item.id, count: toAdd };
                    remaining -= toAdd;
                }
            }

            return remaining; // 0 = success, >0 = overflow (items lost/dropped)
        }

        removeFromInventory(slot, count = 1) {
            if (!this.inventory[slot]) return false;

            this.inventory[slot].count -= count;
            if (this.inventory[slot].count <= 0) {
                this.inventory[slot] = null;
            }
            return true;
        }

        getSelectedBlock() {
            // Returns the selected block for placing (tools return null)
            const item = this.getHeldItem();
            if (!item || item.isItem) return null;
            return item;
        }

        update(world, keys, dt) {
            if (this.isDead) return 0;

            // dt is already clamped by Game.update()
            const dtSeconds = dt / 1000;

            // Horizontal movement (instant velocity, not acceleration-based)
            if (keys.left) {
                this.vx = -CONFIG.MOVE_SPEED;
                this.facingRight = false;
            } else if (keys.right) {
                this.vx = CONFIG.MOVE_SPEED;
                this.facingRight = true;
            } else {
                this.vx = 0;
            }

            // Jumping
            if (keys.jump && this.onGround) {
                this.vy = -CONFIG.JUMP_FORCE;
                this.onGround = false;
            }

            // Track fall start
            const wasOnGround = this.onGround;
            if (wasOnGround && this.vy >= 0) {
                this.fallStartY = this.y;
                this.isFalling = false;
            }
            if (!this.onGround && this.vy > 0) {
                if (!this.isFalling) {
                    this.fallStartY = this.y;
                    this.isFalling = true;
                }
            }

            // Gravity (acceleration in blocks/second²)
            this.vy += CONFIG.GRAVITY * dtSeconds;
            if (this.vy > CONFIG.TERMINAL_VELOCITY) this.vy = CONFIG.TERMINAL_VELOCITY;

            // Move with collision detection (dt-based displacement)
            const dx = this.vx * dtSeconds;
            const dy = this.vy * dtSeconds;
            this.moveWithCollision(world, dx, dy);

            // Calculate fall damage on landing
            let fallDamage = 0;
            if (this.onGround && this.isFalling) {
                const fallDistance = this.y - this.fallStartY;
                // Take damage for falls > 3 blocks (1 damage per block after 3)
                if (fallDistance > 3) {
                    fallDamage = Math.floor(fallDistance - 3);
                    this.takeDamage(fallDamage);
                }
                this.isFalling = false;
            }

            return fallDamage;
        }
        // moveWithCollision and checkCollision inherited from Entity
    }

    // --- MOB SYSTEM ---
    class Mob extends Entity {
        constructor(x, y, type = 'zombie') {
            super(x, y, 0.6, 1.8);
            this.type = type;

            // Stats based on type
            if (type === 'zombie') {
                this.maxHealth = 10;
                this.damage = 2;
                this.speed = 1.5;
                this.color = '#2a6e2a'; // Green zombie
            }

            this.health = this.maxHealth;
            this.isDead = false;
            // onGround and facingRight inherited from Entity

            // AI state
            this.aiState = 'idle'; // 'idle', 'chase'
            this.targetPlayer = null;
            this.jumpCooldown = 0;

            // Combat
            this.invincibleTime = 0; // Invincibility frames after taking damage
            this.knockbackX = 0;
            this.attackCooldown = 0; // Cooldown between attacks on player
        }

        update(world, player, dt) {
            if (this.isDead) return;

            const dtSeconds = dt / 1000;

            // Update cooldowns
            if (this.invincibleTime > 0) this.invincibleTime -= dtSeconds;
            if (this.jumpCooldown > 0) this.jumpCooldown -= dtSeconds;
            if (this.attackCooldown > 0) this.attackCooldown -= dtSeconds;

            // AI: Check distance to player
            const distX = player.x - this.x;
            const distY = player.y - this.y;
            const distance = this.distanceTo(player);

            // Aggro range
            if (distance < 15) {
                this.aiState = 'chase';
                this.targetPlayer = player;
            } else if (distance > 20) {
                this.aiState = 'idle';
                this.targetPlayer = null;
            }

            // Movement based on AI state
            if (this.aiState === 'chase' && this.targetPlayer && !this.targetPlayer.isDead) {
                // Move toward player
                if (distX > 0.5) {
                    this.vx = this.speed;
                    this.facingRight = true;
                } else if (distX < -0.5) {
                    this.vx = -this.speed;
                    this.facingRight = false;
                } else {
                    this.vx = 0;
                }

                // Jump if blocked or player is above
                if (this.onGround && this.jumpCooldown <= 0) {
                    // Check if blocked by a wall
                    const checkX = this.x + (this.facingRight ? 0.5 : -0.5);
                    const blocked = world.getBlock(Math.floor(checkX), Math.floor(this.y - 0.5)).solid;

                    if (blocked || distY < -1.5) {
                        this.vy = -CONFIG.JUMP_FORCE * 0.8;
                        this.onGround = false;
                        this.jumpCooldown = 0.5;
                    }
                }
            } else {
                // Idle: slow random movement or stand still
                this.vx = 0;
            }

            // Apply knockback
            if (this.knockbackX !== 0) {
                this.vx += this.knockbackX;
                this.knockbackX *= 0.8; // Decay
                if (Math.abs(this.knockbackX) < 0.1) this.knockbackX = 0;
            }

            // Gravity (dt-based, dtSeconds defined above)
            this.vy += CONFIG.GRAVITY * dtSeconds;
            if (this.vy > CONFIG.TERMINAL_VELOCITY) this.vy = CONFIG.TERMINAL_VELOCITY;

            // Move with collision (dt-based)
            const dx = this.vx * dtSeconds;
            const dy = this.vy * dtSeconds;
            this.moveWithCollision(world, dx, dy);

            // Check contact with player for damage
            if (this.attackCooldown <= 0 && this.targetPlayer && !this.targetPlayer.isDead) {
                const contactDist = this.distanceTo(this.targetPlayer);

                if (contactDist < 1.0) {
                    // Hit player
                    this.targetPlayer.takeDamage(this.damage);
                    this.attackCooldown = 1.0; // 1 second between attacks
                    return { hitPlayer: true, damage: this.damage };
                }
            }

            return null;
        }
        // moveWithCollision and checkCollision inherited from Entity

        takeDamage(amount, knockbackDir = 0) {
            if (this.invincibleTime > 0 || this.isDead) return false;

            this.health -= amount;
            this.invincibleTime = 0.3; // Brief invincibility
            this.knockbackX = knockbackDir * 8; // Knockback force

            if (this.health <= 0) {
                this.isDead = true;
                return true; // Died
            }
            return false;
        }

        // Check if a point (like mouse click) hits this mob
        containsPoint(worldX, worldY) {
            const halfW = this.width / 2;
            return worldX >= this.x - halfW && worldX <= this.x + halfW &&
                   worldY <= this.y && worldY >= this.y - this.height;
        }
    }

    // --- MOB SYSTEM MANAGER ---
    class MobSystem {
        constructor(maxMobs = 8) {
            this.mobs = [];
            this.maxMobs = maxMobs;
            this.spawnCooldown = 0;

            // These are set after construction
            this.player = null;
            this.world = null;
            this.onMobHitPlayer = null; // callback: () => void
            this.onMobKilled = null;    // callback: (mobType) => void
        }

        setPlayer(player) { this.player = player; }
        setWorld(world) { this.world = world; }
        setCallbacks(onMobHitPlayer, onMobKilled) {
            this.onMobHitPlayer = onMobHitPlayer;
            this.onMobKilled = onMobKilled;
        }

        update(dt, dayProgress) {
            this.updateMobs(dt);
            this.spawnMobs(dt, dayProgress);
        }

        updateMobs(dt) {
            if (!this.player || !this.world) return;

            for (let i = this.mobs.length - 1; i >= 0; i--) {
                const mob = this.mobs[i];
                const result = mob.update(this.world, this.player, dt);

                // Mob hit player
                if (result && result.hitPlayer && this.onMobHitPlayer) {
                    this.onMobHitPlayer();
                }

                // Remove dead mobs
                if (mob.isDead) {
                    this.mobs.splice(i, 1);
                }

                // Remove mobs too far from player
                const dist = Math.abs(mob.x - this.player.x);
                if (dist > 50) {
                    this.mobs.splice(i, 1);
                }
            }
        }

        spawnMobs(dt, dayProgress) {
            if (!this.player || !this.world) return;

            // Only spawn at night (dayProgress 0.75-1.0 and 0-0.25 is night)
            const isNight = dayProgress > 0.75 || dayProgress < 0.25;
            if (!isNight) return;

            // Cooldown between spawns
            this.spawnCooldown -= dt / 1000;
            if (this.spawnCooldown > 0) return;

            // Don't exceed max mobs
            if (this.mobs.length >= this.maxMobs) return;

            // Try to spawn a mob
            this.spawnCooldown = 3 + Math.random() * 5; // 3-8 seconds between spawns

            // Spawn off-screen but within reasonable distance
            const spawnSide = Math.random() < 0.5 ? -1 : 1;
            const spawnX = this.player.x + spawnSide * (15 + Math.random() * 10);

            // Find ground level at spawn point
            let spawnY = 0;
            for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                if (this.world.getBlock(Math.floor(spawnX), y).solid) {
                    spawnY = y - 1;
                    break;
                }
            }

            // Don't spawn underground (too deep)
            if (spawnY > this.player.y + 10) return;

            // Don't spawn if inside a block
            if (this.world.getBlock(Math.floor(spawnX), Math.floor(spawnY)).solid ||
                this.world.getBlock(Math.floor(spawnX), Math.floor(spawnY - 1)).solid) {
                return;
            }

            // Create the zombie
            const zombie = new Mob(spawnX, spawnY, 'zombie');
            this.mobs.push(zombie);
        }

        tryAttackMob(worldX, worldY, heldItem) {
            if (!this.player) return null;

            for (const mob of this.mobs) {
                if (mob.isDead) continue;

                if (mob.containsPoint(worldX, worldY)) {
                    // Calculate damage: use tool's damage value or default to 1 (fist)
                    const damage = heldItem?.damage ?? 1;

                    // Knockback direction (away from player)
                    const knockbackDir = mob.x > this.player.x ? 1 : -1;

                    // Deal damage
                    const died = mob.takeDamage(damage, knockbackDir);

                    if (died && this.onMobKilled) {
                        this.onMobKilled(mob.type);
                    }

                    return mob;
                }
            }
            return null;
        }

        render(ctx, screenWidth, screenHeight, cameraX, cameraY) {
            const blockSize = CONFIG.BLOCK_SIZE;
            const screenCenterX = screenWidth / 2;
            const screenCenterY = screenHeight / 2;

            for (const mob of this.mobs) {
                if (mob.isDead) continue;

                const px = screenCenterX + (mob.x - cameraX) * blockSize;
                const py = screenCenterY + (mob.y - cameraY) * blockSize;

                const w = mob.width * blockSize;
                const h = mob.height * blockSize;

                // Flash white when taking damage
                const isHurt = mob.invincibleTime > 0;

                // Body
                ctx.fillStyle = isHurt ? '#ffffff' : mob.color;
                ctx.fillRect(px - w/2, py - h * 0.7, w, h * 0.5);

                // Head
                ctx.fillStyle = isHurt ? '#ffffff' : '#4a8c4a';
                ctx.fillRect(px - w/2 * 0.9, py - h, w * 0.9, h * 0.35);

                // Eyes (red for zombie)
                ctx.fillStyle = '#ff0000';
                const eyeOffset = mob.facingRight ? 0.1 : -0.1;
                ctx.fillRect(px - w * 0.15 + w * eyeOffset, py - h * 0.9, w * 0.12, w * 0.08);
                ctx.fillRect(px + w * 0.05 + w * eyeOffset, py - h * 0.9, w * 0.12, w * 0.08);

                // Arms (reaching out)
                ctx.fillStyle = isHurt ? '#ffffff' : mob.color;
                const armDir = mob.facingRight ? 1 : -1;
                ctx.fillRect(px + armDir * w * 0.3, py - h * 0.6, w * 0.5 * armDir, h * 0.1);

                // Legs
                ctx.fillStyle = isHurt ? '#ffffff' : '#1a4a1a';
                ctx.fillRect(px - w/2, py - h * 0.2, w * 0.35, h * 0.2);
                ctx.fillRect(px + w/2 - w * 0.35, py - h * 0.2, w * 0.35, h * 0.2);

                // Health bar (if damaged)
                if (mob.health < mob.maxHealth) {
                    const barWidth = w;
                    const barHeight = 4;
                    const healthPercent = mob.health / mob.maxHealth;

                    ctx.fillStyle = '#333';
                    ctx.fillRect(px - barWidth/2, py - h - 10, barWidth, barHeight);
                    ctx.fillStyle = '#ff3333';
                    ctx.fillRect(px - barWidth/2, py - h - 10, barWidth * healthPercent, barHeight);
                }
            }
        }
    }

    // --- FURNACE SYSTEM ---
    class FurnaceSystem {
        constructor(dom, getItemTexture) {
            this.dom = dom;
            this.getItemTexture = getItemTexture;
            this.furnaces = new Map(); // Store furnace states by "x,y"
            this.isOpen = false;
            this.active = null; // Currently open furnace
            this.player = null; // Set by Game after player is created
            this.onUIUpdate = null; // Callback for when UI needs updating

            // Setup event handlers
            document.getElementById('furnaceClose').onclick = () => this.close();
            document.getElementById('furnaceOverlay').onclick = (e) => {
                if (e.target.id === 'furnaceOverlay') this.close();
            };
            document.getElementById('furnaceInput').onclick = () => this.handleSlotClick('input');
            document.getElementById('furnaceFuel').onclick = () => this.handleSlotClick('fuel');
            document.getElementById('furnaceOutput').onclick = () => this.handleSlotClick('output');
        }

        setPlayer(player) { this.player = player; }
        setUIUpdateCallback(callback) { this.onUIUpdate = callback; }

        // For save/load
        getState() { return Array.from(this.furnaces.entries()); }
        loadState(entries) { if (entries) this.furnaces = new Map(entries); }

        getOrCreate(x, y) {
            const key = `${x},${y}`;
            if (!this.furnaces.has(key)) {
                this.furnaces.set(key, {
                    x, y,
                    input: null, fuel: null, output: null,
                    progress: 0, burnTime: 0
                });
            }
            return this.furnaces.get(key);
        }

        open(x, y) {
            this.isOpen = true;
            this.active = this.getOrCreate(x, y);
            this.dom.furnaceOverlay.classList.add('show');
            this.updateUI();
        }

        close() {
            this.isOpen = false;
            this.active = null;
            this.dom.furnaceOverlay.classList.remove('show');
        }

        handleSlotClick(slotType) {
            if (!this.active || !this.player) return;
            const selectedSlot = this.player.inventory[this.player.selectedSlot];
            const selectedItem = selectedSlot ? getItemById(selectedSlot.itemId) : null;

            if (slotType === 'input') {
                if (selectedItem) {
                    const recipe = SMELT_BY_INPUT.get(selectedSlot.itemId);
                    if (recipe) {
                        if (!this.active.input) {
                            this.active.input = { itemId: selectedSlot.itemId, count: selectedSlot.count };
                            this.player.inventory[this.player.selectedSlot] = null;
                        } else if (this.active.input.itemId === selectedSlot.itemId) {
                            this.active.input.count += selectedSlot.count;
                            this.player.inventory[this.player.selectedSlot] = null;
                        }
                    }
                } else if (this.active.input) {
                    const item = getItemById(this.active.input.itemId);
                    if (this.player.addToInventory(item, this.active.input.count) === 0) {
                        this.active.input = null;
                    }
                }
            } else if (slotType === 'fuel') {
                if (selectedItem && selectedSlot.itemId === ITEMS.COAL.id) {
                    if (!this.active.fuel) {
                        this.active.fuel = { itemId: selectedSlot.itemId, count: selectedSlot.count };
                        this.player.inventory[this.player.selectedSlot] = null;
                    } else if (this.active.fuel.itemId === selectedSlot.itemId) {
                        this.active.fuel.count += selectedSlot.count;
                        this.player.inventory[this.player.selectedSlot] = null;
                    }
                } else if (!selectedItem && this.active.fuel) {
                    const item = getItemById(this.active.fuel.itemId);
                    if (this.player.addToInventory(item, this.active.fuel.count) === 0) {
                        this.active.fuel = null;
                    }
                }
            } else if (slotType === 'output') {
                if (this.active.output) {
                    const item = getItemById(this.active.output.itemId);
                    if (this.player.addToInventory(item, this.active.output.count) === 0) {
                        this.active.output = null;
                    }
                }
            }
            this.updateUI();
            if (this.onUIUpdate) this.onUIUpdate();
        }

        updateUI() {
            if (!this.active) return;

            const renderSlot = (slotEl, slotData) => {
                slotEl.innerHTML = '';
                if (slotData) {
                    const item = getItemById(slotData.itemId);
                    const canvas = document.createElement('canvas');
                    canvas.width = 32;
                    canvas.height = 32;
                    const texture = this.getItemTexture(item, 32);
                    if (texture) {
                        canvas.getContext('2d').drawImage(texture, 0, 0, 32, 32);
                    }
                    slotEl.appendChild(canvas);
                    if (slotData.count > 1) {
                        const countEl = document.createElement('span');
                        countEl.className = 'slot-count';
                        countEl.textContent = slotData.count;
                        slotEl.appendChild(countEl);
                    }
                }
            };

            renderSlot(this.dom.furnaceInput, this.active.input);
            renderSlot(this.dom.furnaceFuel, this.active.fuel);
            renderSlot(this.dom.furnaceOutput, this.active.output);

            const { furnaceFire: fireEl, furnaceArrow: arrowEl, furnaceProgress: progressEl } = this.dom;
            if (this.active.burnTime > 0) {
                fireEl.classList.add('burning');
                arrowEl.classList.add('active');
            } else {
                fireEl.classList.remove('burning');
                arrowEl.classList.remove('active');
            }
            progressEl.style.width = (this.active.progress * 100) + '%';
        }

        update(dt, world) {
            const dtSeconds = dt / 1000;

            for (const furnace of this.furnaces.values()) {
                // Check if furnace block still exists
                const block = world.getBlock(furnace.x, furnace.y);
                if (block.id !== BLOCKS.FURNACE.id) {
                    this.furnaces.delete(`${furnace.x},${furnace.y}`);
                    continue;
                }

                if (furnace.input && furnace.input.count > 0) {
                    const recipe = SMELT_BY_INPUT.get(furnace.input.itemId);
                    if (recipe) {
                        const canOutput = !furnace.output ||
                            (furnace.output.itemId === recipe.output.id && furnace.output.count < 64);

                        if (canOutput) {
                            // Try to consume fuel
                            if (furnace.burnTime <= 0 && furnace.fuel && furnace.fuel.count > 0) {
                                furnace.fuel.count--;
                                if (furnace.fuel.count <= 0) furnace.fuel = null;
                                furnace.burnTime = 80;
                            }

                            // Smelt if we have fuel burning
                            if (furnace.burnTime > 0) {
                                furnace.burnTime -= dtSeconds;
                                furnace.progress += dtSeconds / recipe.time;

                                if (furnace.progress >= 1) {
                                    furnace.progress = 0;
                                    furnace.input.count--;
                                    if (furnace.input.count <= 0) furnace.input = null;

                                    if (!furnace.output) {
                                        furnace.output = { itemId: recipe.output.id, count: 1 };
                                    } else {
                                        furnace.output.count++;
                                    }
                                }
                            }
                        }
                    }
                } else {
                    furnace.progress = 0;
                }

                // Burn down fuel even if not smelting
                if (furnace.burnTime > 0 && !furnace.input) {
                    furnace.burnTime -= dtSeconds;
                }
            }

            // Update UI if open
            if (this.isOpen && this.active) {
                this.updateUI();
            }
        }
    }

    // --- CRAFTING SYSTEM ---
    class CraftingSystem {
        constructor(dom, getItemTexture) {
            this.dom = dom;
            this.getItemTexture = getItemTexture;
            this.isOpen = false;
            this.player = null;
            this.onUIUpdate = null;
            this.onNotification = null;

            // Setup event handlers
            document.getElementById('craftingClose').onclick = () => this.close();
            document.getElementById('craftingOverlay').onclick = (e) => {
                if (e.target.id === 'craftingOverlay') this.close();
            };
        }

        setPlayer(player) { this.player = player; }
        setCallbacks(onUIUpdate, onNotification) {
            this.onUIUpdate = onUIUpdate;
            this.onNotification = onNotification;
        }

        toggle() {
            if (this.isOpen) this.close();
            else this.open();
        }

        open() {
            this.isOpen = true;
            this.dom.craftingOverlay.classList.add('show');
            this.renderRecipes();
        }

        close() {
            this.isOpen = false;
            this.dom.craftingOverlay.classList.remove('show');
        }

        countItem(itemId) {
            let count = 0;
            for (const slot of this.player.inventory) {
                if (slot && slot.itemId === itemId) count += slot.count;
            }
            return count;
        }

        canCraft(recipe) {
            for (const ingredient of recipe.ingredients) {
                if (this.countItem(ingredient.item.id) < ingredient.count) return false;
            }
            return true;
        }

        consumeIngredients(recipe) {
            for (const ingredient of recipe.ingredients) {
                let remaining = ingredient.count;
                for (let i = 0; i < this.player.inventory.length && remaining > 0; i++) {
                    const slot = this.player.inventory[i];
                    if (slot && slot.itemId === ingredient.item.id) {
                        const take = Math.min(slot.count, remaining);
                        slot.count -= take;
                        remaining -= take;
                        if (slot.count <= 0) this.player.inventory[i] = null;
                    }
                }
            }
        }

        craft(recipe) {
            if (!this.canCraft(recipe)) return false;

            const result = recipe.result;
            const resultCount = recipe.resultCount;

            // Test if result fits (virtual inventory check)
            const testInv = structuredClone(this.player.inventory);

            // Virtually consume ingredients
            for (const ingredient of recipe.ingredients) {
                let remaining = ingredient.count;
                for (let i = 0; i < testInv.length && remaining > 0; i++) {
                    const slot = testInv[i];
                    if (slot && slot.itemId === ingredient.item.id) {
                        const take = Math.min(slot.count, remaining);
                        slot.count -= take;
                        remaining -= take;
                        if (slot.count <= 0) testInv[i] = null;
                    }
                }
            }

            // Check if result fits
            let canFit = false;
            const canStack = result.stackable !== false;
            const maxStack = canStack ? 64 : 1;

            if (canStack) {
                for (const slot of testInv) {
                    if (slot && slot.itemId === result.id && slot.count + resultCount <= maxStack) {
                        canFit = true;
                        break;
                    }
                }
            }
            if (!canFit) {
                for (const slot of testInv) {
                    if (!slot) { canFit = true; break; }
                }
            }

            if (!canFit) {
                if (this.onNotification) this.onNotification('Inventory full!');
                return false;
            }

            // Actually craft
            this.consumeIngredients(recipe);
            this.player.addToInventory(result, resultCount);
            if (this.onUIUpdate) this.onUIUpdate();
            this.renderRecipes();
            return true;
        }

        renderRecipes() {
            const container = this.dom.craftingRecipes;
            container.innerHTML = '';

            // Group recipes by category
            const categories = {
                'Materials': [], 'Wood Tools': [], 'Stone Tools': [],
                'Iron Tools': [], 'Diamond Tools': [], 'Blocks': []
            };

            for (const recipe of RECIPES) {
                const result = recipe.result;
                if (result.id === ITEMS.STICK?.id || result.id === BLOCKS.PLANKS?.id) {
                    categories['Materials'].push(recipe);
                } else if (result.tier === 'wood') {
                    categories['Wood Tools'].push(recipe);
                } else if (result.tier === 'stone') {
                    categories['Stone Tools'].push(recipe);
                } else if (result.tier === 'iron') {
                    categories['Iron Tools'].push(recipe);
                } else if (result.tier === 'diamond') {
                    categories['Diamond Tools'].push(recipe);
                } else {
                    categories['Blocks'].push(recipe);
                }
            }

            for (const [category, recipes] of Object.entries(categories)) {
                if (recipes.length === 0) continue;

                const section = document.createElement('div');
                section.className = 'craft-section';
                section.innerHTML = `<h3>${category}</h3>`;

                const grid = document.createElement('div');
                grid.className = 'recipe-grid';

                for (const recipe of recipes) {
                    const canCraft = this.canCraft(recipe);
                    const item = document.createElement('div');
                    item.className = 'recipe-item' + (canCraft ? ' can-craft' : '');

                    // Header with icon and name
                    const header = document.createElement('div');
                    header.className = 'recipe-header';

                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'recipe-icon';
                    const texture = this.getItemTexture(recipe.result, 32);
                    if (texture) {
                        const img = document.createElement('canvas');
                        img.width = 24; img.height = 24;
                        img.getContext('2d').drawImage(texture, 0, 0, 24, 24);
                        iconDiv.appendChild(img);
                    }
                    header.appendChild(iconDiv);

                    const nameDiv = document.createElement('div');
                    nameDiv.innerHTML = `<div class="recipe-name">${recipe.name}</div>` +
                        (recipe.resultCount > 1 ? `<div class="recipe-count">x${recipe.resultCount}</div>` : '');
                    header.appendChild(nameDiv);
                    item.appendChild(header);

                    // Ingredients
                    const ingredientsDiv = document.createElement('div');
                    ingredientsDiv.className = 'recipe-ingredients';

                    for (const ing of recipe.ingredients) {
                        const ingDiv = document.createElement('div');
                        ingDiv.className = 'ingredient';

                        const ingTexture = this.getItemTexture(ing.item, 16);
                        if (ingTexture) {
                            const ingImg = document.createElement('canvas');
                            ingImg.className = 'ingredient-icon';
                            ingImg.width = 16; ingImg.height = 16;
                            ingImg.getContext('2d').drawImage(ingTexture, 0, 0, 16, 16);
                            ingDiv.appendChild(ingImg);
                        }

                        const hasCount = this.countItem(ing.item.id);
                        const hasEnough = hasCount >= ing.count;
                        const textSpan = document.createElement('span');
                        textSpan.className = 'ingredient-text ' + (hasEnough ? 'has-enough' : 'not-enough');
                        textSpan.textContent = `${hasCount}/${ing.count}`;
                        ingDiv.appendChild(textSpan);
                        ingredientsDiv.appendChild(ingDiv);
                    }

                    item.appendChild(ingredientsDiv);
                    item.onclick = () => this.craft(recipe);
                    grid.appendChild(item);
                }

                section.appendChild(grid);
                container.appendChild(section);
            }
        }
    }

    // --- GAME ---
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');

            this.resize();
            window.addEventListener('resize', () => this.resize());

            // Cache DOM elements early (before any showNotification calls)
            this.dom = {
                fps: document.getElementById('fps'),
                position: document.getElementById('position'),
                timeDisplay: document.getElementById('timeDisplay'),
                deathScreen: document.getElementById('deathScreen'),
                miningProgress: document.getElementById('miningProgress'),
                miningFill: document.querySelector('#miningProgress .fill'),
                damageOverlay: document.getElementById('damageOverlay'),
                healthBar: document.getElementById('healthBar'),
                saveNotification: document.getElementById('saveNotification'),
                craftingOverlay: document.getElementById('craftingOverlay'),
                craftingRecipes: document.getElementById('craftingRecipes'),
                furnaceOverlay: document.getElementById('furnaceOverlay'),
                furnaceInput: document.getElementById('furnaceInput'),
                furnaceFuel: document.getElementById('furnaceFuel'),
                furnaceOutput: document.getElementById('furnaceOutput'),
                furnaceFire: document.getElementById('furnaceFire'),
                furnaceArrow: document.getElementById('furnaceArrow'),
                furnaceProgress: document.getElementById('furnaceProgress'),
                touchCrosshair: document.getElementById('touchCrosshair'),
            };

            // Try to load saved game
            const saveData = this.loadGame();

            // Generate world (with saved seed if available)
            const seed = saveData ? saveData.seed : undefined;
            this.world = new World(CONFIG.WORLD_WIDTH, CONFIG.WORLD_HEIGHT, seed);

            if (saveData) {
                // Restore saved game
                console.log('Restoring saved game...');

                // Restore world modifications
                this.world.modifiedBlocks = new Map(saveData.world.modifiedBlocks);

                // Restore player
                this.player = new Player(saveData.player.x, saveData.player.y);

                // Migrate old inventory format (blockId -> itemId)
                const migratedInventory = saveData.player.inventory.map(slot => {
                    if (!slot) return null;
                    // Handle old format with blockId
                    if (slot.blockId !== undefined && slot.itemId === undefined) {
                        return { itemId: slot.blockId, count: slot.count };
                    }
                    return slot;
                });
                this.player.inventory = migratedInventory;
                this.player.selectedSlot = saveData.player.selectedSlot;
                this.player.health = saveData.player.health ?? this.player.maxHealth;

                // Restore time
                this.gameTime = saveData.gameTime || 0;

                // Restore furnaces (will be applied after furnaces Map is created)
                this._savedFurnaces = saveData.furnaces;

                this.showNotification('Game Loaded');
            } else {
                // New game - find spawn point
                const spawnX = Math.floor(CONFIG.WORLD_WIDTH / 2);
                let spawnY = 0;
                for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                    if (this.world.getBlock(spawnX, y).solid) {
                        spawnY = y - 1;
                        break;
                    }
                }

                this.player = new Player(spawnX + 0.5, spawnY);

                // Generate some trees near spawn (but not AT spawn)
                for (let i = -10; i < 10; i++) {
                    const tx = spawnX + i * 8 + Math.floor(Math.random() * 4);

                    // Skip trees too close to spawn point to avoid trapping player
                    if (Math.abs(tx - spawnX) < 4) continue;

                    let ty = 0;
                    for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                        if (this.world.getBlock(tx, y).id === BLOCKS.GRASS.id) {
                            ty = y;
                            break;
                        }
                    }
                    if (ty > 0 && Math.random() < 0.6) {
                        this.world.generateTree(tx, ty);
                    }
                }

                // Clear spawn area (in case of any obstructions)
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -3; dy <= 0; dy++) {
                        const block = this.world.getBlock(spawnX + dx, spawnY + dy);
                        if (block.solid && block.id !== BLOCKS.BEDROCK.id) {
                            this.world.setBlock(spawnX + dx, spawnY + dy, BLOCKS.AIR);
                        }
                    }
                }

                this.gameTime = 0;
            }

            // Camera
            this.cameraX = this.player.x;
            this.cameraY = this.player.y;

            // Input
            this.keys = { left: false, right: false, jump: false };
            this.mouse = { x: 0, y: 0, left: false, right: false };
            this.setupInput();

            // Mining
            this.mining = { active: false, x: 0, y: 0, progress: 0, target: null };

            // Mob System
            this.mobSystem = new MobSystem(8);
            this.mobSystem.setPlayer(this.player);
            this.mobSystem.setWorld(this.world);
            this.mobSystem.setCallbacks(
                () => { this.showDamageEffect(); this.updateHealthBar(); },
                (mobType) => this.showNotification(`${mobType.charAt(0).toUpperCase() + mobType.slice(1)} slain!`)
            );

            // Crafting System
            this.craftingSystem = new CraftingSystem(this.dom, this.getItemTexture.bind(this));
            this.craftingSystem.setPlayer(this.player);
            this.craftingSystem.setCallbacks(() => this.updateUI(), (msg) => this.showNotification(msg));

            // Furnace System
            this.furnaceSystem = new FurnaceSystem(this.dom, this.getItemTexture.bind(this));
            this.furnaceSystem.setPlayer(this.player);
            this.furnaceSystem.setUIUpdateCallback(() => this.updateUI());
            if (this._savedFurnaces) {
                this.furnaceSystem.loadState(this._savedFurnaces);
                delete this._savedFurnaces;
            }

            // Touch controls
            this.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            this.touchMode = 'mine'; // 'mine' or 'place'
            if (this.isTouchDevice) {
                document.body.classList.add('touch-visible');
                this.setupTouchControls();
            }

            // Day/night cycle
            this.dayProgress = (this.gameTime / CONFIG.DAY_LENGTH) % 1;
            if (this.dayProgress === 0) this.dayProgress = 0.25; // Start at morning for new games

            // FPS
            this.frameCount = 0;
            this.lastFpsUpdate = Date.now();
            this.fps = 0;

            // Preload textures
            for (const key of Object.keys(BLOCKS)) {
                if (key !== 'AIR') {
                    TextureGenerator.createTexture(key);
                }
            }

            // Preload tool textures
            for (const key of Object.keys(TOOLS)) {
                TextureGenerator.createToolTexture(key);
            }

            // Preload item textures
            for (const key of Object.keys(ITEMS)) {
                TextureGenerator.createItemTexture(key);
            }

            // UI
            this.setupUI();
            this.updateHealthBar();

            // Respawn button handler
            document.getElementById('respawnBtn').onclick = () => this.respawnPlayer();

            // Auto-save every 30 seconds
            this.autoSaveInterval = setInterval(() => this.saveGame(), 30000);

            // Save on page unload
            window.addEventListener('beforeunload', () => this.saveGame());

            // Start game loop
            this.lastTime = performance.now();
            this.loop();
        }

        resize() {
            // Support high-DPI/retina displays
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = Math.floor(window.innerWidth * dpr);
            this.canvas.height = Math.floor(window.innerHeight * dpr);
            this.canvas.style.width = window.innerWidth + 'px';
            this.canvas.style.height = window.innerHeight + 'px';
            this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            this.ctx.imageSmoothingEnabled = false;
            this.dpr = dpr;
            // Store CSS pixel dimensions for rendering calculations
            this.screenWidth = window.innerWidth;
            this.screenHeight = window.innerHeight;

            // Create/update star canvas for night sky (avoids 100 arc calls per frame)
            this.createStarCanvas();
        }

        createStarCanvas() {
            // Create offscreen canvas for stars
            if (!this.starCanvas) {
                this.starCanvas = document.createElement('canvas');
                this.starCtx = this.starCanvas.getContext('2d');
            }
            this.starCanvas.width = this.screenWidth;
            this.starCanvas.height = this.screenHeight;
            this.lastStarSeed = null; // Force redraw on next render
        }

        renderStarsToCanvas(starSeed) {
            // Only redraw if seed changed (camera moved significantly)
            if (this.lastStarSeed === starSeed) return;
            this.lastStarSeed = starSeed;

            const ctx = this.starCtx;
            ctx.clearRect(0, 0, this.starCanvas.width, this.starCanvas.height);
            ctx.fillStyle = 'white';

            for (let i = 0; i < 100; i++) {
                const sx = ((i * 7919 + starSeed * 104729) % 1000) / 1000 * this.starCanvas.width;
                const sy = ((i * 7901 + starSeed * 104723) % 1000) / 1000 * this.starCanvas.height * 0.6;
                const size = ((i * 7907) % 3) + 1;
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        setupInput() {
            document.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'KeyA':
                    case 'ArrowLeft':
                        this.keys.left = true;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        this.keys.right = true;
                        break;
                    case 'KeyW':
                    case 'ArrowUp':
                    case 'Space':
                        this.keys.jump = true;
                        e.preventDefault();
                        break;
                    case 'Digit1': case 'Digit2': case 'Digit3':
                    case 'Digit4': case 'Digit5': case 'Digit6':
                    case 'Digit7': case 'Digit8': case 'Digit9':
                        this.player.selectedSlot = parseInt(e.code.slice(-1)) - 1;
                        this.updateUI();
                        break;
                    case 'KeyP':
                        // Manual save
                        this.saveGame();
                        break;
                    case 'KeyN':
                        // New game (delete save and reload)
                        if (confirm('Start a new game? Your current progress will be lost.')) {
                            this.deleteSave();
                            location.reload();
                        }
                        break;
                    case 'KeyE':
                        // Toggle crafting menu
                        this.craftingSystem.toggle();
                        break;
                    case 'Escape':
                        // Close menus
                        if (this.craftingSystem.isOpen) {
                            this.craftingSystem.close();
                        }
                        if (this.furnaceSystem.isOpen) {
                            this.furnaceSystem.close();
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyA':
                    case 'ArrowLeft':
                        this.keys.left = false;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        this.keys.right = false;
                        break;
                    case 'KeyW':
                    case 'ArrowUp':
                    case 'Space':
                        this.keys.jump = false;
                        break;
                }
            });

            this.canvas.addEventListener('mousemove', (e) => {
                this.mouse.x = e.clientX;
                this.mouse.y = e.clientY;
            });

            this.canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (e.button === 0) this.mouse.left = true;
                if (e.button === 2) this.mouse.right = true;
            });

            this.canvas.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    this.mouse.left = false;
                    this.mining.active = false;
                }
                if (e.button === 2) this.mouse.right = false;
            });

            this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            this.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY > 0) {
                    this.player.selectedSlot = (this.player.selectedSlot + 1) % 9;
                } else {
                    this.player.selectedSlot = (this.player.selectedSlot - 1 + 9) % 9;
                }
                this.updateUI();
            });
        }

        setupTouchControls() {
            const buttons = document.querySelectorAll('.touch-btn');
            const modeBtn = document.querySelector('.mode-btn');
            const modeLabel = document.getElementById('modeLabel');
            const crosshair = document.getElementById('touchCrosshair');

            // Prevent default touch behaviors on canvas
            this.canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
            this.canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

            // Handle button touches
            buttons.forEach(btn => {
                const action = btn.dataset.action;

                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    btn.classList.add('active');

                    if (action === 'left') this.keys.left = true;
                    else if (action === 'right') this.keys.right = true;
                    else if (action === 'jump') this.keys.jump = true;
                    else if (action === 'mode') {
                        // Toggle mine/place mode
                        this.touchMode = this.touchMode === 'mine' ? 'place' : 'mine';
                        modeLabel.textContent = this.touchMode === 'mine' ? 'Mine' : 'Place';
                        modeBtn.textContent = this.touchMode === 'mine' ? '\u26CF' : '\u25A3';
                        modeBtn.classList.toggle('place-mode', this.touchMode === 'place');
                    }
                }, { passive: false });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    btn.classList.remove('active');

                    if (action === 'left') this.keys.left = false;
                    else if (action === 'right') this.keys.right = false;
                    else if (action === 'jump') this.keys.jump = false;
                }, { passive: false });

                btn.addEventListener('touchcancel', (e) => {
                    btn.classList.remove('active');
                    if (action === 'left') this.keys.left = false;
                    else if (action === 'right') this.keys.right = false;
                    else if (action === 'jump') this.keys.jump = false;
                });
            });

            // Handle canvas touch for mining/placing
            let touchHoldTimer = null;
            let isTouchingCanvas = false;

            this.canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    isTouchingCanvas = true;

                    // Update mouse position for block targeting
                    this.mouse.x = touch.clientX;
                    this.mouse.y = touch.clientY;

                    // Update crosshair position
                    this.updateTouchCrosshair();

                    // Start hold timer for mining
                    if (this.touchMode === 'mine') {
                        touchHoldTimer = setTimeout(() => {
                            if (isTouchingCanvas) {
                                this.mouse.left = true;
                            }
                        }, 150); // Small delay to distinguish tap from hold
                    }
                }
            }, { passive: false });

            this.canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isTouchingCanvas) {
                    const touch = e.touches[0];
                    this.mouse.x = touch.clientX;
                    this.mouse.y = touch.clientY;
                    this.updateTouchCrosshair();
                }
            }, { passive: false });

            this.canvas.addEventListener('touchend', (e) => {
                if (touchHoldTimer) {
                    clearTimeout(touchHoldTimer);
                    touchHoldTimer = null;
                }

                if (isTouchingCanvas && e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];

                    // If it was a quick tap and in place mode, place a block
                    if (this.touchMode === 'place' && !this.mouse.left) {
                        this.mouse.x = touch.clientX;
                        this.mouse.y = touch.clientY;
                        this.mouse.right = true;
                        // Reset after a frame
                        setTimeout(() => { this.mouse.right = false; }, 50);
                    }

                    this.mouse.left = false;
                    this.mining.active = false;
                    isTouchingCanvas = false;
                }
            }, { passive: false });

            this.canvas.addEventListener('touchcancel', () => {
                if (touchHoldTimer) {
                    clearTimeout(touchHoldTimer);
                    touchHoldTimer = null;
                }
                this.mouse.left = false;
                this.mining.active = false;
                isTouchingCanvas = false;
            });

            // Initial crosshair position (center of screen)
            this.mouse.x = window.innerWidth / 2;
            this.mouse.y = window.innerHeight / 2;
            this.updateTouchCrosshair();
        }

        updateTouchCrosshair() {
            const crosshair = this.dom.touchCrosshair;
            const blockSize = CONFIG.BLOCK_SIZE;

            // Snap crosshair to block grid
            const target = this.getBlockAtMouse();
            const screenCenterX = this.screenWidth / 2;
            const screenCenterY = this.screenHeight / 2;

            const screenX = screenCenterX + (target.x - this.cameraX) * blockSize;
            const screenY = screenCenterY + (target.y - this.cameraY) * blockSize;

            crosshair.style.left = screenX + 'px';
            crosshair.style.top = screenY + 'px';
            crosshair.style.width = blockSize + 'px';
            crosshair.style.height = blockSize + 'px';
        }

        setupUI() {
            const ui = document.getElementById('ui');
            ui.innerHTML = '';

            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'slot' + (i === this.player.selectedSlot ? ' selected' : '');
                slot.innerHTML = `<span class="slot-key">${i + 1}</span><span class="slot-count"></span>`;
                slot.onclick = () => {
                    this.player.selectedSlot = i;
                    this.updateUI();
                };
                ui.appendChild(slot);
            }

            this.updateUI();
        }

        updateUI() {
            const slots = document.querySelectorAll('.slot');

            slots.forEach((slot, i) => {
                slot.className = 'slot' + (i === this.player.selectedSlot ? ' selected' : '');

                const item = this.player.inventory[i];
                const countEl = slot.querySelector('.slot-count');

                // Clear previous preview
                const existingPreview = slot.querySelector('.block-preview');
                if (existingPreview) existingPreview.remove();

                if (item) {
                    const itemData = getItemById(item.itemId);
                    const preview = document.createElement('canvas');
                    preview.className = 'block-preview';
                    preview.width = 32;
                    preview.height = 32;
                    preview.style.width = '32px';
                    preview.style.height = '32px';

                    const texture = this.getItemTexture(itemData, 32);
                    if (texture) {
                        preview.getContext('2d').drawImage(texture, 0, 0, 32, 32);
                    }

                    slot.insertBefore(preview, countEl);
                    countEl.textContent = item.count > 1 ? item.count : '';
                } else {
                    countEl.textContent = '';
                }
            });
        }

        // Get texture for any item (block, tool, or material)
        getItemTexture(item, size = 32) {
            if (!item) return null;
            if (TOOL_BY_ID[item.id]) {
                return TextureGenerator.createToolTexture(item.key, size);
            } else if (ITEM_BY_ID[item.id]) {
                return TextureGenerator.createItemTexture(item.key, size);
            } else {
                return TextureGenerator.createTexture(item.key, size);
            }
        }

        getBlockAtMouse() {
            const blockSize = CONFIG.BLOCK_SIZE;
            const screenCenterX = this.screenWidth / 2;
            const screenCenterY = this.screenHeight / 2;

            const worldX = this.cameraX + (this.mouse.x - screenCenterX) / blockSize;
            const worldY = this.cameraY + (this.mouse.y - screenCenterY) / blockSize;

            return {
                x: Math.floor(worldX),
                y: Math.floor(worldY),
                worldX,
                worldY
            };
        }

        handleBlockInteraction(dt) {
            const target = this.getBlockAtMouse();
            const dx = target.worldX - this.player.x;
            const dy = target.worldY - (this.player.y - this.player.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > CONFIG.REACH_DISTANCE) {
                this.mining.active = false;
                return;
            }

            // Left click - attack mobs or mine blocks
            if (this.mouse.left) {
                // Check if clicking on a mob first
                const attackedMob = this.mobSystem.tryAttackMob(target.worldX, target.worldY, this.player.getHeldItem());
                if (attackedMob) {
                    this.player.startSwing();
                    // Don't mine while attacking
                    this.mining.active = false;
                    this.dom.miningProgress.style.display = 'none';
                    return;
                }

                const block = this.world.getBlock(target.x, target.y);

                if (block.id !== BLOCKS.AIR.id && block.hardness !== Infinity) {
                    if (!this.mining.active || this.mining.x !== target.x || this.mining.y !== target.y) {
                        this.mining = {
                            active: true,
                            x: target.x,
                            y: target.y,
                            progress: 0,
                            target: block
                        };
                    }

                    // Start swing animation when mining
                    this.player.startSwing();

                    // Apply tool speed multiplier
                    const miningSpeed = this.player.getMiningSpeed(block);
                    this.mining.progress += (dt / (block.hardness * 1000)) * miningSpeed;

                    // Update mining progress bar
                    const progressBar = this.dom.miningProgress;
                    const fill = this.dom.miningFill;
                    progressBar.style.display = 'block';
                    progressBar.style.left = this.mouse.x - 20 + 'px';
                    progressBar.style.top = this.mouse.y + 20 + 'px';
                    fill.style.width = Math.min(100, this.mining.progress * 100) + '%';

                    if (this.mining.progress >= 1) {
                        // Check if tool can harvest this block (for ores with tier requirements)
                        if (this.player.canHarvest(block) && !block.dropsNothing) {
                            // Determine what to drop
                            let dropItem;
                            if (block.dropsItem) {
                                // Drops a specific item (like coal from coal ore)
                                dropItem = getItemById(block.dropsItem);
                            } else if (block.drops) {
                                // Drops a different block (like cobblestone from stone)
                                dropItem = BLOCKS[block.drops];
                            } else {
                                // Drops itself
                                dropItem = block;
                            }
                            if (dropItem) {
                                this.player.addToInventory(dropItem);
                            }

                            // Check for random bonus drops (like apples from leaves)
                            if (block.randomDrop && Math.random() < block.randomDrop.chance) {
                                const bonusItem = getItemById(block.randomDrop.itemId);
                                if (bonusItem) {
                                    this.player.addToInventory(bonusItem);
                                    this.showNotification('Found an apple!');
                                }
                            }
                        }
                        // Block breaks either way, but no drops if wrong tool tier or dropsNothing
                        this.world.setBlock(target.x, target.y, BLOCKS.AIR);
                        this.mining.active = false;
                        progressBar.style.display = 'none';
                        this.updateUI();
                    }
                }
            } else {
                this.mining.active = false;
                this.dom.miningProgress.style.display = 'none';
            }

            // Right click - place, interact, or eat
            if (this.mouse.right) {
                this.mouse.right = false; // Single action per click

                const currentBlock = this.world.getBlock(target.x, target.y);

                // Check for interactive blocks first (like furnace)
                if (currentBlock.interactive) {
                    if (currentBlock.id === BLOCKS.FURNACE.id) {
                        this.furnaceSystem.open(target.x, target.y);
                    }
                    return;
                }

                // Check if holding food - eat it
                const heldItem = this.player.getHeldItem();
                if (heldItem && heldItem.food) {
                    // Only eat if not at full health
                    if (this.player.health < this.player.maxHealth) {
                        this.player.heal(heldItem.healAmount);
                        this.player.removeFromInventory(this.player.selectedSlot);
                        this.updateUI();
                        this.updateHealthBar();
                        this.showNotification(`+${heldItem.healAmount} HP`);
                    } else {
                        this.showNotification('Already at full health!');
                    }
                    return;
                }

                // Place block if target is air
                if (currentBlock.id === BLOCKS.AIR.id) {
                    const selectedBlock = this.player.getSelectedBlock();
                    if (selectedBlock) {
                        // Check not placing inside player
                        const playerBlocks = [
                            { x: Math.floor(this.player.x), y: Math.floor(this.player.y) },
                            { x: Math.floor(this.player.x), y: Math.floor(this.player.y - 1) }
                        ];

                        const isPlayerPos = playerBlocks.some(pb => pb.x === target.x && pb.y === target.y);

                        if (!isPlayerPos) {
                            this.world.setBlock(target.x, target.y, selectedBlock);
                            this.player.removeFromInventory(this.player.selectedSlot);
                            this.updateUI();
                        }
                    }
                }
            }
        }

        update(dt) {
            // Clamp dt to prevent huge physics jumps after tab switch (centralized)
            dt = Math.min(dt, CONFIG.MAX_DT);

            // Check for death
            if (this.player.isDead) {
                this.dom.deathScreen.classList.add('show');
                return;
            }

            // Update player and check for fall damage
            const fallDamage = this.player.update(this.world, this.keys, dt);

            // Update swing animation
            this.player.updateSwing(dt);

            // Show damage effect
            if (fallDamage > 0) {
                this.showDamageEffect();
            }

            // Update health bar
            this.updateHealthBar();

            // Check for death after damage
            if (this.player.isDead) {
                this.dom.deathScreen.classList.add('show');
                return;
            }

            // Smooth camera follow
            const smoothing = 0.1;
            this.cameraX += (this.player.x - this.cameraX) * smoothing;
            this.cameraY += (this.player.y - this.player.height / 2 - this.cameraY) * smoothing;

            // Handle block interactions
            this.handleBlockInteraction(dt);

            // Update furnaces
            this.furnaceSystem.update(dt, this.world);

            // Update mobs
            this.mobSystem.update(dt, this.dayProgress);

            // Update time
            this.gameTime += dt / 1000;
            this.dayProgress = (this.gameTime / CONFIG.DAY_LENGTH) % 1;
        }

        showDamageEffect() {
            const overlay = this.dom.damageOverlay;
            overlay.classList.add('flash');
            setTimeout(() => overlay.classList.remove('flash'), 150);
        }

        updateHealthBar() {
            const healthBar = this.dom.healthBar;
            const hearts = Math.ceil(this.player.maxHealth / 2); // 10 hearts for 20 HP

            // Build hearts HTML if needed
            if (healthBar.children.length !== hearts) {
                healthBar.innerHTML = '';
                for (let i = 0; i < hearts; i++) {
                    const heart = document.createElement('div');
                    heart.className = 'heart';
                    healthBar.appendChild(heart);
                }
            }

            // Update heart states
            const fullHearts = Math.floor(this.player.health / 2);
            const hasHalfHeart = this.player.health % 2 === 1;

            for (let i = 0; i < hearts; i++) {
                const heart = healthBar.children[i];
                heart.classList.remove('empty', 'half');

                if (i < fullHearts) {
                    // Full heart
                } else if (i === fullHearts && hasHalfHeart) {
                    heart.classList.add('half');
                } else {
                    heart.classList.add('empty');
                }
            }
        }

        respawnPlayer() {
            // Find spawn point
            const spawnX = Math.floor(CONFIG.WORLD_WIDTH / 2);
            let spawnY = 0;
            for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                if (this.world.getBlock(spawnX, y).solid) {
                    spawnY = y - 1;
                    break;
                }
            }

            this.player.respawn(spawnX + 0.5, spawnY);
            this.cameraX = this.player.x;
            this.cameraY = this.player.y;

            this.dom.deathScreen.classList.remove('show');
            this.updateHealthBar();
        }

        render() {
            const ctx = this.ctx;
            const blockSize = CONFIG.BLOCK_SIZE;
            const screenCenterX = this.screenWidth / 2;
            const screenCenterY = this.screenHeight / 2;

            // Sky gradient based on time of day
            this.renderSky();

            // Calculate visible range
            const viewWidth = Math.ceil(this.screenWidth / blockSize) + 2;
            const viewHeight = Math.ceil(this.screenHeight / blockSize) + 2;

            const startX = Math.floor(this.cameraX - viewWidth / 2);
            const startY = Math.floor(this.cameraY - viewHeight / 2);

            // Render blocks
            for (let y = startY; y < startY + viewHeight; y++) {
                for (let x = startX; x < startX + viewWidth; x++) {
                    const block = this.world.getBlock(x, y);

                    if (block.id === BLOCKS.AIR.id) continue;

                    const screenX = screenCenterX + (x - this.cameraX) * blockSize;
                    const screenY = screenCenterY + (y - this.cameraY) * blockSize;

                    const texture = TextureGenerator.createTexture(block.key);
                    ctx.drawImage(texture, screenX, screenY, blockSize, blockSize);
                }
            }

            // Render player
            this.renderPlayer();

            // Render mobs
            this.mobSystem.render(this.ctx, this.screenWidth, this.screenHeight, this.cameraX, this.cameraY);

            // Highlight hovered block
            const target = this.getBlockAtMouse();
            const dx = target.worldX - this.player.x;
            const dy = target.worldY - (this.player.y - this.player.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= CONFIG.REACH_DISTANCE) {
                const block = this.world.getBlock(target.x, target.y);
                const screenX = screenCenterX + (target.x - this.cameraX) * blockSize;
                const screenY = screenCenterY + (target.y - this.cameraY) * blockSize;

                ctx.strokeStyle = block.id === BLOCKS.AIR.id ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, blockSize, blockSize);
                ctx.lineWidth = 1;

                // Mining crack overlay
                if (this.mining.active && this.mining.x === target.x && this.mining.y === target.y) {
                    ctx.fillStyle = `rgba(0,0,0,${this.mining.progress * 0.5})`;
                    ctx.fillRect(screenX, screenY, blockSize, blockSize);
                }
            }

            // Update info display
            this.dom.position.textContent =
                `${Math.floor(this.player.x)}, ${Math.floor(this.player.y)}`;

            const hour = Math.floor(this.dayProgress * 24);
            const isDay = hour >= 6 && hour < 18;
            this.dom.timeDisplay.textContent =
                `${hour.toString().padStart(2, '0')}:00 (${isDay ? 'Day' : 'Night'})`;

            // Update touch crosshair position (follows camera)
            if (this.isTouchDevice) {
                this.updateTouchCrosshair();
            }
        }

        renderSky() {
            const ctx = this.ctx;
            const hour = this.dayProgress * 24;

            let skyTop, skyBottom;

            if (hour >= 6 && hour < 8) {
                // Sunrise
                const t = (hour - 6) / 2;
                skyTop = this.lerpColor('#1a1a3e', '#87CEEB', t);
                skyBottom = this.lerpColor('#4a3060', '#e0f0ff', t);
            } else if (hour >= 8 && hour < 17) {
                // Day
                skyTop = '#87CEEB';
                skyBottom = '#e0f0ff';
            } else if (hour >= 17 && hour < 20) {
                // Sunset
                const t = (hour - 17) / 3;
                skyTop = this.lerpColor('#87CEEB', '#1a1a3e', t);
                skyBottom = this.lerpColor('#e0f0ff', '#4a3060', t);
            } else {
                // Night
                skyTop = '#0a0a1e';
                skyBottom = '#1a1a3e';
            }

            const gradient = ctx.createLinearGradient(0, 0, 0, this.screenHeight);
            gradient.addColorStop(0, skyTop);
            gradient.addColorStop(1, skyBottom);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, this.screenWidth, this.screenHeight);

            // Stars at night (use pre-rendered canvas)
            if (hour < 6 || hour >= 20) {
                const starSeed = Math.floor(this.cameraX / 100);
                this.renderStarsToCanvas(starSeed);
                ctx.drawImage(this.starCanvas, 0, 0);
            }

            // Sun/Moon
            const celestialX = this.screenWidth * (0.2 + this.dayProgress * 0.6);
            const celestialY = this.screenHeight * 0.2 + Math.sin(this.dayProgress * Math.PI) * this.screenHeight * 0.15;

            if (hour >= 6 && hour < 18) {
                // Sun
                ctx.fillStyle = '#fff5b5';
                ctx.shadowColor = '#ffdd00';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            } else {
                // Moon
                ctx.fillStyle = '#e8e8e8';
                ctx.shadowColor = '#ccccff';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        renderPlayer() {
            const ctx = this.ctx;
            const blockSize = CONFIG.BLOCK_SIZE;
            const screenCenterX = this.screenWidth / 2;
            const screenCenterY = this.screenHeight / 2;

            const px = screenCenterX + (this.player.x - this.cameraX) * blockSize;
            const py = screenCenterY + (this.player.y - this.cameraY) * blockSize;

            const w = this.player.width * blockSize;
            const h = this.player.height * blockSize;

            // Body
            ctx.fillStyle = '#3b82f6'; // Blue shirt
            ctx.fillRect(px - w/2, py - h * 0.7, w, h * 0.5);

            // Head
            ctx.fillStyle = '#f5deb3'; // Skin tone
            ctx.fillRect(px - w/2 * 0.8, py - h, w * 0.8, h * 0.35);

            // Eyes
            ctx.fillStyle = '#000';
            const eyeOffset = this.player.facingRight ? 0.15 : -0.15;
            ctx.fillRect(px - w * 0.1 + w * eyeOffset, py - h * 0.9, w * 0.1, w * 0.1);
            ctx.fillRect(px + w * 0.1 + w * eyeOffset, py - h * 0.9, w * 0.1, w * 0.1);

            // Hair
            ctx.fillStyle = '#4a3728';
            ctx.fillRect(px - w/2 * 0.8, py - h, w * 0.8, h * 0.1);

            // Legs
            ctx.fillStyle = '#1e3a5f'; // Dark blue pants
            ctx.fillRect(px - w/2, py - h * 0.2, w * 0.4, h * 0.2);
            ctx.fillRect(px + w/2 - w * 0.4, py - h * 0.2, w * 0.4, h * 0.2);

            // Render held item (tool or block)
            this.renderHeldItem(px, py, w, h);
        }

        renderHeldItem(px, py, w, h) {
            const ctx = this.ctx;
            const heldItem = this.player.getHeldItem();
            if (!heldItem) return;

            // Hand/arm position
            const armX = this.player.facingRight ? px + w * 0.3 : px - w * 0.3;
            const armY = py - h * 0.5;

            ctx.save();
            ctx.translate(armX, armY);

            // Apply swing rotation
            const swingDir = this.player.facingRight ? 1 : -1;
            ctx.rotate((this.player.swingAngle * Math.PI / 180) * swingDir);

            // Flip if facing left
            if (!this.player.facingRight) {
                ctx.scale(-1, 1);
            }

            const itemSize = w * 0.8;

            let texture = null;
            if (heldItem.kind === 'tool') {
                // Draw tool (pickaxe, axe, shovel)
                texture = TextureGenerator.createToolTexture(heldItem.key, 32);
                if (texture) {
                    ctx.drawImage(texture, 0, -itemSize * 0.3, itemSize, itemSize);
                }
            } else if (heldItem.kind === 'item') {
                // Draw material item (stick, coal, apple, etc.)
                texture = TextureGenerator.createItemTexture(heldItem.key, 32);
                if (texture) {
                    ctx.drawImage(texture, 0, -itemSize * 0.3, itemSize * 0.7, itemSize * 0.7);
                }
            } else {
                // Draw block preview
                texture = TextureGenerator.createTexture(heldItem.key);
                if (texture) {
                    ctx.drawImage(texture, 0, -itemSize * 0.3, itemSize * 0.6, itemSize * 0.6);
                }
            }

            ctx.restore();
        }

        lerpColor(a, b, t) {
            const ah = parseInt(a.replace(/#/g, ''), 16);
            const bh = parseInt(b.replace(/#/g, ''), 16);

            const ar = ah >> 16, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
            const br = bh >> 16, bg = (bh >> 8) & 0xff, bb = bh & 0xff;

            const rr = Math.round(ar + (br - ar) * t);
            const rg = Math.round(ag + (bg - ag) * t);
            const rb = Math.round(ab + (bb - ab) * t);

            return `#${((1 << 24) + (rr << 16) + (rg << 8) + rb).toString(16).slice(1)}`;
        }

        // --- SAVE/LOAD SYSTEM ---
        saveGame() {
            try {
                const saveData = {
                    version: 2,
                    timestamp: Date.now(),
                    seed: this.world.seed,
                    player: {
                        x: this.player.x,
                        y: this.player.y,
                        inventory: this.player.inventory,
                        selectedSlot: this.player.selectedSlot,
                        health: this.player.health
                    },
                    world: {
                        // Convert Map to array of [key, value] pairs
                        modifiedBlocks: Array.from(this.world.modifiedBlocks.entries())
                    },
                    furnaces: this.furnaceSystem.getState(),
                    gameTime: this.gameTime
                };

                localStorage.setItem('minecraft2d_save', JSON.stringify(saveData));
                this.showNotification('Game Saved');
                console.log(`Game saved: ${saveData.world.modifiedBlocks.length} block changes`);
                return true;
            } catch (e) {
                console.error('Failed to save game:', e);
                this.showNotification('Save Failed!');
                return false;
            }
        }

        loadGame() {
            try {
                const saveJson = localStorage.getItem('minecraft2d_save');
                if (!saveJson) return null;

                const saveData = JSON.parse(saveJson);
                console.log(`Loading save from ${new Date(saveData.timestamp).toLocaleString()}`);
                return saveData;
            } catch (e) {
                console.error('Failed to load game:', e);
                return null;
            }
        }

        deleteSave() {
            localStorage.removeItem('minecraft2d_save');
            this.showNotification('Save Deleted');
        }

        showNotification(message) {
            const notif = this.dom.saveNotification;
            notif.textContent = message;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), 1500);
        }

        loop() {
            const now = performance.now();
            const dt = now - this.lastTime;
            this.lastTime = now;

            // FPS counter
            this.frameCount++;
            if (now - this.lastFpsUpdate >= 1000) {
                this.fps = this.frameCount;
                this.frameCount = 0;
                this.lastFpsUpdate = now;
                this.dom.fps.textContent = this.fps;
            }

            this.update(dt);
            this.render();

            requestAnimationFrame(() => this.loop());
        }
    }

    // --- START GAME ---
    window.addEventListener('load', () => {
        try {
            new Game();
            console.log('2D Minecraft initialized successfully!');
        } catch (error) {
            console.error('Game initialization failed:', error);
            alert('Failed to initialize game. Check console for details.');
        }
    });
    </script>
</body>
</html>
