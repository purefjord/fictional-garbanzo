<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2D Minecraft - Side Scroller</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #87CEEB;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
        }
        #gameCanvas {
            display: block;
            cursor: crosshair;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            border: 2px solid #555;
        }
        .slot {
            width: 50px;
            height: 50px;
            background: rgba(139,139,139,0.8);
            border: 2px solid #373737;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }
        .slot.selected {
            border-color: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        .slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        .slot-key {
            position: absolute;
            top: 2px;
            left: 4px;
            color: #aaa;
            font-size: 10px;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.8);
        }
        #crosshair::before {
            width: 2px; height: 20px;
            left: 9px; top: 0;
        }
        #crosshair::after {
            width: 20px; height: 2px;
            left: 0; top: 9px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px black;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
            max-width: 200px;
        }
        #miningProgress {
            position: absolute;
            width: 40px;
            height: 6px;
            background: rgba(0,0,0,0.5);
            border-radius: 3px;
            display: none;
        }
        #miningProgress .fill {
            height: 100%;
            background: #4CAF50;
            border-radius: 3px;
            transition: width 0.05s;
        }
        /* Health Bar */
        #healthBar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            padding: 5px 10px;
            background: rgba(0,0,0,0.4);
            border-radius: 5px;
        }
        .heart {
            width: 18px;
            height: 18px;
            position: relative;
        }
        .heart::before {
            content: '♥';
            position: absolute;
            font-size: 20px;
            line-height: 18px;
            color: #333;
            text-shadow: 0 0 2px #000;
        }
        .heart::after {
            content: '♥';
            position: absolute;
            font-size: 20px;
            line-height: 18px;
            color: #ff0000;
            text-shadow: 0 0 2px #000;
            clip-path: inset(0 0 0 0);
            transition: clip-path 0.1s;
        }
        .heart.empty::after {
            clip-path: inset(0 100% 0 0);
        }
        .heart.half::after {
            clip-path: inset(0 50% 0 0);
        }
        #damageOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 0, 0, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 500;
        }
        #damageOverlay.flash {
            opacity: 1;
        }
        #deathScreen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(100, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #deathScreen.show {
            display: flex;
        }
        #deathScreen h1 {
            color: #fff;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px #000;
        }
        #deathScreen button {
            padding: 15px 30px;
            font-size: 20px;
            background: #555;
            color: white;
            border: 2px solid #777;
            border-radius: 5px;
            cursor: pointer;
        }
        #deathScreen button:hover {
            background: #666;
        }

        /* Mobile Touch Controls */
        #touchControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            z-index: 100;
        }
        .touch-visible #touchControls {
            display: block;
        }
        .touch-visible #controls {
            display: none;
        }
        .touch-visible #ui {
            bottom: 140px;
        }
        .touch-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.25);
            border: 3px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px 3px black;
            pointer-events: all;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            transition: background 0.1s, transform 0.1s;
        }
        .touch-btn:active, .touch-btn.active {
            background: rgba(255,255,255,0.5);
            transform: scale(0.95);
        }
        .touch-btn.left-btn { bottom: 20px; left: 20px; }
        .touch-btn.right-btn { bottom: 20px; left: 100px; }
        .touch-btn.jump-btn { bottom: 20px; right: 20px; }
        .touch-btn.mode-btn {
            bottom: 100px;
            right: 20px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }
        .touch-btn.mode-btn.place-mode {
            background: rgba(100,200,100,0.4);
            border-color: rgba(100,255,100,0.6);
        }
        #modeLabel {
            position: absolute;
            bottom: 160px;
            right: 15px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px black;
            text-align: center;
            width: 60px;
            pointer-events: none;
        }
        /* Touch crosshair for aiming */
        #touchCrosshair {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255,255,255,0.7);
            border-radius: 4px;
            pointer-events: none;
            display: none;
            z-index: 50;
        }
        #touchCrosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: rgba(255,255,255,0.9);
            border-radius: 50%;
        }
        .touch-visible #touchCrosshair {
            display: block;
        }
        /* Larger slots on mobile */
        .touch-visible .slot {
            width: 40px;
            height: 40px;
        }
        .touch-visible .slot-key {
            display: none;
        }
        .touch-visible #info {
            font-size: 12px;
            padding: 6px;
        }
        #saveNotification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: #4CAF50;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        #saveNotification.show {
            opacity: 1;
        }

        /* Crafting UI */
        #craftingOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 800;
        }
        #craftingOverlay.show {
            display: flex;
        }
        #craftingPanel {
            background: #8b8b8b;
            border: 4px solid #373737;
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #craftingPanel h2 {
            color: #fff;
            text-shadow: 2px 2px #373737;
            margin: 0 0 15px 0;
            text-align: center;
            font-size: 24px;
        }
        .craft-section {
            margin-bottom: 20px;
        }
        .craft-section h3 {
            color: #ddd;
            font-size: 14px;
            margin: 0 0 10px 0;
            border-bottom: 2px solid #555;
            padding-bottom: 5px;
        }
        .recipe-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
        }
        .recipe-item {
            background: #5a5a5a;
            border: 2px solid #444;
            border-radius: 4px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .recipe-item:hover {
            background: #6a6a6a;
            border-color: #888;
        }
        .recipe-item.can-craft {
            border-color: #5a5;
            background: #4a5a4a;
        }
        .recipe-item.can-craft:hover {
            background: #5a6a5a;
            border-color: #7c7;
        }
        .recipe-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        .recipe-icon {
            width: 32px;
            height: 32px;
            background: #333;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .recipe-name {
            color: #fff;
            font-weight: bold;
            font-size: 14px;
        }
        .recipe-count {
            color: #aaa;
            font-size: 12px;
        }
        .recipe-ingredients {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .ingredient {
            display: flex;
            align-items: center;
            gap: 4px;
            background: #444;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 11px;
        }
        .ingredient-icon {
            width: 16px;
            height: 16px;
        }
        .ingredient-text {
            color: #ccc;
        }
        .ingredient-text.has-enough {
            color: #8f8;
        }
        .ingredient-text.not-enough {
            color: #f88;
        }
        #craftingClose {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            text-shadow: 2px 2px #000;
        }
        #craftingClose:hover {
            color: #f88;
        }
        .crafting-hint {
            color: #aaa;
            font-size: 12px;
            text-align: center;
            margin-top: 10px;
        }

        /* Furnace UI */
        #furnaceOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 800;
        }
        #furnaceOverlay.show {
            display: flex;
        }
        #furnacePanel {
            background: #8b8b8b;
            border: 4px solid #373737;
            border-radius: 8px;
            padding: 20px;
            position: relative;
        }
        #furnacePanel h2 {
            color: #fff;
            text-shadow: 2px 2px #373737;
            margin: 0 0 15px 0;
            text-align: center;
            font-size: 24px;
        }
        #furnaceClose {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            text-shadow: 2px 2px #000;
        }
        #furnaceClose:hover {
            color: #f88;
        }
        .furnace-grid {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .furnace-row {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .furnace-slot {
            width: 50px;
            height: 50px;
            background: #5a5a5a;
            border: 2px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }
        .furnace-slot:hover {
            border-color: #888;
        }
        .furnace-slot canvas {
            width: 32px;
            height: 32px;
        }
        .furnace-slot .slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        .furnace-arrow {
            font-size: 32px;
            color: #666;
        }
        .furnace-arrow.active {
            color: #fa0;
        }
        .furnace-fire {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #444;
        }
        .furnace-fire.burning {
            color: #f80;
            animation: flicker 0.5s infinite alternate;
        }
        @keyframes flicker {
            from { opacity: 0.8; }
            to { opacity: 1; }
        }
        .furnace-progress {
            width: 50px;
            height: 6px;
            background: #444;
            border-radius: 3px;
            margin-top: 5px;
        }
        .furnace-progress-fill {
            height: 100%;
            background: #fa0;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s;
        }
        .furnace-label {
            color: #aaa;
            font-size: 11px;
            text-align: center;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="healthBar"></div>
    <div id="damageOverlay"></div>
    <div id="deathScreen">
        <h1>You Died!</h1>
        <button id="respawnBtn">Respawn</button>
    </div>
    <div id="ui"></div>
    <div id="info">
        <div>FPS: <span id="fps">0</span></div>
        <div>Position: <span id="position">0, 0</span></div>
        <div>Time: <span id="timeDisplay">Day</span></div>
    </div>
    <div id="controls">
        <strong>Controls:</strong><br>
        WASD / Arrows - Move<br>
        Space - Jump<br>
        Left Click - Break block<br>
        Right Click - Place/Use<br>
        1-9 - Select hotbar<br>
        E - Crafting menu<br>
        P - Save game<br>
        N - New game
    </div>
    <div id="miningProgress"><div class="fill"></div></div>
    <div id="saveNotification">Game Saved</div>

    <!-- Crafting UI -->
    <div id="craftingOverlay">
        <div id="craftingPanel">
            <span id="craftingClose">&times;</span>
            <h2>Crafting</h2>
            <div id="craftingRecipes"></div>
            <div class="crafting-hint">Click a recipe to craft. Press E or Escape to close.</div>
        </div>
    </div>

    <!-- Furnace UI -->
    <div id="furnaceOverlay">
        <div id="furnacePanel">
            <span id="furnaceClose">&times;</span>
            <h2>Furnace</h2>
            <div class="furnace-grid">
                <div class="furnace-row">
                    <div>
                        <div class="furnace-slot" id="furnaceInput"></div>
                        <div class="furnace-label">Input</div>
                    </div>
                    <div class="furnace-arrow" id="furnaceArrow">&#10132;</div>
                    <div>
                        <div class="furnace-slot" id="furnaceOutput"></div>
                        <div class="furnace-label">Output</div>
                    </div>
                </div>
                <div class="furnace-row">
                    <div>
                        <div class="furnace-fire" id="furnaceFire">&#128293;</div>
                        <div class="furnace-slot" id="furnaceFuel"></div>
                        <div class="furnace-label">Fuel (Coal)</div>
                    </div>
                    <div class="furnace-progress">
                        <div class="furnace-progress-fill" id="furnaceProgress"></div>
                    </div>
                </div>
            </div>
            <div class="crafting-hint">Click slots to transfer items. Press Escape to close.</div>
        </div>
    </div>

    <!-- Mobile Touch Controls -->
    <div id="touchControls">
        <div id="touchCrosshair"></div>
        <div class="touch-btn left-btn" data-action="left">&#9664;</div>
        <div class="touch-btn right-btn" data-action="right">&#9654;</div>
        <div class="touch-btn jump-btn" data-action="jump">&#9650;</div>
        <div class="touch-btn mode-btn" data-action="mode">&#9935;</div>
        <div id="modeLabel">Mine</div>
    </div>

    <script>
    // ============================================
    // 2D MINECRAFT SIDE-SCROLLER
    // Single HTML file implementation
    // ============================================

    // --- CONFIGURATION ---
    const CONFIG = {
        BLOCK_SIZE: 32,
        WORLD_WIDTH: 512,      // blocks
        WORLD_HEIGHT: 256,     // blocks
        SURFACE_HEIGHT: 180,   // base surface level
        // Physics values in blocks/second or blocks/second²
        GRAVITY: 30,           // blocks/second² (acceleration)
        JUMP_FORCE: 10,        // blocks/second (initial velocity)
        MOVE_SPEED: 5,         // blocks/second
        TERMINAL_VELOCITY: 20, // blocks/second (max fall speed)
        MAX_DT: 50,            // ms - clamp dt to prevent huge jumps after tab switch
        PLAYER_WIDTH: 0.6,     // in blocks
        PLAYER_HEIGHT: 1.8,    // in blocks
        REACH_DISTANCE: 5,     // blocks
        DAY_LENGTH: 600,       // seconds for full day cycle
    };

    // --- HELPERS ---
    function hash2i(seed, x, y) {
        let h = (seed | 0) ^ Math.imul(x | 0, 374761393) ^ Math.imul(y | 0, 668265263);
        h = Math.imul(h ^ (h >>> 13), 1274126177);
        return (h ^ (h >>> 16)) >>> 0 / 4294967296;
    }

    // Registry: adds key, kind, builds lookup table
    function register(collection, kind) {
        const byId = {};
        for (const [key, item] of Object.entries(collection)) {
            item.key = key;
            item.kind = kind;
            byId[item.id] = item;
        }
        return byId;
    }

    // --- BLOCKS ---
    const BLOCKS = {
        AIR: { id: 0, name: 'Air', solid: false, transparent: true },
        GRASS: { id: 1, name: 'Grass', solid: true, hardness: 0.6, drops: 'DIRT', toolType: 'shovel' },
        DIRT: { id: 2, name: 'Dirt', solid: true, hardness: 0.5, toolType: 'shovel' },
        STONE: { id: 3, name: 'Stone', solid: true, hardness: 1.5, drops: 'COBBLESTONE', toolType: 'pickaxe' },
        COBBLESTONE: { id: 4, name: 'Cobblestone', solid: true, hardness: 2, toolType: 'pickaxe' },
        WOOD: { id: 5, name: 'Wood', solid: true, hardness: 2, toolType: 'axe' },
        LEAVES: { id: 6, name: 'Leaves', solid: true, hardness: 0.2, transparent: true, randomDrop: { itemId: 204, chance: 0.1 } },
        SAND: { id: 7, name: 'Sand', solid: true, hardness: 0.5, toolType: 'shovel' },
        WATER: { id: 8, name: 'Water', solid: false, transparent: true },
        COAL_ORE: { id: 9, name: 'Coal Ore', solid: true, hardness: 3, toolType: 'pickaxe', dropsItem: 201 },
        IRON_ORE: { id: 10, name: 'Iron Ore', solid: true, hardness: 3, toolType: 'pickaxe', minTier: 1 },
        GOLD_ORE: { id: 11, name: 'Gold Ore', solid: true, hardness: 3, toolType: 'pickaxe', minTier: 2 },
        DIAMOND_ORE: { id: 12, name: 'Diamond Ore', solid: true, hardness: 3, toolType: 'pickaxe', minTier: 2, dropsItem: 203 },
        BEDROCK: { id: 13, name: 'Bedrock', solid: true, hardness: Infinity },
        PLANKS: { id: 14, name: 'Planks', solid: true, hardness: 2, toolType: 'axe' },
        GLASS: { id: 15, name: 'Glass', solid: true, hardness: 0.3, transparent: true, dropsNothing: true },
        FURNACE: { id: 16, name: 'Furnace', solid: true, hardness: 3.5, toolType: 'pickaxe', interactive: true },
    };
    const BLOCK_BY_ID = register(BLOCKS, 'block');

    // --- TOOLS (generated from compact definition) ---
    const TOOL_TIERS = {
        wood:    { tier: 0, speedMultiplier: 2, color: '#8B5A2B' },
        stone:   { tier: 1, speedMultiplier: 4, color: '#808080' },
        iron:    { tier: 2, speedMultiplier: 6, color: '#C0C0C0' },
        diamond: { tier: 3, speedMultiplier: 8, color: '#00CED1' },
    };
    const TOOL_TYPES = {
        pickaxe: { baseId: 100, baseDamage: 2 },
        axe:     { baseId: 110, baseDamage: 4 },
        shovel:  { baseId: 120, baseDamage: 1 },
    };
    const TIERS = ['wood', 'stone', 'iron', 'diamond'];

    // Generate all tools: WOOD_PICKAXE, STONE_PICKAXE, etc.
    const TOOLS = {};
    for (const [type, { baseId, baseDamage }] of Object.entries(TOOL_TYPES)) {
        TIERS.forEach((tier, i) => {
            const key = `${tier.toUpperCase()}_${type.toUpperCase()}`;
            const name = `${tier[0].toUpperCase() + tier.slice(1)} ${type[0].toUpperCase() + type.slice(1)}`;
            TOOLS[key] = { id: baseId + i, name, type, tier, damage: baseDamage + i };
        });
    }
    const TOOL_BY_ID = register(TOOLS, 'tool');

    // --- ITEMS (materials) ---
    const ITEMS = {
        STICK:      { id: 200, name: 'Stick' },
        COAL:       { id: 201, name: 'Coal' },
        IRON_INGOT: { id: 202, name: 'Iron Ingot' },
        DIAMOND:    { id: 203, name: 'Diamond' },
        APPLE:      { id: 204, name: 'Apple', food: true, healAmount: 4 },
    };
    const ITEM_BY_ID = register(ITEMS, 'item');

    // Unified lookup
    function getItemById(id) {
        return BLOCK_BY_ID[id] || TOOL_BY_ID[id] || ITEM_BY_ID[id];
    }

    // Derived properties (avoid storing redundant data)
    const isStackable = (item) => item.kind !== 'tool';

    // --- CRAFTING RECIPES ---
    // Tool recipe materials by tier
    const TIER_MATERIALS = {
        wood: BLOCKS.PLANKS, stone: BLOCKS.COBBLESTONE, iron: ITEMS.IRON_INGOT, diamond: ITEMS.DIAMOND,
    };
    // Head count by tool type (shovel = 1, pickaxe/axe = 3)
    const TOOL_HEAD_COUNT = { pickaxe: 3, axe: 3, shovel: 1 };

    // Generate tool recipes
    const TOOL_RECIPES = Object.values(TOOLS).map(tool => ({
        result: tool, resultCount: 1,
        ingredients: [
            { item: TIER_MATERIALS[tool.tier], count: TOOL_HEAD_COUNT[tool.type] },
            { item: ITEMS.STICK, count: 2 },
        ],
    }));

    const RECIPES = [
        // Basic materials
        { result: BLOCKS.PLANKS, resultCount: 4, ingredients: [{ item: BLOCKS.WOOD, count: 1 }] },
        { result: ITEMS.STICK, resultCount: 4, ingredients: [{ item: BLOCKS.PLANKS, count: 2 }] },
        { result: BLOCKS.FURNACE, resultCount: 1, ingredients: [{ item: BLOCKS.COBBLESTONE, count: 8 }] },
        // All tool recipes
        ...TOOL_RECIPES,
    ];

    // --- SMELTING RECIPES ---
    const SMELTING_RECIPES = [
        { input: BLOCKS.IRON_ORE, output: ITEMS.IRON_INGOT, time: 10 }, // 10 seconds
        { input: BLOCKS.COBBLESTONE, output: BLOCKS.STONE, time: 10 },
        { input: BLOCKS.SAND, output: BLOCKS.GLASS, time: 10 },
    ];

    // Smelting lookup map (avoids linear search)
    const SMELT_BY_INPUT = new Map(SMELTING_RECIPES.map(r => [r.input.id, r]));

    // --- SIMPLEX NOISE IMPLEMENTATION ---
    class SimplexNoise {
        constructor(seed = Math.random() * 10000) {
            this.p = new Uint8Array(512);
            const perm = new Uint8Array(256);
            for (let i = 0; i < 256; i++) perm[i] = i;

            // Seed-based shuffle
            let s = seed;
            for (let i = 255; i > 0; i--) {
                s = (s * 16807) % 2147483647;
                const j = s % (i + 1);
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }

            for (let i = 0; i < 512; i++) this.p[i] = perm[i & 255];
        }

        noise2D(x, y) {
            const F2 = 0.5 * (Math.sqrt(3) - 1);
            const G2 = (3 - Math.sqrt(3)) / 6;

            const s = (x + y) * F2;
            const i = Math.floor(x + s);
            const j = Math.floor(y + s);

            const t = (i + j) * G2;
            const X0 = i - t;
            const Y0 = j - t;
            const x0 = x - X0;
            const y0 = y - Y0;

            const [i1, j1] = x0 > y0 ? [1, 0] : [0, 1];

            const x1 = x0 - i1 + G2;
            const y1 = y0 - j1 + G2;
            const x2 = x0 - 1 + 2 * G2;
            const y2 = y0 - 1 + 2 * G2;

            const ii = i & 255;
            const jj = j & 255;

            const grad = (hash, x, y) => {
                const h = hash & 7;
                const u = h < 4 ? x : y;
                const v = h < 4 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
            };

            let n0 = 0, n1 = 0, n2 = 0;

            let t0 = 0.5 - x0*x0 - y0*y0;
            if (t0 >= 0) {
                t0 *= t0;
                n0 = t0 * t0 * grad(this.p[ii + this.p[jj]], x0, y0);
            }

            let t1 = 0.5 - x1*x1 - y1*y1;
            if (t1 >= 0) {
                t1 *= t1;
                n1 = t1 * t1 * grad(this.p[ii + i1 + this.p[jj + j1]], x1, y1);
            }

            let t2 = 0.5 - x2*x2 - y2*y2;
            if (t2 >= 0) {
                t2 *= t2;
                n2 = t2 * t2 * grad(this.p[ii + 1 + this.p[jj + 1]], x2, y2);
            }

            return 70 * (n0 + n1 + n2);
        }

        octaveNoise(x, y, octaves, persistence = 0.5) {
            let total = 0;
            let frequency = 1;
            let amplitude = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                total += this.noise2D(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }

            return total / maxValue;
        }
    }

    // --- TEXTURE GENERATOR ---
    const TextureGenerator = {
        cache: {},

        createTexture(blockType, size = CONFIG.BLOCK_SIZE) {
            const cacheKey = `${blockType}_${size}`;
            if (this.cache[cacheKey]) return this.cache[cacheKey];

            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Lookup tables for block drawing
            const oreColors = { COAL_ORE: '#333', IRON_ORE: '#d4a574', GOLD_ORE: '#ffd700', DIAMOND_ORE: '#00ffff' };
            const drawFn = this['draw' + blockType.split('_').map(w => w[0] + w.slice(1).toLowerCase()).join('')];

            if (oreColors[blockType]) this.drawOre(ctx, size, oreColors[blockType]);
            else if (drawFn) drawFn.call(this, ctx, size);
            else { ctx.fillStyle = '#ff00ff'; ctx.fillRect(0, 0, size, size); }

            this.cache[cacheKey] = canvas;
            return canvas;
        },

        drawGrass(ctx, size) {
            // Dirt base
            ctx.fillStyle = '#8B5A2B';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#6B4226', 0.3);

            // Green top
            const gradient = ctx.createLinearGradient(0, 0, 0, size * 0.4);
            gradient.addColorStop(0, '#5d8c32');
            gradient.addColorStop(1, '#4a7029');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size * 0.35);

            // Grass blades
            ctx.strokeStyle = '#7cb342';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * size;
                ctx.beginPath();
                ctx.moveTo(x, size * 0.35);
                ctx.lineTo(x + (Math.random() - 0.5) * 4, 0);
                ctx.stroke();
            }
        },

        drawDirt(ctx, size) {
            ctx.fillStyle = '#8B5A2B';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#6B4226', 0.4);
            this.addNoise(ctx, size, '#9B6A3B', 0.2);

            // Small rocks
            ctx.fillStyle = '#5a4020';
            for (let i = 0; i < 4; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                ctx.beginPath();
                ctx.arc(x, y, 1 + Math.random() * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        },

        drawStone(ctx, size) {
            ctx.fillStyle = '#808080';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#666666', 0.3);
            this.addNoise(ctx, size, '#999999', 0.2);

            // Cracks
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            for (let i = 0; i < 2; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * size, Math.random() * size);
                ctx.lineTo(Math.random() * size, Math.random() * size);
                ctx.stroke();
            }
        },

        drawCobblestone(ctx, size) {
            ctx.fillStyle = '#6a6a6a';
            ctx.fillRect(0, 0, size, size);

            // Irregular stones
            const stones = [
                [0, 0, size*0.5, size*0.45],
                [size*0.5, 0, size*0.5, size*0.5],
                [0, size*0.45, size*0.6, size*0.55],
                [size*0.55, size*0.5, size*0.45, size*0.5]
            ];

            stones.forEach(([x, y, w, h], i) => {
                ctx.fillStyle = i % 2 ? '#7a7a7a' : '#5a5a5a';
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
            });
        },

        drawWood(ctx, size) {
            ctx.fillStyle = '#6B4423';
            ctx.fillRect(0, 0, size, size);

            // Bark lines
            ctx.strokeStyle = '#4a3020';
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) {
                const x = i * (size / 4) + Math.random() * 4;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x + (Math.random() - 0.5) * 4, size);
                ctx.stroke();
            }

            // Rings hint
            ctx.fillStyle = '#5a3818';
            ctx.beginPath();
            ctx.ellipse(size/2, size/2, size*0.3, size*0.35, 0, 0, Math.PI * 2);
            ctx.fill();
        },

        drawLeaves(ctx, size) {
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 0, size, size);

            // Leaf clusters
            for (let i = 0; i < 15; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#32CD32' : '#1e7b1e';
                const x = Math.random() * size;
                const y = Math.random() * size;
                ctx.beginPath();
                ctx.arc(x, y, 2 + Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }
        },

        drawSand(ctx, size) {
            ctx.fillStyle = '#e6d59e';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#d4c48a', 0.3);

            // Sand grains
            ctx.fillStyle = '#c4b47a';
            for (let i = 0; i < 20; i++) {
                ctx.fillRect(
                    Math.random() * size,
                    Math.random() * size,
                    1, 1
                );
            }
        },

        drawWater(ctx, size) {
            const gradient = ctx.createLinearGradient(0, 0, size, size);
            gradient.addColorStop(0, 'rgba(30, 144, 255, 0.7)');
            gradient.addColorStop(1, 'rgba(0, 100, 180, 0.7)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            // Wave highlights
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(0, size * 0.3 * (i + 1));
                ctx.quadraticCurveTo(size/2, size * 0.3 * (i + 1) - 5, size, size * 0.3 * (i + 1));
                ctx.stroke();
            }
        },

        drawOre(ctx, size, oreColor) {
            // Stone base
            this.drawStone(ctx, size);

            // Ore deposits
            ctx.fillStyle = oreColor;
            const deposits = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < deposits; i++) {
                const x = 4 + Math.random() * (size - 8);
                const y = 4 + Math.random() * (size - 8);
                const s = 3 + Math.random() * 4;

                ctx.beginPath();
                ctx.moveTo(x, y - s);
                ctx.lineTo(x + s, y);
                ctx.lineTo(x, y + s);
                ctx.lineTo(x - s, y);
                ctx.closePath();
                ctx.fill();
            }
        },

        drawBedrock(ctx, size) {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, size, size);

            // Chaotic pattern
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#333' : '#0a0a0a';
                ctx.fillRect(
                    Math.random() * size,
                    Math.random() * size,
                    3 + Math.random() * 6,
                    3 + Math.random() * 6
                );
            }
        },

        drawPlanks(ctx, size) {
            ctx.fillStyle = '#ba8c51';
            ctx.fillRect(0, 0, size, size);

            // Horizontal planks
            ctx.strokeStyle = '#8a5c31';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                const y = i * (size / 4) + size / 8;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(size, y);
                ctx.stroke();
            }

            // Wood grain
            ctx.strokeStyle = 'rgba(100, 60, 20, 0.3)';
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * size, 0);
                ctx.lineTo(Math.random() * size, size);
                ctx.stroke();
            }
        },

        drawGlass(ctx, size) {
            ctx.fillStyle = 'rgba(200, 230, 255, 0.4)';
            ctx.fillRect(0, 0, size, size);

            // Frame
            ctx.strokeStyle = 'rgba(180, 210, 235, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, size - 2, size - 2);

            // Shine
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(2, 2);
            ctx.lineTo(size * 0.4, 2);
            ctx.lineTo(2, size * 0.4);
            ctx.closePath();
            ctx.fill();
        },

        drawFurnace(ctx, size) {
            // Stone base
            ctx.fillStyle = '#6a6a6a';
            ctx.fillRect(0, 0, size, size);
            this.addNoise(ctx, size, '#555', 0.2);

            // Dark border
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, size - 2, size - 2);

            // Furnace opening (dark hole)
            const holeX = size * 0.25;
            const holeY = size * 0.4;
            const holeW = size * 0.5;
            const holeH = size * 0.45;

            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(holeX, holeY, holeW, holeH);

            // Inner glow hint
            ctx.fillStyle = '#333';
            ctx.fillRect(holeX + 2, holeY + 2, holeW - 4, holeH - 4);

            // Top vent
            ctx.fillStyle = '#555';
            ctx.fillRect(size * 0.3, size * 0.1, size * 0.4, size * 0.15);
            ctx.fillStyle = '#222';
            ctx.fillRect(size * 0.35, size * 0.12, size * 0.1, size * 0.1);
            ctx.fillRect(size * 0.55, size * 0.12, size * 0.1, size * 0.1);
        },

        addNoise(ctx, size, color, intensity) {
            ctx.fillStyle = color;
            for (let i = 0; i < size * size * intensity; i++) {
                ctx.fillRect(
                    Math.floor(Math.random() * size),
                    Math.floor(Math.random() * size),
                    1, 1
                );
            }
        },

        // Tool textures
        createToolTexture(toolKey, size = 32) {
            const cacheKey = `tool_${toolKey}_${size}`;
            if (this.cache[cacheKey]) return this.cache[cacheKey];

            const tool = TOOLS[toolKey];
            if (!tool) return null;

            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const tierInfo = TOOL_TIERS[tool.tier];
            const headColor = tierInfo.color;
            const handleColor = '#6B4423';

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const drawFn = { pickaxe: this.drawPickaxe, axe: this.drawAxe, shovel: this.drawShovel }[tool.type];
            if (drawFn) drawFn.call(this, ctx, size, headColor, handleColor);

            this.cache[cacheKey] = canvas;
            return canvas;
        },

        drawPickaxe(ctx, size, headColor, handleColor) {
            const s = size / 32;
            // Handle (diagonal)
            ctx.strokeStyle = handleColor;
            ctx.lineWidth = 4 * s;
            ctx.beginPath();
            ctx.moveTo(8 * s, 24 * s);
            ctx.lineTo(24 * s, 8 * s);
            ctx.stroke();

            // Pickaxe head
            ctx.fillStyle = headColor;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1 * s;

            ctx.beginPath();
            ctx.moveTo(16 * s, 4 * s);
            ctx.lineTo(28 * s, 10 * s);
            ctx.lineTo(24 * s, 14 * s);
            ctx.lineTo(20 * s, 12 * s);
            ctx.lineTo(18 * s, 18 * s);
            ctx.lineTo(12 * s, 12 * s);
            ctx.lineTo(10 * s, 14 * s);
            ctx.lineTo(6 * s, 10 * s);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        },

        drawAxe(ctx, size, headColor, handleColor) {
            const s = size / 32;
            // Handle
            ctx.strokeStyle = handleColor;
            ctx.lineWidth = 4 * s;
            ctx.beginPath();
            ctx.moveTo(8 * s, 24 * s);
            ctx.lineTo(22 * s, 10 * s);
            ctx.stroke();

            // Axe head
            ctx.fillStyle = headColor;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1 * s;

            ctx.beginPath();
            ctx.moveTo(18 * s, 6 * s);
            ctx.quadraticCurveTo(30 * s, 8 * s, 26 * s, 18 * s);
            ctx.lineTo(20 * s, 14 * s);
            ctx.lineTo(18 * s, 12 * s);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        },

        drawShovel(ctx, size, headColor, handleColor) {
            const s = size / 32;
            // Handle
            ctx.strokeStyle = handleColor;
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(10 * s, 26 * s);
            ctx.lineTo(22 * s, 14 * s);
            ctx.stroke();

            // Shovel head
            ctx.fillStyle = headColor;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1 * s;

            ctx.beginPath();
            ctx.moveTo(20 * s, 16 * s);
            ctx.quadraticCurveTo(28 * s, 8 * s, 24 * s, 4 * s);
            ctx.quadraticCurveTo(20 * s, 2 * s, 16 * s, 6 * s);
            ctx.quadraticCurveTo(14 * s, 10 * s, 18 * s, 14 * s);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        },

        // Item textures (materials)
        createItemTexture(itemKey, size = 32) {
            const cacheKey = `item_${itemKey}_${size}`;
            if (this.cache[cacheKey]) return this.cache[cacheKey];

            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const drawFn = this['draw' + itemKey.split('_').map(w => w[0] + w.slice(1).toLowerCase()).join('')];
            if (itemKey === 'IRON_INGOT') this.drawIngot(ctx, size, '#C0C0C0', '#888');
            else if (drawFn) drawFn.call(this, ctx, size);
            else { ctx.fillStyle = '#ff00ff'; ctx.fillRect(size * 0.25, size * 0.25, size * 0.5, size * 0.5); }

            this.cache[cacheKey] = canvas;
            return canvas;
        },

        drawStick(ctx, size) {
            const s = size / 32;
            ctx.strokeStyle = '#6B4423';
            ctx.lineWidth = 4 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(10 * s, 26 * s);
            ctx.lineTo(22 * s, 6 * s);
            ctx.stroke();

            // Highlight
            ctx.strokeStyle = '#8B6443';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(11 * s, 24 * s);
            ctx.lineTo(21 * s, 8 * s);
            ctx.stroke();
        },

        drawCoal(ctx, size) {
            const s = size / 32;
            ctx.fillStyle = '#1a1a1a';

            // Irregular coal chunk
            ctx.beginPath();
            ctx.moveTo(8 * s, 16 * s);
            ctx.lineTo(12 * s, 8 * s);
            ctx.lineTo(20 * s, 6 * s);
            ctx.lineTo(26 * s, 12 * s);
            ctx.lineTo(24 * s, 22 * s);
            ctx.lineTo(16 * s, 26 * s);
            ctx.lineTo(10 * s, 24 * s);
            ctx.closePath();
            ctx.fill();

            // Shiny spots
            ctx.fillStyle = '#333';
            ctx.fillRect(14 * s, 12 * s, 4 * s, 3 * s);
            ctx.fillRect(18 * s, 16 * s, 3 * s, 4 * s);
        },

        drawIngot(ctx, size, color, shadow) {
            const s = size / 32;

            // 3D ingot shape
            ctx.fillStyle = shadow;
            ctx.beginPath();
            ctx.moveTo(4 * s, 20 * s);
            ctx.lineTo(8 * s, 26 * s);
            ctx.lineTo(28 * s, 26 * s);
            ctx.lineTo(28 * s, 16 * s);
            ctx.lineTo(24 * s, 12 * s);
            ctx.lineTo(4 * s, 12 * s);
            ctx.closePath();
            ctx.fill();

            // Top face
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(4 * s, 12 * s);
            ctx.lineTo(8 * s, 8 * s);
            ctx.lineTo(28 * s, 8 * s);
            ctx.lineTo(24 * s, 12 * s);
            ctx.closePath();
            ctx.fill();

            // Front face
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(4 * s, 12 * s);
            ctx.lineTo(4 * s, 20 * s);
            ctx.lineTo(8 * s, 26 * s);
            ctx.lineTo(8 * s, 8 * s);
            ctx.closePath();
            ctx.fill();

            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(6 * s, 9 * s, 18 * s, 2 * s);
        },

        drawDiamond(ctx, size) {
            const s = size / 32;

            // Diamond gem shape
            ctx.fillStyle = '#00CED1';
            ctx.beginPath();
            ctx.moveTo(16 * s, 4 * s);   // Top
            ctx.lineTo(26 * s, 12 * s);  // Top right
            ctx.lineTo(22 * s, 28 * s);  // Bottom right
            ctx.lineTo(10 * s, 28 * s);  // Bottom left
            ctx.lineTo(6 * s, 12 * s);   // Top left
            ctx.closePath();
            ctx.fill();

            // Facets
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = 1 * s;
            ctx.beginPath();
            ctx.moveTo(16 * s, 4 * s);
            ctx.lineTo(16 * s, 28 * s);
            ctx.moveTo(6 * s, 12 * s);
            ctx.lineTo(26 * s, 12 * s);
            ctx.moveTo(16 * s, 12 * s);
            ctx.lineTo(10 * s, 28 * s);
            ctx.moveTo(16 * s, 12 * s);
            ctx.lineTo(22 * s, 28 * s);
            ctx.stroke();

            // Shine
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.moveTo(16 * s, 4 * s);
            ctx.lineTo(10 * s, 12 * s);
            ctx.lineTo(16 * s, 12 * s);
            ctx.closePath();
            ctx.fill();
        },

        drawApple(ctx, size) {
            const s = size / 32;

            // Apple body (red)
            ctx.fillStyle = '#cc2222';
            ctx.beginPath();
            ctx.ellipse(16 * s, 18 * s, 10 * s, 11 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Darker shade
            ctx.fillStyle = '#aa1111';
            ctx.beginPath();
            ctx.ellipse(20 * s, 20 * s, 6 * s, 8 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.ellipse(12 * s, 14 * s, 4 * s, 5 * s, -0.5, 0, Math.PI * 2);
            ctx.fill();

            // Stem
            ctx.strokeStyle = '#5a3d2b';
            ctx.lineWidth = 2 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(16 * s, 7 * s);
            ctx.quadraticCurveTo(18 * s, 4 * s, 20 * s, 5 * s);
            ctx.stroke();

            // Leaf
            ctx.fillStyle = '#228822';
            ctx.beginPath();
            ctx.ellipse(22 * s, 6 * s, 4 * s, 2 * s, 0.5, 0, Math.PI * 2);
            ctx.fill();
        }
    };

    // --- WORLD GENERATION ---
    class World {
        constructor(width, height, seed) {
            this.width = width;
            this.height = height;
            this.seed = seed || Math.random() * 10000;
            this.noise = new SimplexNoise(this.seed);
            this.caveNoise = new SimplexNoise(this.seed + 1000);
            this.oreNoise = new SimplexNoise(this.seed + 2000);

            // Chunk-based loading
            this.chunkSize = 16;
            this.chunks = new Map();
            this.modifiedBlocks = new Map(); // Track player modifications
        }

        getChunkKey(cx, cy) {
            return `${cx},${cy}`;
        }

        getBlock(x, y) {
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
                return BLOCKS.AIR;
            }

            // Check for player modifications first
            const modKey = `${x},${y}`;
            if (this.modifiedBlocks.has(modKey)) {
                return BLOCK_BY_ID[this.modifiedBlocks.get(modKey)];
            }

            // Generate if needed
            const cx = Math.floor(x / this.chunkSize);
            const cy = Math.floor(y / this.chunkSize);
            const chunkKey = this.getChunkKey(cx, cy);

            if (!this.chunks.has(chunkKey)) {
                this.generateChunk(cx, cy);
            }

            const chunk = this.chunks.get(chunkKey);
            const lx = x - cx * this.chunkSize;
            const ly = y - cy * this.chunkSize;

            return BLOCK_BY_ID[chunk[ly * this.chunkSize + lx]] || BLOCKS.AIR;
        }

        setBlock(x, y, blockType) {
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;

            const modKey = `${x},${y}`;
            this.modifiedBlocks.set(modKey, blockType.id);
        }

        generateChunk(cx, cy) {
            const chunk = new Uint8Array(this.chunkSize * this.chunkSize);

            for (let ly = 0; ly < this.chunkSize; ly++) {
                for (let lx = 0; lx < this.chunkSize; lx++) {
                    const x = cx * this.chunkSize + lx;
                    const y = cy * this.chunkSize + ly;

                    chunk[ly * this.chunkSize + lx] = this.generateBlock(x, y);
                }
            }

            this.chunks.set(this.getChunkKey(cx, cy), chunk);
        }

        generateBlock(x, y) {
            // Get surface height using multi-octave noise
            const surfaceNoise = this.noise.octaveNoise(x * 0.02, 0, 4, 0.5);
            const surfaceHeight = CONFIG.SURFACE_HEIGHT + Math.floor(surfaceNoise * 20);

            // Bedrock layer (deterministic based on seed + coords)
            if (y >= this.height - 3) {
                if (y >= this.height - 1 || hash2i(this.seed, x, y) < 0.5) {
                    return BLOCKS.BEDROCK.id;
                }
            }

            // Above ground
            if (y < surfaceHeight) {
                return BLOCKS.AIR.id;
            }

            // Cave generation
            const caveValue = this.caveNoise.octaveNoise(x * 0.05, y * 0.05, 3, 0.5);
            const caveThreshold = 0.3 + (y / this.height) * 0.1; // Caves more common deeper

            if (y > surfaceHeight + 5 && caveValue > caveThreshold) {
                return BLOCKS.AIR.id;
            }

            // Surface layer
            if (y === surfaceHeight) {
                return BLOCKS.GRASS.id;
            }

            // Dirt layer (3-5 blocks deep)
            const dirtDepth = 3 + Math.floor(this.noise.noise2D(x * 0.1, y * 0.1) * 2);
            if (y <= surfaceHeight + dirtDepth) {
                return BLOCKS.DIRT.id;
            }

            // Stone with ores
            const depth = y - surfaceHeight;

            // Diamond (deep)
            if (depth > 100 && this.oreNoise.noise2D(x * 0.1, y * 0.1) > 0.85) {
                return BLOCKS.DIAMOND_ORE.id;
            }

            // Gold (medium-deep)
            if (depth > 60 && this.oreNoise.noise2D(x * 0.15 + 100, y * 0.15) > 0.8) {
                return BLOCKS.GOLD_ORE.id;
            }

            // Iron (everywhere below surface)
            if (depth > 20 && this.oreNoise.noise2D(x * 0.12 + 200, y * 0.12) > 0.75) {
                return BLOCKS.IRON_ORE.id;
            }

            // Coal (shallow to medium)
            if (depth > 5 && depth < 80 && this.oreNoise.noise2D(x * 0.08 + 300, y * 0.08) > 0.7) {
                return BLOCKS.COAL_ORE.id;
            }

            return BLOCKS.STONE.id;
        }

        // Generate trees after initial terrain
        generateTree(baseX, baseY) {
            // Tree height is deterministic based on position
            const trunkHeight = 4 + Math.floor(hash2i(this.seed, baseX, baseY) * 3);

            // Trunk
            for (let y = 0; y < trunkHeight; y++) {
                this.setBlock(baseX, baseY - y - 1, BLOCKS.WOOD);
            }

            // Leaves
            const leafStart = baseY - trunkHeight;
            for (let dy = -2; dy <= 1; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    if (Math.abs(dx) === 2 && Math.abs(dy) === 1) continue;
                    if (dx === 0 && dy <= 0) continue; // Leave space for trunk top
                    if (Math.abs(dx) + Math.abs(dy) > 3) continue;

                    const lx = baseX + dx;
                    const ly = leafStart + dy;

                    if (this.getBlock(lx, ly).id === BLOCKS.AIR.id) {
                        this.setBlock(lx, ly, BLOCKS.LEAVES);
                    }
                }
            }

            // Top leaves
            this.setBlock(baseX, leafStart - 2, BLOCKS.LEAVES);
            this.setBlock(baseX - 1, leafStart - 1, BLOCKS.LEAVES);
            this.setBlock(baseX + 1, leafStart - 1, BLOCKS.LEAVES);
            this.setBlock(baseX, leafStart - 1, BLOCKS.LEAVES);
        }
    }

    // --- ENTITY BASE CLASS (shared physics/collision) ---
    class Entity {
        constructor(x, y, width, height) {
            Object.assign(this, { x, y, width, height, vx: 0, vy: 0, onGround: false, facingRight: true });
        }

        checkCollision(world, x, y) {
            const [l, r, t, b] = [x - this.width / 2, x + this.width / 2, y - this.height, y];
            return [[l, t], [r, t], [l, b - 0.01], [r, b - 0.01], [l, (t + b) / 2], [r, (t + b) / 2]]
                .some(([px, py]) => world.getBlock(Math.floor(px), Math.floor(py)).solid);
        }

        moveWithCollision(world, dx, dy, steps = 10) {
            const [stepX, stepY] = [dx / steps, dy / steps];
            for (let i = 0; i < steps; i++) {
                if (!this.checkCollision(world, this.x + stepX, this.y)) this.x += stepX;
                if (!this.checkCollision(world, this.x, this.y + stepY)) this.y += stepY;
                else { if (dy > 0) this.onGround = true; this.vy = 0; }
            }
            if (!this.checkCollision(world, this.x, this.y + 0.1)) this.onGround = false;
        }

        distanceTo(other) {
            const [dx, dy] = [other.x - this.x, other.y - this.y];
            return Math.sqrt(dx * dx + dy * dy);
        }
    }

    class Player extends Entity {
        constructor(x, y) {
            super(x, y, CONFIG.PLAYER_WIDTH, CONFIG.PLAYER_HEIGHT);
            Object.assign(this, {
                maxHealth: 20, health: 20, isDead: false,
                fallStartY: y, isFalling: false,
                swingAngle: 0, isSwinging: false, swingProgress: 0,
                inventory: Array(9).fill(null), selectedSlot: 0,
            });
            [TOOLS.WOOD_PICKAXE, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD]
                .forEach((item, i) => this.addToInventory(item, [1, 64, 32, 16][i]));
        }

        getHeldItem() {
            const slot = this.inventory[this.selectedSlot];
            return slot ? getItemById(slot.itemId) : null;
        }

        getHeldTool() {
            const slot = this.inventory[this.selectedSlot];
            return slot && TOOL_BY_ID[slot.itemId] || null;
        }

        getMiningSpeed(block) {
            const tool = this.getHeldTool();
            if (!tool || !block.toolType || tool.type !== block.toolType) return 1;
            const tierInfo = TOOL_TIERS[tool.tier];
            return tierInfo.tier >= (block.minTier || 0) ? tierInfo.speedMultiplier : 1;
        }

        canHarvest(block) {
            if (!block.minTier) return true;
            const tool = this.getHeldTool();
            return tool?.type === block.toolType && TOOL_TIERS[tool.tier].tier >= block.minTier;
        }

        startSwing() {
            if (!this.isSwinging) Object.assign(this, { isSwinging: true, swingProgress: 0 });
        }

        updateSwing(dt) {
            if (!this.isSwinging) return;
            this.swingProgress += dt / 200;
            this.swingAngle = Math.sin(this.swingProgress * Math.PI) * 90;
            if (this.swingProgress >= 1) Object.assign(this, { isSwinging: false, swingAngle: 0, swingProgress: 0 });
        }

        takeDamage(amount) {
            if (this.isDead) return;
            this.health = Math.max(0, this.health - amount);
            if (this.health <= 0) this.isDead = true;
            return this.health;
        }

        heal(amount) { this.health = Math.min(this.maxHealth, this.health + amount); }

        respawn(x, y) {
            Object.assign(this, { x, y, vx: 0, vy: 0, health: this.maxHealth, isDead: false, fallStartY: y, isFalling: false });
        }

        addToInventory(item, count = 1) {
            const [canStack, maxStack] = [isStackable(item), isStackable(item) ? 64 : 1];
            let remaining = count;

            // Stack with existing slots first
            if (canStack) {
                for (const slot of this.inventory.filter(s => s?.itemId === item.id)) {
                    const add = Math.min(maxStack - slot.count, remaining);
                    slot.count += add;
                    remaining -= add;
                    if (!remaining) return 0;
                }
            }

            // Fill empty slots
            for (let i = 0; i < this.inventory.length && remaining > 0; i++) {
                if (!this.inventory[i]) {
                    const add = Math.min(maxStack, remaining);
                    this.inventory[i] = { itemId: item.id, count: add };
                    remaining -= add;
                }
            }
            return remaining;
        }

        removeFromInventory(slot, count = 1) {
            if (!this.inventory[slot]) return false;
            if ((this.inventory[slot].count -= count) <= 0) this.inventory[slot] = null;
            return true;
        }

        getSelectedBlock() {
            const item = this.getHeldItem();
            return item?.kind === 'block' ? item : null;
        }

        update(world, keys, dt) {
            if (this.isDead) return 0;
            const dtSeconds = dt / 1000;

            // Movement
            this.vx = keys.left ? -CONFIG.MOVE_SPEED : keys.right ? CONFIG.MOVE_SPEED : 0;
            if (keys.left) this.facingRight = false;
            if (keys.right) this.facingRight = true;
            if (keys.jump && this.onGround) { this.vy = -CONFIG.JUMP_FORCE; this.onGround = false; }

            // Fall tracking
            if (this.onGround && this.vy >= 0) { this.fallStartY = this.y; this.isFalling = false; }
            if (!this.onGround && this.vy > 0 && !this.isFalling) { this.fallStartY = this.y; this.isFalling = true; }

            // Physics
            this.vy = Math.min(this.vy + CONFIG.GRAVITY * dtSeconds, CONFIG.TERMINAL_VELOCITY);
            this.moveWithCollision(world, this.vx * dtSeconds, this.vy * dtSeconds);

            // Fall damage
            let fallDamage = 0;
            if (this.onGround && this.isFalling) {
                const dist = this.y - this.fallStartY;
                if (dist > 3) { fallDamage = Math.floor(dist - 3); this.takeDamage(fallDamage); }
                this.isFalling = false;
            }

            return fallDamage;
        }
        // moveWithCollision and checkCollision inherited from Entity
    }

    // --- MOB SYSTEM ---
    const MOB_TYPES = {
        zombie: { health: 10, damage: 2, speed: 1.5, color: '#2a6e2a' },
    };

    class Mob extends Entity {
        constructor(x, y, type = 'zombie') {
            super(x, y, 0.6, 1.8);
            const s = MOB_TYPES[type];
            Object.assign(this, {
                type, maxHealth: s.health, health: s.health, damage: s.damage, speed: s.speed, color: s.color,
                isDead: false, aiState: 'idle', targetPlayer: null,
                jumpCooldown: 0, invincibleTime: 0, knockbackX: 0, attackCooldown: 0,
            });
        }

        update(world, player, dt) {
            if (this.isDead) return;
            const dtSec = dt / 1000;

            // Tick cooldowns
            ['invincibleTime', 'jumpCooldown', 'attackCooldown'].forEach(k => { if (this[k] > 0) this[k] -= dtSec; });

            // Distance to player
            const [distX, distY] = [player.x - this.x, player.y - this.y];
            const dist = Math.sqrt(distX * distX + distY * distY);

            // Aggro
            if (dist < 15) { this.aiState = 'chase'; this.targetPlayer = player; }
            else if (dist > 20) { this.aiState = 'idle'; this.targetPlayer = null; }

            // Chase movement
            if (this.aiState === 'chase' && this.targetPlayer && !this.targetPlayer.isDead) {
                this.vx = Math.abs(distX) > 0.5 ? Math.sign(distX) * this.speed : 0;
                if (distX > 0.5) this.facingRight = true;
                if (distX < -0.5) this.facingRight = false;

                // Jump if blocked or player above
                if (this.onGround && this.jumpCooldown <= 0) {
                    const blocked = world.getBlock(Math.floor(this.x + (this.facingRight ? 0.5 : -0.5)), Math.floor(this.y - 0.5)).solid;
                    if (blocked || distY < -1.5) {
                        this.vy = -CONFIG.JUMP_FORCE * 0.8;
                        this.onGround = false;
                        this.jumpCooldown = 0.5;
                    }
                }
            } else this.vx = 0;

            // Knockback decay
            if (this.knockbackX) {
                this.vx += this.knockbackX;
                this.knockbackX *= 0.8;
                if (Math.abs(this.knockbackX) < 0.1) this.knockbackX = 0;
            }

            // Physics
            this.vy = Math.min(this.vy + CONFIG.GRAVITY * dtSec, CONFIG.TERMINAL_VELOCITY);
            this.moveWithCollision(world, this.vx * dtSec, this.vy * dtSec);

            // Attack player on contact
            if (this.attackCooldown <= 0 && this.targetPlayer && !this.targetPlayer.isDead && this.distanceTo(this.targetPlayer) < 1.0) {
                this.targetPlayer.takeDamage(this.damage);
                this.attackCooldown = 1.0;
                return { hitPlayer: true, damage: this.damage };
            }
            return null;
        }

        takeDamage(amount, knockbackDir = 0) {
            if (this.invincibleTime > 0 || this.isDead) return false;
            this.health -= amount;
            this.invincibleTime = 0.3;
            this.knockbackX = knockbackDir * 8;
            if (this.health <= 0) this.isDead = true;
            return this.isDead;
        }

        containsPoint(wx, wy) {
            const hw = this.width / 2;
            return wx >= this.x - hw && wx <= this.x + hw && wy <= this.y && wy >= this.y - this.height;
        }
    }

    // --- MOB SYSTEM MANAGER ---
    class MobSystem {
        constructor(maxMobs = 8) {
            Object.assign(this, { mobs: [], maxMobs, spawnCooldown: 0, player: null, world: null, onMobHitPlayer: null, onMobKilled: null });
        }

        setPlayer(player) { this.player = player; }
        setWorld(world) { this.world = world; }
        setCallbacks(onHit, onKill) { Object.assign(this, { onMobHitPlayer: onHit, onMobKilled: onKill }); }

        update(dt, dayProgress) {
            if (!this.player || !this.world) return;

            // Update and cull mobs
            this.mobs = this.mobs.filter(mob => {
                const result = mob.update(this.world, this.player, dt);
                if (result?.hitPlayer) this.onMobHitPlayer?.();
                return !mob.isDead && Math.abs(mob.x - this.player.x) <= 50;
            });

            // Spawn at night
            const isNight = dayProgress > 0.75 || dayProgress < 0.25;
            this.spawnCooldown -= dt / 1000;
            if (!isNight || this.spawnCooldown > 0 || this.mobs.length >= this.maxMobs) return;

            this.spawnCooldown = 3 + Math.random() * 5;
            const spawnX = this.player.x + (Math.random() < 0.5 ? -1 : 1) * (15 + Math.random() * 10);

            // Find ground
            let spawnY = 0;
            for (let y = 0; y < CONFIG.WORLD_HEIGHT && !this.world.getBlock(Math.floor(spawnX), y).solid; y++) spawnY = y;

            // Validate spawn location
            if (spawnY > this.player.y + 10) return;
            const floorX = Math.floor(spawnX), floorY = Math.floor(spawnY);
            if (this.world.getBlock(floorX, floorY).solid || this.world.getBlock(floorX, floorY - 1).solid) return;

            this.mobs.push(new Mob(spawnX, spawnY, 'zombie'));
        }

        tryAttackMob(worldX, worldY, heldItem) {
            const mob = this.mobs.find(m => !m.isDead && m.containsPoint(worldX, worldY));
            if (!mob) return null;
            const died = mob.takeDamage(heldItem?.damage ?? 1, mob.x > this.player.x ? 1 : -1);
            if (died) this.onMobKilled?.(mob.type);
            return mob;
        }

        render(ctx, screenWidth, screenHeight, cameraX, cameraY) {
            const [bs, cx, cy] = [CONFIG.BLOCK_SIZE, screenWidth / 2, screenHeight / 2];

            for (const mob of this.mobs.filter(m => !m.isDead)) {
                const [px, py] = [cx + (mob.x - cameraX) * bs, cy + (mob.y - cameraY) * bs];
                const [w, h] = [mob.width * bs, mob.height * bs];
                const hurt = mob.invincibleTime > 0;
                const dir = mob.facingRight ? 1 : -1;

                ctx.fillStyle = hurt ? '#fff' : mob.color;
                ctx.fillRect(px - w/2, py - h * 0.7, w, h * 0.5); // Body
                ctx.fillRect(px + dir * w * 0.3, py - h * 0.6, w * 0.5 * dir, h * 0.1); // Arm

                ctx.fillStyle = hurt ? '#fff' : '#4a8c4a';
                ctx.fillRect(px - w/2 * 0.9, py - h, w * 0.9, h * 0.35); // Head

                ctx.fillStyle = '#f00';
                const eo = dir * 0.1 * w;
                ctx.fillRect(px - w * 0.15 + eo, py - h * 0.9, w * 0.12, w * 0.08); // Eyes
                ctx.fillRect(px + w * 0.05 + eo, py - h * 0.9, w * 0.12, w * 0.08);

                ctx.fillStyle = hurt ? '#fff' : '#1a4a1a';
                ctx.fillRect(px - w/2, py - h * 0.2, w * 0.35, h * 0.2); // Legs
                ctx.fillRect(px + w/2 - w * 0.35, py - h * 0.2, w * 0.35, h * 0.2);

                if (mob.health < mob.maxHealth) { // Health bar
                    ctx.fillStyle = '#333'; ctx.fillRect(px - w/2, py - h - 10, w, 4);
                    ctx.fillStyle = '#f33'; ctx.fillRect(px - w/2, py - h - 10, w * mob.health / mob.maxHealth, 4);
                }
            }
        }
    }

    // --- FURNACE SYSTEM ---
    class FurnaceSystem {
        constructor(dom, getItemTexture) {
            this.dom = dom;
            this.getItemTexture = getItemTexture;
            this.furnaces = new Map(); // Store furnace states by "x,y"
            this.isOpen = false;
            this.active = null; // Currently open furnace
            this.player = null; // Set by Game after player is created
            this.onUIUpdate = null; // Callback for when UI needs updating

            // Setup event handlers
            document.getElementById('furnaceClose').onclick = () => this.close();
            document.getElementById('furnaceOverlay').onclick = (e) => {
                if (e.target.id === 'furnaceOverlay') this.close();
            };
            document.getElementById('furnaceInput').onclick = () => this.handleSlotClick('input');
            document.getElementById('furnaceFuel').onclick = () => this.handleSlotClick('fuel');
            document.getElementById('furnaceOutput').onclick = () => this.handleSlotClick('output');
        }

        setPlayer(player) { this.player = player; }
        setUIUpdateCallback(callback) { this.onUIUpdate = callback; }

        // For save/load
        getState() { return Array.from(this.furnaces.entries()); }
        loadState(entries) { if (entries) this.furnaces = new Map(entries); }

        getOrCreate(x, y) {
            const key = `${x},${y}`;
            if (!this.furnaces.has(key)) {
                this.furnaces.set(key, {
                    x, y,
                    input: null, fuel: null, output: null,
                    progress: 0, burnTime: 0
                });
            }
            return this.furnaces.get(key);
        }

        open(x, y) {
            this.isOpen = true;
            this.active = this.getOrCreate(x, y);
            this.dom.furnaceOverlay.classList.add('show');
            this.updateUI();
        }

        close() {
            this.isOpen = false;
            this.active = null;
            this.dom.furnaceOverlay.classList.remove('show');
        }

        handleSlotClick(slotType) {
            if (!this.active || !this.player) return;
            const held = this.player.inventory[this.player.selectedSlot];
            const slot = this.active[slotType];

            // Validation: what can go where
            const canAccept = {
                input: held && SMELT_BY_INPUT.has(held.itemId),
                fuel: held?.itemId === ITEMS.COAL.id,
                output: false,
            }[slotType];

            if (held && canAccept) {
                // Place item into slot
                if (!slot) this.active[slotType] = { itemId: held.itemId, count: held.count };
                else if (slot.itemId === held.itemId) slot.count += held.count;
                else { this.updateUI(); return; }
                this.player.inventory[this.player.selectedSlot] = null;
            } else if (!held && slot) {
                // Take item from slot
                if (this.player.addToInventory(getItemById(slot.itemId), slot.count) === 0)
                    this.active[slotType] = null;
            }
            this.updateUI();
            this.onUIUpdate?.();
        }

        updateUI() {
            if (!this.active) return;

            const renderSlot = (el, data) => {
                el.innerHTML = '';
                if (!data) return;
                const canvas = Object.assign(document.createElement('canvas'), { width: 32, height: 32 });
                const tex = this.getItemTexture(getItemById(data.itemId), 32);
                if (tex) canvas.getContext('2d').drawImage(tex, 0, 0, 32, 32);
                el.appendChild(canvas);
                if (data.count > 1) el.appendChild(Object.assign(document.createElement('span'),
                    { className: 'slot-count', textContent: data.count }));
            };

            ['input', 'fuel', 'output'].forEach(s => renderSlot(this.dom['furnace' + s[0].toUpperCase() + s.slice(1)], this.active[s]));

            const burning = this.active.burnTime > 0;
            this.dom.furnaceFire.classList.toggle('burning', burning);
            this.dom.furnaceArrow.classList.toggle('active', burning);
            this.dom.furnaceProgress.style.width = (this.active.progress * 100) + '%';
        }

        update(dt, world) {
            const dtSec = dt / 1000;

            for (const [key, f] of this.furnaces) {
                // Remove if block destroyed
                if (world.getBlock(f.x, f.y).id !== BLOCKS.FURNACE.id) { this.furnaces.delete(key); continue; }

                const recipe = f.input?.count > 0 && SMELT_BY_INPUT.get(f.input.itemId);
                const canOutput = recipe && (!f.output || (f.output.itemId === recipe.output.id && f.output.count < 64));

                if (canOutput) {
                    // Consume fuel if needed
                    if (f.burnTime <= 0 && f.fuel?.count > 0) {
                        if (--f.fuel.count <= 0) f.fuel = null;
                        f.burnTime = 80;
                    }
                    // Smelt
                    if (f.burnTime > 0) {
                        f.burnTime -= dtSec;
                        if ((f.progress += dtSec / recipe.time) >= 1) {
                            f.progress = 0;
                            if (--f.input.count <= 0) f.input = null;
                            f.output ? f.output.count++ : (f.output = { itemId: recipe.output.id, count: 1 });
                        }
                    }
                } else {
                    f.progress = 0;
                    if (f.burnTime > 0 && !f.input) f.burnTime -= dtSec;
                }
            }

            if (this.isOpen && this.active) this.updateUI();
        }
    }

    // --- CRAFTING SYSTEM ---
    class CraftingSystem {
        constructor(dom, getItemTexture) {
            this.dom = dom;
            this.getItemTexture = getItemTexture;
            this.isOpen = false;
            this.player = null;
            this.onUIUpdate = null;
            this.onNotification = null;

            // Setup event handlers
            document.getElementById('craftingClose').onclick = () => this.close();
            document.getElementById('craftingOverlay').onclick = (e) => {
                if (e.target.id === 'craftingOverlay') this.close();
            };
        }

        setPlayer(player) { this.player = player; }
        setCallbacks(onUIUpdate, onNotification) {
            this.onUIUpdate = onUIUpdate;
            this.onNotification = onNotification;
        }

        toggle() {
            if (this.isOpen) this.close();
            else this.open();
        }

        open() {
            this.isOpen = true;
            this.dom.craftingOverlay.classList.add('show');
            this.renderRecipes();
        }

        close() {
            this.isOpen = false;
            this.dom.craftingOverlay.classList.remove('show');
        }

        countItem(itemId) {
            let count = 0;
            for (const slot of this.player.inventory) {
                if (slot && slot.itemId === itemId) count += slot.count;
            }
            return count;
        }

        canCraft(recipe) {
            for (const ingredient of recipe.ingredients) {
                if (this.countItem(ingredient.item.id) < ingredient.count) return false;
            }
            return true;
        }

        consumeIngredients(recipe) {
            for (const ingredient of recipe.ingredients) {
                let remaining = ingredient.count;
                for (let i = 0; i < this.player.inventory.length && remaining > 0; i++) {
                    const slot = this.player.inventory[i];
                    if (slot && slot.itemId === ingredient.item.id) {
                        const take = Math.min(slot.count, remaining);
                        slot.count -= take;
                        remaining -= take;
                        if (slot.count <= 0) this.player.inventory[i] = null;
                    }
                }
            }
        }

        craft(recipe) {
            if (!this.canCraft(recipe)) return false;

            const result = recipe.result;
            const resultCount = recipe.resultCount;

            // Test if result fits (virtual inventory check)
            const testInv = structuredClone(this.player.inventory);

            // Virtually consume ingredients
            for (const ingredient of recipe.ingredients) {
                let remaining = ingredient.count;
                for (let i = 0; i < testInv.length && remaining > 0; i++) {
                    const slot = testInv[i];
                    if (slot && slot.itemId === ingredient.item.id) {
                        const take = Math.min(slot.count, remaining);
                        slot.count -= take;
                        remaining -= take;
                        if (slot.count <= 0) testInv[i] = null;
                    }
                }
            }

            // Check if result fits
            let canFit = false;
            const canStack = isStackable(result);
            const maxStack = canStack ? 64 : 1;

            if (canStack) {
                for (const slot of testInv) {
                    if (slot && slot.itemId === result.id && slot.count + resultCount <= maxStack) {
                        canFit = true;
                        break;
                    }
                }
            }
            if (!canFit) {
                for (const slot of testInv) {
                    if (!slot) { canFit = true; break; }
                }
            }

            if (!canFit) {
                if (this.onNotification) this.onNotification('Inventory full!');
                return false;
            }

            // Actually craft
            this.consumeIngredients(recipe);
            this.player.addToInventory(result, resultCount);
            if (this.onUIUpdate) this.onUIUpdate();
            this.renderRecipes();
            return true;
        }

        renderRecipes() {
            const container = this.dom.craftingRecipes;
            container.innerHTML = '';

            // Group recipes by category (derived from result properties)
            const getCategory = (r) => {
                if (r.kind === 'item' || r.id === BLOCKS.PLANKS.id) return 'Materials';
                if (r.tier) return `${r.tier[0].toUpperCase() + r.tier.slice(1)} Tools`;
                return 'Blocks';
            };
            const categories = {};
            for (const recipe of RECIPES) {
                const cat = getCategory(recipe.result);
                (categories[cat] ??= []).push(recipe);
            }

            for (const [category, recipes] of Object.entries(categories)) {
                if (recipes.length === 0) continue;

                const section = document.createElement('div');
                section.className = 'craft-section';
                section.innerHTML = `<h3>${category}</h3>`;

                const grid = document.createElement('div');
                grid.className = 'recipe-grid';

                for (const recipe of recipes) {
                    const canCraft = this.canCraft(recipe);
                    const item = document.createElement('div');
                    item.className = 'recipe-item' + (canCraft ? ' can-craft' : '');

                    // Header with icon and name
                    const header = document.createElement('div');
                    header.className = 'recipe-header';

                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'recipe-icon';
                    const texture = this.getItemTexture(recipe.result, 32);
                    if (texture) {
                        const img = document.createElement('canvas');
                        img.width = 24; img.height = 24;
                        img.getContext('2d').drawImage(texture, 0, 0, 24, 24);
                        iconDiv.appendChild(img);
                    }
                    header.appendChild(iconDiv);

                    const nameDiv = document.createElement('div');
                    nameDiv.innerHTML = `<div class="recipe-name">${recipe.result.name}</div>` +
                        (recipe.resultCount > 1 ? `<div class="recipe-count">x${recipe.resultCount}</div>` : '');
                    header.appendChild(nameDiv);
                    item.appendChild(header);

                    // Ingredients
                    const ingredientsDiv = document.createElement('div');
                    ingredientsDiv.className = 'recipe-ingredients';

                    for (const ing of recipe.ingredients) {
                        const ingDiv = document.createElement('div');
                        ingDiv.className = 'ingredient';

                        const ingTexture = this.getItemTexture(ing.item, 16);
                        if (ingTexture) {
                            const ingImg = document.createElement('canvas');
                            ingImg.className = 'ingredient-icon';
                            ingImg.width = 16; ingImg.height = 16;
                            ingImg.getContext('2d').drawImage(ingTexture, 0, 0, 16, 16);
                            ingDiv.appendChild(ingImg);
                        }

                        const hasCount = this.countItem(ing.item.id);
                        const hasEnough = hasCount >= ing.count;
                        const textSpan = document.createElement('span');
                        textSpan.className = 'ingredient-text ' + (hasEnough ? 'has-enough' : 'not-enough');
                        textSpan.textContent = `${hasCount}/${ing.count}`;
                        ingDiv.appendChild(textSpan);
                        ingredientsDiv.appendChild(ingDiv);
                    }

                    item.appendChild(ingredientsDiv);
                    item.onclick = () => this.craft(recipe);
                    grid.appendChild(item);
                }

                section.appendChild(grid);
                container.appendChild(section);
            }
        }
    }

    // --- GAME ---
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');

            this.resize();
            window.addEventListener('resize', () => this.resize());

            // Cache DOM elements early (before any showNotification calls)
            this.dom = {
                fps: document.getElementById('fps'),
                position: document.getElementById('position'),
                timeDisplay: document.getElementById('timeDisplay'),
                deathScreen: document.getElementById('deathScreen'),
                miningProgress: document.getElementById('miningProgress'),
                miningFill: document.querySelector('#miningProgress .fill'),
                damageOverlay: document.getElementById('damageOverlay'),
                healthBar: document.getElementById('healthBar'),
                saveNotification: document.getElementById('saveNotification'),
                craftingOverlay: document.getElementById('craftingOverlay'),
                craftingRecipes: document.getElementById('craftingRecipes'),
                furnaceOverlay: document.getElementById('furnaceOverlay'),
                furnaceInput: document.getElementById('furnaceInput'),
                furnaceFuel: document.getElementById('furnaceFuel'),
                furnaceOutput: document.getElementById('furnaceOutput'),
                furnaceFire: document.getElementById('furnaceFire'),
                furnaceArrow: document.getElementById('furnaceArrow'),
                furnaceProgress: document.getElementById('furnaceProgress'),
                touchCrosshair: document.getElementById('touchCrosshair'),
            };

            // Try to load saved game
            const saveData = this.loadGame();

            // Generate world (with saved seed if available)
            const seed = saveData ? saveData.seed : undefined;
            this.world = new World(CONFIG.WORLD_WIDTH, CONFIG.WORLD_HEIGHT, seed);

            if (saveData) {
                // Restore saved game
                console.log('Restoring saved game...');

                // Restore world modifications
                this.world.modifiedBlocks = new Map(saveData.world.modifiedBlocks);

                // Restore player
                this.player = new Player(saveData.player.x, saveData.player.y);

                // Migrate old inventory format (blockId -> itemId)
                const migratedInventory = saveData.player.inventory.map(slot => {
                    if (!slot) return null;
                    // Handle old format with blockId
                    if (slot.blockId !== undefined && slot.itemId === undefined) {
                        return { itemId: slot.blockId, count: slot.count };
                    }
                    return slot;
                });
                this.player.inventory = migratedInventory;
                this.player.selectedSlot = saveData.player.selectedSlot;
                this.player.health = saveData.player.health ?? this.player.maxHealth;

                // Restore time
                this.gameTime = saveData.gameTime || 0;

                // Restore furnaces (will be applied after furnaces Map is created)
                this._savedFurnaces = saveData.furnaces;

                this.showNotification('Game Loaded');
            } else {
                // New game - find spawn point
                const spawnX = Math.floor(CONFIG.WORLD_WIDTH / 2);
                let spawnY = 0;
                for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                    if (this.world.getBlock(spawnX, y).solid) {
                        spawnY = y - 1;
                        break;
                    }
                }

                this.player = new Player(spawnX + 0.5, spawnY);

                // Generate some trees near spawn (but not AT spawn)
                for (let i = -10; i < 10; i++) {
                    const tx = spawnX + i * 8 + Math.floor(Math.random() * 4);

                    // Skip trees too close to spawn point to avoid trapping player
                    if (Math.abs(tx - spawnX) < 4) continue;

                    let ty = 0;
                    for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                        if (this.world.getBlock(tx, y).id === BLOCKS.GRASS.id) {
                            ty = y;
                            break;
                        }
                    }
                    if (ty > 0 && Math.random() < 0.6) {
                        this.world.generateTree(tx, ty);
                    }
                }

                // Clear spawn area (in case of any obstructions)
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -3; dy <= 0; dy++) {
                        const block = this.world.getBlock(spawnX + dx, spawnY + dy);
                        if (block.solid && block.id !== BLOCKS.BEDROCK.id) {
                            this.world.setBlock(spawnX + dx, spawnY + dy, BLOCKS.AIR);
                        }
                    }
                }

                this.gameTime = 0;
            }

            // Camera
            this.cameraX = this.player.x;
            this.cameraY = this.player.y;

            // Input
            this.keys = { left: false, right: false, jump: false };
            this.mouse = { x: 0, y: 0, left: false, right: false };
            this.setupInput();

            // Mining
            this.mining = { active: false, x: 0, y: 0, progress: 0, target: null };

            // Mob System
            this.mobSystem = new MobSystem(8);
            this.mobSystem.setPlayer(this.player);
            this.mobSystem.setWorld(this.world);
            this.mobSystem.setCallbacks(
                () => { this.showDamageEffect(); this.updateHealthBar(); },
                (mobType) => this.showNotification(`${mobType.charAt(0).toUpperCase() + mobType.slice(1)} slain!`)
            );

            // Crafting System
            this.craftingSystem = new CraftingSystem(this.dom, this.getItemTexture.bind(this));
            this.craftingSystem.setPlayer(this.player);
            this.craftingSystem.setCallbacks(() => this.updateUI(), (msg) => this.showNotification(msg));

            // Furnace System
            this.furnaceSystem = new FurnaceSystem(this.dom, this.getItemTexture.bind(this));
            this.furnaceSystem.setPlayer(this.player);
            this.furnaceSystem.setUIUpdateCallback(() => this.updateUI());
            if (this._savedFurnaces) {
                this.furnaceSystem.loadState(this._savedFurnaces);
                delete this._savedFurnaces;
            }

            // Touch controls
            this.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            this.touchMode = 'mine'; // 'mine' or 'place'
            if (this.isTouchDevice) {
                document.body.classList.add('touch-visible');
                this.setupTouchControls();
            }

            // Day/night cycle
            this.dayProgress = (this.gameTime / CONFIG.DAY_LENGTH) % 1;
            if (this.dayProgress === 0) this.dayProgress = 0.25; // Start at morning for new games

            // FPS
            this.frameCount = 0;
            this.lastFpsUpdate = Date.now();
            this.fps = 0;

            // Preload textures
            for (const key of Object.keys(BLOCKS)) {
                if (key !== 'AIR') {
                    TextureGenerator.createTexture(key);
                }
            }

            // Preload tool textures
            for (const key of Object.keys(TOOLS)) {
                TextureGenerator.createToolTexture(key);
            }

            // Preload item textures
            for (const key of Object.keys(ITEMS)) {
                TextureGenerator.createItemTexture(key);
            }

            // UI
            this.setupUI();
            this.updateHealthBar();

            // Respawn button handler
            document.getElementById('respawnBtn').onclick = () => this.respawnPlayer();

            // Auto-save every 30 seconds
            this.autoSaveInterval = setInterval(() => this.saveGame(), 30000);

            // Save on page unload
            window.addEventListener('beforeunload', () => this.saveGame());

            // Start game loop
            this.lastTime = performance.now();
            this.loop();
        }

        resize() {
            // Support high-DPI/retina displays
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = Math.floor(window.innerWidth * dpr);
            this.canvas.height = Math.floor(window.innerHeight * dpr);
            this.canvas.style.width = window.innerWidth + 'px';
            this.canvas.style.height = window.innerHeight + 'px';
            this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            this.ctx.imageSmoothingEnabled = false;
            // Store CSS pixel dimensions for rendering calculations
            this.screenWidth = window.innerWidth;
            this.screenHeight = window.innerHeight;

            // Create/update star canvas for night sky (avoids 100 arc calls per frame)
            this.createStarCanvas();
        }

        createStarCanvas() {
            // Create offscreen canvas for stars
            if (!this.starCanvas) {
                this.starCanvas = document.createElement('canvas');
                this.starCtx = this.starCanvas.getContext('2d');
            }
            this.starCanvas.width = this.screenWidth;
            this.starCanvas.height = this.screenHeight;
            this.lastStarSeed = null; // Force redraw on next render
        }

        renderStarsToCanvas(starSeed) {
            // Only redraw if seed changed (camera moved significantly)
            if (this.lastStarSeed === starSeed) return;
            this.lastStarSeed = starSeed;

            const ctx = this.starCtx;
            ctx.clearRect(0, 0, this.starCanvas.width, this.starCanvas.height);
            ctx.fillStyle = 'white';

            for (let i = 0; i < 100; i++) {
                const sx = ((i * 7919 + starSeed * 104729) % 1000) / 1000 * this.starCanvas.width;
                const sy = ((i * 7901 + starSeed * 104723) % 1000) / 1000 * this.starCanvas.height * 0.6;
                const size = ((i * 7907) % 3) + 1;
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        setupInput() {
            // Key-to-action mappings
            const keyMap = {
                KeyA: 'left', ArrowLeft: 'left',
                KeyD: 'right', ArrowRight: 'right',
                KeyW: 'jump', ArrowUp: 'jump', Space: 'jump',
            };

            document.addEventListener('keydown', (e) => {
                const key = keyMap[e.code];
                if (key) {
                    this.keys[key] = true;
                    if (key === 'jump') e.preventDefault();
                } else if (e.code.startsWith('Digit') && e.code.length === 6) {
                    this.player.selectedSlot = e.code[5] - 1;
                    this.updateUI();
                } else if (e.code === 'KeyP') this.saveGame();
                else if (e.code === 'KeyN' && confirm('Start a new game? Your current progress will be lost.')) {
                    this.deleteSave();
                    location.reload();
                } else if (e.code === 'KeyE') this.craftingSystem.toggle();
                else if (e.code === 'Escape') {
                    this.craftingSystem.isOpen && this.craftingSystem.close();
                    this.furnaceSystem.isOpen && this.furnaceSystem.close();
                }
            });

            document.addEventListener('keyup', (e) => {
                const key = keyMap[e.code];
                if (key) this.keys[key] = false;
            });

            this.canvas.addEventListener('mousemove', (e) => Object.assign(this.mouse, { x: e.clientX, y: e.clientY }));
            this.canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.mouse[e.button === 0 ? 'left' : 'right'] = true;
            });
            this.canvas.addEventListener('mouseup', (e) => {
                if (e.button === 0) { this.mouse.left = false; this.mining.active = false; }
                else this.mouse.right = false;
            });
            this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            this.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                this.player.selectedSlot = (this.player.selectedSlot + (e.deltaY > 0 ? 1 : 8)) % 9;
                this.updateUI();
            });
        }

        setupTouchControls() {
            const buttons = document.querySelectorAll('.touch-btn');
            const modeBtn = document.querySelector('.mode-btn');
            const modeLabel = document.getElementById('modeLabel');
            const crosshair = document.getElementById('touchCrosshair');

            // Prevent default touch behaviors on canvas
            this.canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
            this.canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

            // Handle button touches
            buttons.forEach(btn => {
                const action = btn.dataset.action;

                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    btn.classList.add('active');
                    if (action in this.keys) this.keys[action] = true;
                    else if (action === 'mode') {
                        this.touchMode = this.touchMode === 'mine' ? 'place' : 'mine';
                        modeLabel.textContent = this.touchMode === 'mine' ? 'Mine' : 'Place';
                        modeBtn.textContent = this.touchMode === 'mine' ? '\u26CF' : '\u25A3';
                        modeBtn.classList.toggle('place-mode', this.touchMode === 'place');
                    }
                }, { passive: false });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    btn.classList.remove('active');
                    if (action in this.keys) this.keys[action] = false;
                }, { passive: false });

                btn.addEventListener('touchcancel', (e) => {
                    btn.classList.remove('active');
                    if (action in this.keys) this.keys[action] = false;
                });
            });

            // Handle canvas touch for mining/placing
            let touchHoldTimer = null;
            let isTouchingCanvas = false;

            this.canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    isTouchingCanvas = true;

                    // Update mouse position for block targeting
                    this.mouse.x = touch.clientX;
                    this.mouse.y = touch.clientY;

                    // Update crosshair position
                    this.updateTouchCrosshair();

                    // Start hold timer for mining
                    if (this.touchMode === 'mine') {
                        touchHoldTimer = setTimeout(() => {
                            if (isTouchingCanvas) {
                                this.mouse.left = true;
                            }
                        }, 150); // Small delay to distinguish tap from hold
                    }
                }
            }, { passive: false });

            this.canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isTouchingCanvas) {
                    const touch = e.touches[0];
                    this.mouse.x = touch.clientX;
                    this.mouse.y = touch.clientY;
                    this.updateTouchCrosshair();
                }
            }, { passive: false });

            this.canvas.addEventListener('touchend', (e) => {
                if (touchHoldTimer) {
                    clearTimeout(touchHoldTimer);
                    touchHoldTimer = null;
                }

                if (isTouchingCanvas && e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];

                    // If it was a quick tap and in place mode, place a block
                    if (this.touchMode === 'place' && !this.mouse.left) {
                        this.mouse.x = touch.clientX;
                        this.mouse.y = touch.clientY;
                        this.mouse.right = true;
                        // Reset after a frame
                        setTimeout(() => { this.mouse.right = false; }, 50);
                    }

                    this.mouse.left = false;
                    this.mining.active = false;
                    isTouchingCanvas = false;
                }
            }, { passive: false });

            this.canvas.addEventListener('touchcancel', () => {
                if (touchHoldTimer) {
                    clearTimeout(touchHoldTimer);
                    touchHoldTimer = null;
                }
                this.mouse.left = false;
                this.mining.active = false;
                isTouchingCanvas = false;
            });

            // Initial crosshair position (center of screen)
            this.mouse.x = window.innerWidth / 2;
            this.mouse.y = window.innerHeight / 2;
            this.updateTouchCrosshair();
        }

        updateTouchCrosshair() {
            const crosshair = this.dom.touchCrosshair;
            const blockSize = CONFIG.BLOCK_SIZE;

            // Snap crosshair to block grid
            const target = this.getBlockAtMouse();
            const screenCenterX = this.screenWidth / 2;
            const screenCenterY = this.screenHeight / 2;

            const screenX = screenCenterX + (target.x - this.cameraX) * blockSize;
            const screenY = screenCenterY + (target.y - this.cameraY) * blockSize;

            crosshair.style.left = screenX + 'px';
            crosshair.style.top = screenY + 'px';
            crosshair.style.width = blockSize + 'px';
            crosshair.style.height = blockSize + 'px';
        }

        setupUI() {
            const ui = document.getElementById('ui');
            ui.innerHTML = '';

            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'slot' + (i === this.player.selectedSlot ? ' selected' : '');
                slot.innerHTML = `<span class="slot-key">${i + 1}</span><span class="slot-count"></span>`;
                slot.onclick = () => {
                    this.player.selectedSlot = i;
                    this.updateUI();
                };
                ui.appendChild(slot);
            }

            this.updateUI();
        }

        updateUI() {
            const slots = document.querySelectorAll('.slot');

            slots.forEach((slot, i) => {
                slot.className = 'slot' + (i === this.player.selectedSlot ? ' selected' : '');

                const item = this.player.inventory[i];
                const countEl = slot.querySelector('.slot-count');

                // Clear previous preview
                const existingPreview = slot.querySelector('.block-preview');
                if (existingPreview) existingPreview.remove();

                if (item) {
                    const itemData = getItemById(item.itemId);
                    const preview = document.createElement('canvas');
                    preview.className = 'block-preview';
                    preview.width = 32;
                    preview.height = 32;
                    preview.style.width = '32px';
                    preview.style.height = '32px';

                    const texture = this.getItemTexture(itemData, 32);
                    if (texture) {
                        preview.getContext('2d').drawImage(texture, 0, 0, 32, 32);
                    }

                    slot.insertBefore(preview, countEl);
                    countEl.textContent = item.count > 1 ? item.count : '';
                } else {
                    countEl.textContent = '';
                }
            });
        }

        // Get texture for any item (block, tool, or material)
        getItemTexture(item, size = 32) {
            if (!item) return null;
            if (item.kind === 'tool') return TextureGenerator.createToolTexture(item.key, size);
            if (item.kind === 'item') return TextureGenerator.createItemTexture(item.key, size);
            return TextureGenerator.createTexture(item.key, size);
        }

        getBlockAtMouse() {
            const blockSize = CONFIG.BLOCK_SIZE;
            const screenCenterX = this.screenWidth / 2;
            const screenCenterY = this.screenHeight / 2;

            const worldX = this.cameraX + (this.mouse.x - screenCenterX) / blockSize;
            const worldY = this.cameraY + (this.mouse.y - screenCenterY) / blockSize;

            return {
                x: Math.floor(worldX),
                y: Math.floor(worldY),
                worldX,
                worldY
            };
        }

        handleBlockInteraction(dt) {
            const target = this.getBlockAtMouse();
            const dx = target.worldX - this.player.x;
            const dy = target.worldY - (this.player.y - this.player.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > CONFIG.REACH_DISTANCE) {
                this.mining.active = false;
                return;
            }

            // Left click - attack mobs or mine blocks
            if (this.mouse.left) {
                // Check if clicking on a mob first
                const attackedMob = this.mobSystem.tryAttackMob(target.worldX, target.worldY, this.player.getHeldItem());
                if (attackedMob) {
                    this.player.startSwing();
                    // Don't mine while attacking
                    this.mining.active = false;
                    this.dom.miningProgress.style.display = 'none';
                    return;
                }

                const block = this.world.getBlock(target.x, target.y);

                if (block.id !== BLOCKS.AIR.id && block.hardness !== Infinity) {
                    if (!this.mining.active || this.mining.x !== target.x || this.mining.y !== target.y) {
                        this.mining = {
                            active: true,
                            x: target.x,
                            y: target.y,
                            progress: 0,
                            target: block
                        };
                    }

                    // Start swing animation when mining
                    this.player.startSwing();

                    // Apply tool speed multiplier
                    const miningSpeed = this.player.getMiningSpeed(block);
                    this.mining.progress += (dt / (block.hardness * 1000)) * miningSpeed;

                    // Update mining progress bar
                    const progressBar = this.dom.miningProgress;
                    const fill = this.dom.miningFill;
                    progressBar.style.display = 'block';
                    progressBar.style.left = this.mouse.x - 20 + 'px';
                    progressBar.style.top = this.mouse.y + 20 + 'px';
                    fill.style.width = Math.min(100, this.mining.progress * 100) + '%';

                    if (this.mining.progress >= 1) {
                        // Check if tool can harvest this block (for ores with tier requirements)
                        if (this.player.canHarvest(block) && !block.dropsNothing) {
                            // Determine what to drop
                            let dropItem;
                            if (block.dropsItem) {
                                // Drops a specific item (like coal from coal ore)
                                dropItem = getItemById(block.dropsItem);
                            } else if (block.drops) {
                                // Drops a different block (like cobblestone from stone)
                                dropItem = BLOCKS[block.drops];
                            } else {
                                // Drops itself
                                dropItem = block;
                            }
                            if (dropItem) {
                                this.player.addToInventory(dropItem);
                            }

                            // Check for random bonus drops (like apples from leaves)
                            if (block.randomDrop && Math.random() < block.randomDrop.chance) {
                                const bonusItem = getItemById(block.randomDrop.itemId);
                                if (bonusItem) {
                                    this.player.addToInventory(bonusItem);
                                    this.showNotification('Found an apple!');
                                }
                            }
                        }
                        // Block breaks either way, but no drops if wrong tool tier or dropsNothing
                        this.world.setBlock(target.x, target.y, BLOCKS.AIR);
                        this.mining.active = false;
                        progressBar.style.display = 'none';
                        this.updateUI();
                    }
                }
            } else {
                this.mining.active = false;
                this.dom.miningProgress.style.display = 'none';
            }

            // Right click - place, interact, or eat
            if (this.mouse.right) {
                this.mouse.right = false; // Single action per click

                const currentBlock = this.world.getBlock(target.x, target.y);

                // Check for interactive blocks first (like furnace)
                if (currentBlock.interactive) {
                    if (currentBlock.id === BLOCKS.FURNACE.id) {
                        this.furnaceSystem.open(target.x, target.y);
                    }
                    return;
                }

                // Check if holding food - eat it
                const heldItem = this.player.getHeldItem();
                if (heldItem && heldItem.food) {
                    // Only eat if not at full health
                    if (this.player.health < this.player.maxHealth) {
                        this.player.heal(heldItem.healAmount);
                        this.player.removeFromInventory(this.player.selectedSlot);
                        this.updateUI();
                        this.updateHealthBar();
                        this.showNotification(`+${heldItem.healAmount} HP`);
                    } else {
                        this.showNotification('Already at full health!');
                    }
                    return;
                }

                // Place block if target is air
                if (currentBlock.id === BLOCKS.AIR.id) {
                    const selectedBlock = this.player.getSelectedBlock();
                    if (selectedBlock) {
                        // Check not placing inside player
                        const playerBlocks = [
                            { x: Math.floor(this.player.x), y: Math.floor(this.player.y) },
                            { x: Math.floor(this.player.x), y: Math.floor(this.player.y - 1) }
                        ];

                        const isPlayerPos = playerBlocks.some(pb => pb.x === target.x && pb.y === target.y);

                        if (!isPlayerPos) {
                            this.world.setBlock(target.x, target.y, selectedBlock);
                            this.player.removeFromInventory(this.player.selectedSlot);
                            this.updateUI();
                        }
                    }
                }
            }
        }

        update(dt) {
            // Clamp dt to prevent huge physics jumps after tab switch (centralized)
            dt = Math.min(dt, CONFIG.MAX_DT);

            // Check for death
            if (this.player.isDead) {
                this.dom.deathScreen.classList.add('show');
                return;
            }

            // Update player and check for fall damage
            const fallDamage = this.player.update(this.world, this.keys, dt);

            // Update swing animation
            this.player.updateSwing(dt);

            // Show damage effect
            if (fallDamage > 0) {
                this.showDamageEffect();
            }

            // Update health bar
            this.updateHealthBar();

            // Check for death after damage
            if (this.player.isDead) {
                this.dom.deathScreen.classList.add('show');
                return;
            }

            // Smooth camera follow
            const smoothing = 0.1;
            this.cameraX += (this.player.x - this.cameraX) * smoothing;
            this.cameraY += (this.player.y - this.player.height / 2 - this.cameraY) * smoothing;

            // Handle block interactions
            this.handleBlockInteraction(dt);

            // Update furnaces
            this.furnaceSystem.update(dt, this.world);

            // Update mobs
            this.mobSystem.update(dt, this.dayProgress);

            // Update time
            this.gameTime += dt / 1000;
            this.dayProgress = (this.gameTime / CONFIG.DAY_LENGTH) % 1;
        }

        showDamageEffect() {
            const overlay = this.dom.damageOverlay;
            overlay.classList.add('flash');
            setTimeout(() => overlay.classList.remove('flash'), 150);
        }

        updateHealthBar() {
            const healthBar = this.dom.healthBar;
            const hearts = Math.ceil(this.player.maxHealth / 2); // 10 hearts for 20 HP

            // Build hearts HTML if needed
            if (healthBar.children.length !== hearts) {
                healthBar.innerHTML = '';
                for (let i = 0; i < hearts; i++) {
                    const heart = document.createElement('div');
                    heart.className = 'heart';
                    healthBar.appendChild(heart);
                }
            }

            // Update heart states
            const fullHearts = Math.floor(this.player.health / 2);
            const hasHalfHeart = this.player.health % 2 === 1;

            for (let i = 0; i < hearts; i++) {
                const heart = healthBar.children[i];
                heart.classList.remove('empty', 'half');

                if (i < fullHearts) {
                    // Full heart
                } else if (i === fullHearts && hasHalfHeart) {
                    heart.classList.add('half');
                } else {
                    heart.classList.add('empty');
                }
            }
        }

        respawnPlayer() {
            // Find spawn point
            const spawnX = Math.floor(CONFIG.WORLD_WIDTH / 2);
            let spawnY = 0;
            for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                if (this.world.getBlock(spawnX, y).solid) {
                    spawnY = y - 1;
                    break;
                }
            }

            this.player.respawn(spawnX + 0.5, spawnY);
            this.cameraX = this.player.x;
            this.cameraY = this.player.y;

            this.dom.deathScreen.classList.remove('show');
            this.updateHealthBar();
        }

        render() {
            const ctx = this.ctx;
            const blockSize = CONFIG.BLOCK_SIZE;
            const screenCenterX = this.screenWidth / 2;
            const screenCenterY = this.screenHeight / 2;

            // Sky gradient based on time of day
            this.renderSky();

            // Calculate visible range
            const viewWidth = Math.ceil(this.screenWidth / blockSize) + 2;
            const viewHeight = Math.ceil(this.screenHeight / blockSize) + 2;

            const startX = Math.floor(this.cameraX - viewWidth / 2);
            const startY = Math.floor(this.cameraY - viewHeight / 2);

            // Render blocks
            for (let y = startY; y < startY + viewHeight; y++) {
                for (let x = startX; x < startX + viewWidth; x++) {
                    const block = this.world.getBlock(x, y);

                    if (block.id === BLOCKS.AIR.id) continue;

                    const screenX = screenCenterX + (x - this.cameraX) * blockSize;
                    const screenY = screenCenterY + (y - this.cameraY) * blockSize;

                    const texture = TextureGenerator.createTexture(block.key);
                    ctx.drawImage(texture, screenX, screenY, blockSize, blockSize);
                }
            }

            // Render player
            this.renderPlayer();

            // Render mobs
            this.mobSystem.render(this.ctx, this.screenWidth, this.screenHeight, this.cameraX, this.cameraY);

            // Highlight hovered block
            const target = this.getBlockAtMouse();
            const dx = target.worldX - this.player.x;
            const dy = target.worldY - (this.player.y - this.player.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= CONFIG.REACH_DISTANCE) {
                const block = this.world.getBlock(target.x, target.y);
                const screenX = screenCenterX + (target.x - this.cameraX) * blockSize;
                const screenY = screenCenterY + (target.y - this.cameraY) * blockSize;

                ctx.strokeStyle = block.id === BLOCKS.AIR.id ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, blockSize, blockSize);
                ctx.lineWidth = 1;

                // Mining crack overlay
                if (this.mining.active && this.mining.x === target.x && this.mining.y === target.y) {
                    ctx.fillStyle = `rgba(0,0,0,${this.mining.progress * 0.5})`;
                    ctx.fillRect(screenX, screenY, blockSize, blockSize);
                }
            }

            // Update info display
            this.dom.position.textContent =
                `${Math.floor(this.player.x)}, ${Math.floor(this.player.y)}`;

            const hour = Math.floor(this.dayProgress * 24);
            const isDay = hour >= 6 && hour < 18;
            this.dom.timeDisplay.textContent =
                `${hour.toString().padStart(2, '0')}:00 (${isDay ? 'Day' : 'Night'})`;

            // Update touch crosshair position (follows camera)
            if (this.isTouchDevice) {
                this.updateTouchCrosshair();
            }
        }

        renderSky() {
            const ctx = this.ctx;
            const hour = this.dayProgress * 24;

            let skyTop, skyBottom;

            if (hour >= 6 && hour < 8) {
                // Sunrise
                const t = (hour - 6) / 2;
                skyTop = this.lerpColor('#1a1a3e', '#87CEEB', t);
                skyBottom = this.lerpColor('#4a3060', '#e0f0ff', t);
            } else if (hour >= 8 && hour < 17) {
                // Day
                skyTop = '#87CEEB';
                skyBottom = '#e0f0ff';
            } else if (hour >= 17 && hour < 20) {
                // Sunset
                const t = (hour - 17) / 3;
                skyTop = this.lerpColor('#87CEEB', '#1a1a3e', t);
                skyBottom = this.lerpColor('#e0f0ff', '#4a3060', t);
            } else {
                // Night
                skyTop = '#0a0a1e';
                skyBottom = '#1a1a3e';
            }

            const gradient = ctx.createLinearGradient(0, 0, 0, this.screenHeight);
            gradient.addColorStop(0, skyTop);
            gradient.addColorStop(1, skyBottom);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, this.screenWidth, this.screenHeight);

            // Stars at night (use pre-rendered canvas)
            if (hour < 6 || hour >= 20) {
                const starSeed = Math.floor(this.cameraX / 100);
                this.renderStarsToCanvas(starSeed);
                ctx.drawImage(this.starCanvas, 0, 0);
            }

            // Sun/Moon
            const celestialX = this.screenWidth * (0.2 + this.dayProgress * 0.6);
            const celestialY = this.screenHeight * 0.2 + Math.sin(this.dayProgress * Math.PI) * this.screenHeight * 0.15;

            if (hour >= 6 && hour < 18) {
                // Sun
                ctx.fillStyle = '#fff5b5';
                ctx.shadowColor = '#ffdd00';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            } else {
                // Moon
                ctx.fillStyle = '#e8e8e8';
                ctx.shadowColor = '#ccccff';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        renderPlayer() {
            const ctx = this.ctx;
            const blockSize = CONFIG.BLOCK_SIZE;
            const screenCenterX = this.screenWidth / 2;
            const screenCenterY = this.screenHeight / 2;

            const px = screenCenterX + (this.player.x - this.cameraX) * blockSize;
            const py = screenCenterY + (this.player.y - this.cameraY) * blockSize;

            const w = this.player.width * blockSize;
            const h = this.player.height * blockSize;

            // Body
            ctx.fillStyle = '#3b82f6'; // Blue shirt
            ctx.fillRect(px - w/2, py - h * 0.7, w, h * 0.5);

            // Head
            ctx.fillStyle = '#f5deb3'; // Skin tone
            ctx.fillRect(px - w/2 * 0.8, py - h, w * 0.8, h * 0.35);

            // Eyes
            ctx.fillStyle = '#000';
            const eyeOffset = this.player.facingRight ? 0.15 : -0.15;
            ctx.fillRect(px - w * 0.1 + w * eyeOffset, py - h * 0.9, w * 0.1, w * 0.1);
            ctx.fillRect(px + w * 0.1 + w * eyeOffset, py - h * 0.9, w * 0.1, w * 0.1);

            // Hair
            ctx.fillStyle = '#4a3728';
            ctx.fillRect(px - w/2 * 0.8, py - h, w * 0.8, h * 0.1);

            // Legs
            ctx.fillStyle = '#1e3a5f'; // Dark blue pants
            ctx.fillRect(px - w/2, py - h * 0.2, w * 0.4, h * 0.2);
            ctx.fillRect(px + w/2 - w * 0.4, py - h * 0.2, w * 0.4, h * 0.2);

            // Render held item (tool or block)
            this.renderHeldItem(px, py, w, h);
        }

        renderHeldItem(px, py, w, h) {
            const ctx = this.ctx;
            const heldItem = this.player.getHeldItem();
            if (!heldItem) return;

            // Hand/arm position
            const armX = this.player.facingRight ? px + w * 0.3 : px - w * 0.3;
            const armY = py - h * 0.5;

            ctx.save();
            ctx.translate(armX, armY);

            // Apply swing rotation
            const swingDir = this.player.facingRight ? 1 : -1;
            ctx.rotate((this.player.swingAngle * Math.PI / 180) * swingDir);

            // Flip if facing left
            if (!this.player.facingRight) {
                ctx.scale(-1, 1);
            }

            const itemSize = w * 0.8;
            const sizeScale = { tool: 1.0, item: 0.7, block: 0.6 }[heldItem.kind] || 0.6;
            const texture = this.getItemTexture(heldItem, 32);
            if (texture) {
                const drawSize = itemSize * sizeScale;
                ctx.drawImage(texture, 0, -itemSize * 0.3, drawSize, drawSize);
            }

            ctx.restore();
        }

        lerpColor(a, b, t) {
            const ah = parseInt(a.replace(/#/g, ''), 16);
            const bh = parseInt(b.replace(/#/g, ''), 16);

            const ar = ah >> 16, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
            const br = bh >> 16, bg = (bh >> 8) & 0xff, bb = bh & 0xff;

            const rr = Math.round(ar + (br - ar) * t);
            const rg = Math.round(ag + (bg - ag) * t);
            const rb = Math.round(ab + (bb - ab) * t);

            return `#${((1 << 24) + (rr << 16) + (rg << 8) + rb).toString(16).slice(1)}`;
        }

        // --- SAVE/LOAD SYSTEM ---
        saveGame() {
            try {
                const saveData = {
                    version: 2,
                    timestamp: Date.now(),
                    seed: this.world.seed,
                    player: {
                        x: this.player.x,
                        y: this.player.y,
                        inventory: this.player.inventory,
                        selectedSlot: this.player.selectedSlot,
                        health: this.player.health
                    },
                    world: {
                        // Convert Map to array of [key, value] pairs
                        modifiedBlocks: Array.from(this.world.modifiedBlocks.entries())
                    },
                    furnaces: this.furnaceSystem.getState(),
                    gameTime: this.gameTime
                };

                localStorage.setItem('minecraft2d_save', JSON.stringify(saveData));
                this.showNotification('Game Saved');
                console.log(`Game saved: ${saveData.world.modifiedBlocks.length} block changes`);
                return true;
            } catch (e) {
                console.error('Failed to save game:', e);
                this.showNotification('Save Failed!');
                return false;
            }
        }

        loadGame() {
            try {
                const saveJson = localStorage.getItem('minecraft2d_save');
                if (!saveJson) return null;

                const saveData = JSON.parse(saveJson);
                console.log(`Loading save from ${new Date(saveData.timestamp).toLocaleString()}`);
                return saveData;
            } catch (e) {
                console.error('Failed to load game:', e);
                return null;
            }
        }

        deleteSave() {
            localStorage.removeItem('minecraft2d_save');
            this.showNotification('Save Deleted');
        }

        showNotification(message) {
            const notif = this.dom.saveNotification;
            notif.textContent = message;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), 1500);
        }

        loop() {
            const now = performance.now();
            const dt = now - this.lastTime;
            this.lastTime = now;

            // FPS counter
            this.frameCount++;
            if (now - this.lastFpsUpdate >= 1000) {
                this.fps = this.frameCount;
                this.frameCount = 0;
                this.lastFpsUpdate = now;
                this.dom.fps.textContent = this.fps;
            }

            this.update(dt);
            this.render();

            requestAnimationFrame(() => this.loop());
        }
    }

    // --- START GAME ---
    window.addEventListener('load', () => {
        try {
            new Game();
            console.log('2D Minecraft initialized successfully!');
        } catch (error) {
            console.error('Game initialization failed:', error);
            alert('Failed to initialize game. Check console for details.');
        }
    });
    </script>
</body>
</html>
